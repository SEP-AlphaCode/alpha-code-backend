<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/models/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/__init__.py" />
              <option name="updatedContent" value="# This folder contains Pydantic models for request and response schemas.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/__init__.py" />
              <option name="updatedContent" value="# This folder contains business logic and robot control functions.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/osmo_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/osmo_service.py" />
              <option name="originalContent" value="from models.osmo import OsmoCardSequence, AlphaMiniAction, AlphaMiniActionList, ActionCardList, ActionCard, OsmoCard&#10;from typing import List, Optional&#10;from fastapi.responses import JSONResponse&#10;&#10;def parse_osmo_cards(card_sequence: OsmoCardSequence) -&gt; AlphaMiniActionList:&#10;    actions: List[AlphaMiniAction] = []&#10;    i = 0&#10;    while i &lt; len(card_sequence.cards):&#10;        card = card_sequence.cards[i]&#10;        ccolor = getattr(card, &quot;color&quot;, None)&#10;        cvalue = getattr(card, &quot;value&quot;, None)&#10;&#10;        if ccolor in (&quot;blue&quot;, &quot;red&quot;, &quot;orange&quot;):&#10;            step = 0&#10;            if i + 1 &lt; len(card_sequence.cards):&#10;                next_card = card_sequence.cards[i + 1]&#10;                ncolor = getattr(next_card, &quot;color&quot;, None)&#10;                nvalue = getattr(next_card, &quot;value&quot;, None)&#10;                if ncolor == &quot;yellow&quot; and nvalue is not None:&#10;                    step = int(nvalue)&#10;                    i += 1  # consume yellow card&#10;&#10;            if ccolor == &quot;blue&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;move_forward&quot;, value=step))&#10;            elif ccolor == &quot;red&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;jump_forward&quot;, value=step))&#10;            elif ccolor == &quot;orange&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;raise_hand&quot;, value=step))&#10;        i += 1&#10;    return AlphaMiniActionList(actions=actions)&#10;&#10;&#10;def export_actions_to_json(actions: AlphaMiniActionList, file_path: str):&#10;    import json&#10;    with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;        json.dump([action.dict() for action in actions.actions], f, ensure_ascii=False, indent=2)&#10;&#10;&#10;def export_actions_to_json_response(actions: AlphaMiniActionList):&#10;    return JSONResponse(content=[action.dict() for action in actions.actions])&#10;&#10;&#10;# ------------------ New Parser for ActionCardList ------------------&#10;&#10;def parse_action_card_list(action_card_list: ActionCardList) -&gt; AlphaMiniActionList:&#10;    actions: List[AlphaMiniAction] = []&#10;    for ac in action_card_list.action_cards:&#10;        color = ac.action.color&#10;        step = ac.step.value if ac.step and ac.step.value is not None else 0&#10;&#10;        if color == &quot;blue&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;move_forward&quot;, value=step))&#10;        elif color == &quot;red&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;jump_forward&quot;, value=step))&#10;        elif color == &quot;orange&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;raise_hand&quot;, value=step))&#10;        # 'gray' bị bỏ qua hoàn toàn&#10;    return AlphaMiniActionList(actions=actions)&#10;&#10;# ------------------ Recognizer ------------------&#10;&#10;def recognize_action_cards_from_image(image_path: str) -&gt; ActionCardList:&#10;    import cv2&#10;    import numpy as np&#10;    import pytesseract&#10;&#10;    img = cv2.imread(image_path)&#10;    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)&#10;&#10;    # Range màu&#10;    color_ranges = {&#10;        'blue': ([90, 80, 60], [130, 255, 255]),&#10;        'yellow': ([20, 150, 150], [40, 255, 255]),&#10;        'orange': ([5, 100, 100], [25, 255, 255]),&#10;        'red1': ([0, 100, 100], [10, 255, 255]),&#10;        'red2': ([160, 100, 100], [179, 255, 255]),&#10;    }&#10;&#10;    detected_cards = []&#10;&#10;    # Detect màu action&#10;    for color, rng in color_ranges.items():&#10;        lower = np.array(rng['lower'], dtype=np.uint8)&#10;        upper = np.array(rng['upper'], dtype=np.uint8)&#10;        mask = cv2.inRange(hsv, lower, upper)&#10;&#10;        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)&#10;        for c in cnts:&#10;            x, y, w, h = cv2.boundingRect(c)&#10;            if w &gt; 20 and h &gt; 20:&#10;                if color in ['red1', 'red2']:&#10;                    color_name = 'red'&#10;                else:&#10;                    color_name = color&#10;&#10;                if color_name != 'gray':&#10;                    detected_cards.append({&#10;                        &quot;color&quot;: color_name,&#10;                        &quot;x&quot;: x,&#10;                        &quot;y&quot;: y,&#10;                        &quot;w&quot;: w,&#10;                        &quot;h&quot;: h&#10;                    })&#10;&#10;    # Sắp xếp từ trái qua phải&#10;    detected_cards.sort(key=lambda c: c['x'])&#10;&#10;    action_cards = []&#10;    i = 0&#10;    while i &lt; len(detected_cards) - 1:&#10;        action_card = detected_cards[i]&#10;        step_card = detected_cards[i + 1]&#10;&#10;        # Chỉ ghép nếu step là yellow&#10;        if step_card['color'] == 'yellow':&#10;            # OCR đọc số từ step&#10;            roi = img[step_card['y']:step_card['y']+step_card['h'],&#10;                      step_card['x']:step_card['x']+step_card['w']]&#10;            step_text = pytesseract.image_to_string(roi, config='--psm 8 -c tessedit_char_whitelist=0123456789').strip()&#10;            step_value = int(step_text) if step_text.isdigit() else 0&#10;&#10;            action_cards.append(ActionCard(&#10;                action=OsmoCard(color=action_card['color'], value=None),  # action value = None&#10;                step=OsmoCard(color=&quot;yellow&quot;, value=step_value)&#10;            ))&#10;            i += 2&#10;        else:&#10;            i += 1&#10;&#10;    return ActionCardList(action_cards=action_cards)" />
              <option name="updatedContent" value="from models.osmo import OsmoCardSequence, AlphaMiniAction, AlphaMiniActionList, ActionCardList, ActionCard, OsmoCard&#10;from typing import List, Optional&#10;from fastapi.responses import JSONResponse&#10;&#10;def parse_osmo_cards(card_sequence: OsmoCardSequence) -&gt; AlphaMiniActionList:&#10;    actions: List[AlphaMiniAction] = []&#10;    i = 0&#10;    while i &lt; len(card_sequence.cards):&#10;        card = card_sequence.cards[i]&#10;        ccolor = getattr(card, &quot;color&quot;, None)&#10;        cvalue = getattr(card, &quot;value&quot;, None)&#10;&#10;        if ccolor in (&quot;blue&quot;, &quot;red&quot;, &quot;orange&quot;):&#10;            step = 0&#10;            if i + 1 &lt; len(card_sequence.cards):&#10;                next_card = card_sequence.cards[i + 1]&#10;                ncolor = getattr(next_card, &quot;color&quot;, None)&#10;                nvalue = getattr(next_card, &quot;value&quot;, None)&#10;                if ncolor == &quot;yellow&quot; and nvalue is not None:&#10;                    step = int(nvalue)&#10;                    i += 1  # consume yellow card&#10;&#10;            if ccolor == &quot;blue&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;move_forward&quot;, value=step))&#10;            elif ccolor == &quot;red&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;jump_forward&quot;, value=step))&#10;            elif ccolor == &quot;orange&quot;:&#10;                actions.append(AlphaMiniAction(action=&quot;raise_hand&quot;, value=step))&#10;        i += 1&#10;    return AlphaMiniActionList(actions=actions)&#10;&#10;&#10;def export_actions_to_json(actions: AlphaMiniActionList, file_path: str):&#10;    import json&#10;    with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;        json.dump([action.dict() for action in actions.actions], f, ensure_ascii=False, indent=2)&#10;&#10;&#10;def export_actions_to_json_response(actions: AlphaMiniActionList):&#10;    return JSONResponse(content=[action.dict() for action in actions.actions])&#10;&#10;&#10;# ------------------ New Parser for ActionCardList ------------------&#10;&#10;def parse_action_card_list(action_card_list: ActionCardList) -&gt; AlphaMiniActionList:&#10;    actions: List[AlphaMiniAction] = []&#10;    for ac in action_card_list.action_cards:&#10;        color = ac.action.color&#10;        step = ac.step.value if ac.step and ac.step.value is not None else 0&#10;&#10;        if color == &quot;blue&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;move_forward&quot;, value=step))&#10;        elif color == &quot;red&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;jump_forward&quot;, value=step))&#10;        elif color == &quot;orange&quot;:&#10;            actions.append(AlphaMiniAction(action=&quot;raise_hand&quot;, value=step))&#10;        # 'gray' bị bỏ qua hoàn toàn&#10;    return AlphaMiniActionList(actions=actions)&#10;&#10;# ------------------ Recognizer ------------------&#10;&#10;def recognize_action_cards_from_image(image_path: str) -&gt; ActionCardList:&#10;    import cv2&#10;    import numpy as np&#10;    import pytesseract&#10;    from models.osmo import ActionCard, OsmoCard, ActionCardList&#10;&#10;    color_ranges = {&#10;        'blue':   ([90, 80, 60], [130, 255, 255]),&#10;        'yellow': ([20, 150, 150], [40, 255, 255]),&#10;        'orange': ([5, 100, 100], [25, 255, 255]),&#10;        'red1':   ([0, 100, 100], [10, 255, 255]),&#10;        'red2':   ([160, 100, 100], [179, 255, 255]),&#10;    }&#10;&#10;    def detect_dominant_color(hsv_img):&#10;        largest_area = 0&#10;        detected_color = None&#10;        bbox = None&#10;        for color, (lower, upper) in color_ranges.items():&#10;            mask = cv2.inRange(hsv_img, np.array(lower), np.array(upper))&#10;            cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)&#10;            for c in cnts:&#10;                x, y, w, h = cv2.boundingRect(c)&#10;                area = w * h&#10;                if area &gt; largest_area:&#10;                    largest_area = area&#10;                    detected_color = color&#10;                    bbox = (x, y, w, h)&#10;        # Gộp red1/red2 thành red&#10;        if detected_color in (&quot;red1&quot;, &quot;red2&quot;):&#10;            detected_color = &quot;red&quot;&#10;        return detected_color, bbox&#10;&#10;    img = cv2.imread(image_path)&#10;    if img is None:&#10;        return ActionCardList(action_cards=[])&#10;    h, w, _ = img.shape&#10;    # Chia ảnh thành các hàng (mỗi hàng là 1 action card)&#10;    num_rows = 1&#10;    if h &gt; 120:&#10;        num_rows = h // 120&#10;    action_cards = []&#10;    for row in range(num_rows):&#10;        y1 = row * (h // num_rows)&#10;        y2 = (row + 1) * (h // num_rows)&#10;        row_img = img[y1:y2, :]&#10;        row_h, row_w, _ = row_img.shape&#10;        left_img = row_img[:, :row_w//2]&#10;        right_img = row_img[:, row_w//2:]&#10;        left_hsv = cv2.cvtColor(left_img, cv2.COLOR_BGR2HSV)&#10;        right_hsv = cv2.cvtColor(right_img, cv2.COLOR_BGR2HSV)&#10;        action_color, _ = detect_dominant_color(left_hsv)&#10;        step_color, bbox = detect_dominant_color(right_hsv)&#10;        detected_number = 0&#10;        if bbox:&#10;            x, y, ww, hh = bbox&#10;            crop = right_img[y:y+hh, x:x+ww]&#10;            text = pytesseract.image_to_string(&#10;                crop,&#10;                config='--psm 8 -c tessedit_char_whitelist=0123456789'&#10;            ).strip()&#10;            detected_number = int(text) if text.isdigit() else 0&#10;        action_cards.append(ActionCard(&#10;            action=OsmoCard(color=action_color, value=None),&#10;            step=OsmoCard(color=step_color, value=detected_number)&#10;        ))&#10;    return ActionCardList(action_cards=action_cards)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>