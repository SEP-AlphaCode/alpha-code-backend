<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# Environment Configuration&#10;# Server Settings&#10;HOST=127.0.0.1&#10;PORT=8000&#10;DEBUG=True&#10;&#10;# Database&#10;DATABASE_URL=sqlite:///./alpha_mini.db&#10;&#10;# Robot Connection&#10;ROBOT_IP=&#10;ROBOT_PORT=20001&#10;ROBOT_TIMEOUT=30&#10;&#10;# File Upload Limits&#10;MAX_FILE_SIZE=104857600  # 100MB in bytes&#10;&#10;# Audio Analysis Settings&#10;SAMPLE_RATE=22050&#10;HOP_LENGTH=512&#10;FRAME_LENGTH=2048&#10;&#10;# Choreography Settings&#10;MIN_BPM=60&#10;MAX_BPM=180&#10;BEAT_THRESHOLD=0.3" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/__init__.py" />
              <option name="updatedContent" value="# Tạo __init__.py files để Python nhận diện các thư mục là packages" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/endpoints/choreography.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/endpoints/choreography.py" />
              <option name="updatedContent" value="from fastapi import APIRouter, HTTPException&#10;from typing import List, Dict, Any&#10;import os&#10;&#10;from app.models.schemas import ChoreographyData, ChoreographySegment&#10;from app.services.choreography import ChoreographyService&#10;&#10;router = APIRouter()&#10;choreography_service = ChoreographyService()&#10;&#10;@router.post(&quot;/generate/{analysis_id}&quot;, response_model=ChoreographyData)&#10;async def generate_choreography(analysis_id: str):&#10;    &quot;&quot;&quot;Tạo vũ đạo tự động dựa trên kết quả phân tích nhạc&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreography = await choreography_service.generate_choreography(analysis_id)&#10;        return choreography&#10;        &#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;Music analysis not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error generating choreography: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/list&quot;, response_model=List[Dict[str, Any]])&#10;async def list_choreographies():&#10;    &quot;&quot;&quot;Liệt kê tất cả vũ đạo đã tạo&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreographies = await choreography_service.list_choreographies()&#10;        return choreographies&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error listing choreographies: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/{choreography_id}&quot;, response_model=ChoreographyData)&#10;async def get_choreography(choreography_id: str):&#10;    &quot;&quot;&quot;Lấy thông tin chi tiết vũ đạo&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreography = await choreography_service.load_choreography(choreography_id)&#10;        return choreography&#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;Choreography not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error loading choreography: {str(e)}&quot;)&#10;&#10;@router.delete(&quot;/{choreography_id}&quot;)&#10;async def delete_choreography(choreography_id: str):&#10;    &quot;&quot;&quot;Xóa vũ đạo&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreography_file = f&quot;data/choreography/{choreography_id}.json&quot;&#10;        &#10;        if not os.path.exists(choreography_file):&#10;            raise HTTPException(status_code=404, detail=&quot;Choreography not found&quot;)&#10;        &#10;        os.remove(choreography_file)&#10;        &#10;        return {&quot;success&quot;: True, &quot;message&quot;: &quot;Choreography deleted successfully&quot;}&#10;        &#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error deleting choreography: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/{choreography_id}/segments&quot;, response_model=List[ChoreographySegment])&#10;async def get_choreography_segments(choreography_id: str):&#10;    &quot;&quot;&quot;Lấy danh sách segments của vũ đạo&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreography = await choreography_service.load_choreography(choreography_id)&#10;        return choreography.segments&#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;Choreography not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error loading segments: {str(e)}&quot;)&#10;&#10;@router.post(&quot;/{choreography_id}/optimize&quot;)&#10;async def optimize_choreography(choreography_id: str):&#10;    &quot;&quot;&quot;Tối ưu hóa vũ đạo (có thể thêm logic tối ưu sau)&quot;&quot;&quot;&#10;    &#10;    try:&#10;        # Load choreography hiện tại&#10;        choreography = await choreography_service.load_choreography(choreography_id)&#10;        &#10;        # Có thể thêm logic tối ưu hóa ở đây&#10;        # Ví dụ: loại bỏ segments quá ngắn, smooth transitions, etc.&#10;        &#10;        return {&#10;            &quot;success&quot;: True,&#10;            &quot;message&quot;: &quot;Choreography optimization completed&quot;,&#10;            &quot;choreography_id&quot;: choreography_id&#10;        }&#10;        &#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;Choreography not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error optimizing choreography: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/stats/overview&quot;)&#10;async def get_choreography_stats():&#10;    &quot;&quot;&quot;Lấy thống kê tổng quan về vũ đạo&quot;&quot;&quot;&#10;    &#10;    try:&#10;        choreographies = await choreography_service.list_choreographies()&#10;        &#10;        total_count = len(choreographies)&#10;        total_duration = sum(c.get(&quot;total_duration&quot;, 0) for c in choreographies)&#10;        avg_bpm = sum(c.get(&quot;bpm&quot;, 0) for c in choreographies) / max(total_count, 1)&#10;        &#10;        # Thống kê theo BPM range&#10;        bpm_ranges = {&#10;            &quot;slow (60-90)&quot;: 0,&#10;            &quot;medium (90-120)&quot;: 0,&#10;            &quot;fast (120-150)&quot;: 0,&#10;            &quot;very_fast (150+)&quot;: 0&#10;        }&#10;        &#10;        for c in choreographies:&#10;            bpm = c.get(&quot;bpm&quot;, 0)&#10;            if bpm &lt; 90:&#10;                bpm_ranges[&quot;slow (60-90)&quot;] += 1&#10;            elif bpm &lt; 120:&#10;                bpm_ranges[&quot;medium (90-120)&quot;] += 1&#10;            elif bpm &lt; 150:&#10;                bpm_ranges[&quot;fast (120-150)&quot;] += 1&#10;            else:&#10;                bpm_ranges[&quot;very_fast (150+)&quot;] += 1&#10;        &#10;        return {&#10;            &quot;total_choreographies&quot;: total_count,&#10;            &quot;total_duration_minutes&quot;: round(total_duration / 60, 2),&#10;            &quot;average_bpm&quot;: round(avg_bpm, 2),&#10;            &quot;bpm_distribution&quot;: bpm_ranges&#10;        }&#10;        &#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error getting stats: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/endpoints/music.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/endpoints/music.py" />
              <option name="updatedContent" value="from fastapi import APIRouter, UploadFile, File, HTTPException, Depends&#10;from fastapi.responses import JSONResponse&#10;from typing import List, Optional&#10;import os&#10;import uuid&#10;import aiofiles&#10;from pathlib import Path&#10;&#10;from app.models.schemas import (&#10;    MusicAnalysisRequest, &#10;    MusicAnalysisResult, &#10;    UploadResponse&#10;)&#10;from app.services.music_analysis import MusicAnalysisService&#10;from app.core.config import settings&#10;&#10;router = APIRouter()&#10;music_service = MusicAnalysisService()&#10;&#10;@router.post(&quot;/upload&quot;, response_model=UploadResponse)&#10;async def upload_music_file(file: UploadFile = File(...)):&#10;    &quot;&quot;&quot;Upload file nhạc để phân tích&quot;&quot;&quot;&#10;    &#10;    # Kiểm tra định dạng file&#10;    file_extension = Path(file.filename).suffix.lower()&#10;    if file_extension not in settings.ALLOWED_AUDIO_EXTENSIONS:&#10;        raise HTTPException(&#10;            status_code=400,&#10;            detail=f&quot;Unsupported audio format. Allowed: {settings.ALLOWED_AUDIO_EXTENSIONS}&quot;&#10;        )&#10;    &#10;    # Kiểm tra kích thước file&#10;    content = await file.read()&#10;    if len(content) &gt; settings.MAX_FILE_SIZE:&#10;        raise HTTPException(&#10;            status_code=400,&#10;            detail=f&quot;File too large. Max size: {settings.MAX_FILE_SIZE} bytes&quot;&#10;        )&#10;    &#10;    try:&#10;        # Tạo tên file unique&#10;        file_id = str(uuid.uuid4())&#10;        filename = f&quot;{file_id}_{file.filename}&quot;&#10;        file_path = f&quot;uploads/music/{filename}&quot;&#10;        &#10;        # Lưu file&#10;        async with aiofiles.open(file_path, 'wb') as f:&#10;            await f.write(content)&#10;        &#10;        return UploadResponse(&#10;            success=True,&#10;            message=&quot;File uploaded successfully&quot;,&#10;            file_id=file_id,&#10;            filename=filename&#10;        )&#10;        &#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error uploading file: {str(e)}&quot;)&#10;&#10;@router.post(&quot;/analyze/{file_id}&quot;, response_model=MusicAnalysisResult)&#10;async def analyze_music_file(file_id: str):&#10;    &quot;&quot;&quot;Phân tích file nhạc đã upload&quot;&quot;&quot;&#10;    &#10;    try:&#10;        # Tìm file trong thư mục uploads&#10;        upload_dir = &quot;uploads/music&quot;&#10;        target_file = None&#10;        &#10;        for filename in os.listdir(upload_dir):&#10;            if filename.startswith(file_id):&#10;                target_file = filename&#10;                break&#10;        &#10;        if not target_file:&#10;            raise HTTPException(status_code=404, detail=&quot;File not found&quot;)&#10;        &#10;        file_path = f&quot;{upload_dir}/{target_file}&quot;&#10;        &#10;        # Phân tích file&#10;        result = await music_service.analyze_audio_file(file_path, target_file)&#10;        &#10;        return result&#10;        &#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;File not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error analyzing file: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/analysis/{analysis_id}&quot;, response_model=MusicAnalysisResult)&#10;async def get_analysis_result(analysis_id: str):&#10;    &quot;&quot;&quot;Lấy kết quả phân tích đã lưu&quot;&quot;&quot;&#10;    &#10;    try:&#10;        result = await music_service.load_analysis_result(analysis_id)&#10;        return result&#10;    except FileNotFoundError:&#10;        raise HTTPException(status_code=404, detail=&quot;Analysis result not found&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error loading analysis: {str(e)}&quot;)&#10;&#10;@router.get(&quot;/analysis&quot;, response_model=List[dict])&#10;async def list_analysis_results():&#10;    &quot;&quot;&quot;Liệt kê tất cả kết quả phân tích&quot;&quot;&quot;&#10;    &#10;    try:&#10;        results = await music_service.list_analysis_results()&#10;        return results&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error listing analysis results: {str(e)}&quot;)&#10;&#10;@router.delete(&quot;/analysis/{analysis_id}&quot;)&#10;async def delete_analysis_result(analysis_id: str):&#10;    &quot;&quot;&quot;Xóa kết quả phân tích&quot;&quot;&quot;&#10;    &#10;    try:&#10;        analysis_file = f&quot;data/analysis/{analysis_id}.json&quot;&#10;        &#10;        if not os.path.exists(analysis_file):&#10;            raise HTTPException(status_code=404, detail=&quot;Analysis result not found&quot;)&#10;        &#10;        os.remove(analysis_file)&#10;        &#10;        return {&quot;success&quot;: True, &quot;message&quot;: &quot;Analysis result deleted successfully&quot;}&#10;        &#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Error deleting analysis: {str(e)}&quot;)&#10;&#10;@router.post(&quot;/upload-batch&quot;)&#10;async def upload_multiple_music_files(files: List[UploadFile] = File(...)):&#10;    &quot;&quot;&quot;Upload nhiều file nhạc cùng lúc&quot;&quot;&quot;&#10;    &#10;    results = []&#10;    &#10;    for file in files:&#10;        try:&#10;            # Kiểm tra định dạng&#10;            file_extension = Path(file.filename).suffix.lower()&#10;            if file_extension not in settings.ALLOWED_AUDIO_EXTENSIONS:&#10;                results.append({&#10;                    &quot;filename&quot;: file.filename,&#10;                    &quot;success&quot;: False,&#10;                    &quot;error&quot;: f&quot;Unsupported format: {file_extension}&quot;&#10;                })&#10;                continue&#10;            &#10;            # Upload file&#10;            content = await file.read()&#10;            if len(content) &gt; settings.MAX_FILE_SIZE:&#10;                results.append({&#10;                    &quot;filename&quot;: file.filename,&#10;                    &quot;success&quot;: False,&#10;                    &quot;error&quot;: &quot;File too large&quot;&#10;                })&#10;                continue&#10;            &#10;            file_id = str(uuid.uuid4())&#10;            filename = f&quot;{file_id}_{file.filename}&quot;&#10;            file_path = f&quot;uploads/music/{filename}&quot;&#10;            &#10;            async with aiofiles.open(file_path, 'wb') as f:&#10;                await f.write(content)&#10;            &#10;            results.append({&#10;                &quot;filename&quot;: file.filename,&#10;                &quot;success&quot;: True,&#10;                &quot;file_id&quot;: file_id,&#10;                &quot;saved_as&quot;: filename&#10;            })&#10;            &#10;        except Exception as e:&#10;            results.append({&#10;                &quot;filename&quot;: file.filename,&#10;                &quot;success&quot;: False,&#10;                &quot;error&quot;: str(e)&#10;            })&#10;    &#10;    return {&quot;results&quot;: results}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/schemas.py" />
              <option name="originalContent" value="from pydantic import BaseModel&#10;from typing import List, Optional, Dict, Any&#10;from datetime import datetime&#10;from enum import Enum&#10;&#10;class AudioFormat(str, Enum):&#10;    MP3 = &quot;mp3&quot;&#10;    WAV = &quot;wav&quot;&#10;    FLAC = &quot;flac&quot;&#10;    M4A = &quot;m4a&quot;&#10;    AAC = &quot;aac&quot;&#10;&#10;class RobotAction(str, Enum):&#10;    DANCE = &quot;dance&quot;&#10;    WALK = &quot;walk&quot;&#10;    ARM_MOVEMENT = &quot;arm_movement&quot;&#10;    HEAD_MOVEMENT = &quot;head_movement&quot;&#10;    POSE = &quot;pose&quot;&#10;    STOP = &quot;stop&quot;&#10;&#10;class MusicAnalysisRequest(BaseModel):&#10;    filename: str&#10;    analyze_tempo: bool = True&#10;    analyze_beats: bool = True&#10;    analyze_spectral: bool = True&#10;    generate_choreography: bool = True&#10;&#10;class MusicAnalysisResult(BaseModel):&#10;    id: str&#10;    filename: str&#10;    duration: float&#10;    tempo: Optional[float] = None&#10;    beats: Optional[List[float]] = None&#10;    spectral_features: Optional[Dict[str, Any]] = None&#10;    energy_analysis: Optional[Dict[str, Any]] = None&#10;    analysis_timestamp: datetime&#10;    file_path: str&#10;&#10;class BeatInfo(BaseModel):&#10;    time: float&#10;    confidence: float&#10;    intensity: float&#10;&#10;class ChoreographySegment(BaseModel):&#10;    start_time: float&#10;    end_time: float&#10;    action: RobotAction&#10;    parameters: Dict[str, Any]&#10;    ubx_file: Optional[str] = None&#10;    energy_level: Optional[str] = &quot;medium&quot;&#10;    notes: Optional[str] = &quot;&quot;&#10;&#10;class ChoreographyData(BaseModel):&#10;    id: str&#10;    name: str&#10;    music_file: str&#10;    music_analysis_id: str&#10;    segments: List[ChoreographySegment]&#10;    total_duration: float&#10;    bpm: float&#10;    created_at: datetime&#10;    style_preferences: Optional[Dict[str, Any]] = {}&#10;&#10;class RobotStatus(BaseModel):&#10;    connected: bool&#10;    battery_level: Optional[int] = None&#10;    current_action: Optional[RobotAction] = None&#10;    position: Optional[Dict[str, float]] = None&#10;    timestamp: datetime&#10;&#10;class RobotCommand(BaseModel):&#10;    action: RobotAction&#10;    parameters: Dict[str, Any]&#10;    duration: Optional[float] = None&#10;    ubx_file: Optional[str] = None&#10;&#10;class RobotActionData(BaseModel):&#10;    &quot;&quot;&quot;Data class để đại diện cho robot action với thông tin chi tiết&quot;&quot;&quot;&#10;    type: str&#10;    name: str&#10;    start_time: float&#10;    duration: float&#10;    intensity: float&#10;    parameters: Dict[str, Any] = {}&#10;&#10;class UploadResponse(BaseModel):&#10;    success: bool&#10;    message: str&#10;    file_id: Optional[str] = None&#10;    filename: Optional[str] = None&#10;" />
              <option name="updatedContent" value="from pydantic import BaseModel&#10;from typing import List, Optional, Dict, Any&#10;from datetime import datetime&#10;from enum import Enum&#10;&#10;class AudioFormat(str, Enum):&#10;    MP3 = &quot;mp3&quot;&#10;    WAV = &quot;wav&quot;&#10;    FLAC = &quot;flac&quot;&#10;    M4A = &quot;m4a&quot;&#10;    AAC = &quot;aac&quot;&#10;&#10;class RobotAction(str, Enum):&#10;    DANCE = &quot;dance&quot;&#10;    WALK = &quot;walk&quot;&#10;    ARM_MOVEMENT = &quot;arm_movement&quot;&#10;    HEAD_MOVEMENT = &quot;head_movement&quot;&#10;    POSE = &quot;pose&quot;&#10;    STOP = &quot;stop&quot;&#10;&#10;class MusicAnalysisRequest(BaseModel):&#10;    filename: str&#10;    analyze_tempo: bool = True&#10;    analyze_beats: bool = True&#10;    analyze_spectral: bool = True&#10;    generate_choreography: bool = True&#10;&#10;class MusicAnalysisResult(BaseModel):&#10;    id: str&#10;    filename: str&#10;    duration: float&#10;    tempo: Optional[float] = None&#10;    beats: Optional[List[float]] = None&#10;    spectral_features: Optional[Dict[str, Any]] = None&#10;    energy_analysis: Optional[Dict[str, Any]] = None&#10;    analysis_timestamp: datetime&#10;    file_path: str&#10;&#10;class BeatInfo(BaseModel):&#10;    time: float&#10;    confidence: float&#10;    intensity: float&#10;&#10;class ChoreographySegment(BaseModel):&#10;    start_time: float&#10;    end_time: float&#10;    action: RobotAction&#10;    parameters: Dict[str, Any]&#10;    ubx_file: Optional[str] = None&#10;    energy_level: Optional[str] = &quot;medium&quot;&#10;    notes: Optional[str] = &quot;&quot;&#10;&#10;class ChoreographyData(BaseModel):&#10;    id: str&#10;    name: str&#10;    music_file: str&#10;    music_analysis_id: str&#10;    segments: List[ChoreographySegment]&#10;    total_duration: float&#10;    bpm: float&#10;    created_at: datetime&#10;    style_preferences: Optional[Dict[str, Any]] = {}&#10;&#10;class RobotStatus(BaseModel):&#10;    connected: bool&#10;    battery_level: Optional[int] = None&#10;    current_action: Optional[RobotAction] = None&#10;    position: Optional[Dict[str, float]] = None&#10;    timestamp: datetime&#10;&#10;class RobotCommand(BaseModel):&#10;    action: RobotAction&#10;    parameters: Dict[str, Any]&#10;    duration: Optional[float] = None&#10;    ubx_file: Optional[str] = None&#10;&#10;class RobotActionData(BaseModel):&#10;    &quot;&quot;&quot;Data class để đại diện cho robot action với thông tin chi tiết&quot;&quot;&quot;&#10;    type: str&#10;    name: str&#10;    start_time: float&#10;    duration: float&#10;    intensity: str  # Changed from float to str to accept 'low', 'medium', 'high'&#10;    parameters: Dict[str, Any] = {}&#10;&#10;class UploadResponse(BaseModel):&#10;    success: bool&#10;    message: str&#10;    file_id: Optional[str] = None&#10;    filename: Optional[str] = None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/ai_choreographer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/ai_choreographer.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;AI Choreographer Service&#10;Tạo choreography tự động dựa trên phân tích âm nhạc và AI&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import numpy as np&#10;import random&#10;from typing import List, Dict, Any, Tuple, Optional&#10;import uuid&#10;from datetime import datetime&#10;&#10;from app.services.alpha_mini_actions import alpha_mini_actions_service, AlphaAction, AlphaExpression&#10;from app.models.schemas import MusicAnalysisResult, ChoreographyData, ChoreographySegment, RobotAction, RobotActionData&#10;&#10;class AIChoreographerService:&#10;    &quot;&quot;&quot;Service tạo choreography thông minh dựa trên AI và phân tích nhạc&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.actions_service = alpha_mini_actions_service&#10;        self.emotion_mapping = self._create_emotion_mapping()&#10;        self.tempo_emotion_mapping = self._create_tempo_emotion_mapping()&#10;        &#10;    def _create_emotion_mapping(self) -&gt; Dict[str, List[str]]:&#10;        &quot;&quot;&quot;Mapping giữa đặc trưng âm nhạc và emotions&quot;&quot;&quot;&#10;        return {&#10;            &quot;high_energy&quot;: [&quot;energetic&quot;, &quot;excited&quot;, &quot;powerful&quot;, &quot;happy&quot;],&#10;            &quot;medium_energy&quot;: [&quot;happy&quot;, &quot;friendly&quot;, &quot;playful&quot;, &quot;confident&quot;],&#10;            &quot;low_energy&quot;: [&quot;calm&quot;, &quot;gentle&quot;, &quot;peaceful&quot;, &quot;graceful&quot;],&#10;            &quot;fast_tempo&quot;: [&quot;energetic&quot;, &quot;excited&quot;, &quot;powerful&quot;, &quot;athletic&quot;],&#10;            &quot;medium_tempo&quot;: [&quot;happy&quot;, &quot;friendly&quot;, &quot;balanced&quot;, &quot;confident&quot;],&#10;            &quot;slow_tempo&quot;: [&quot;calm&quot;, &quot;graceful&quot;, &quot;gentle&quot;, &quot;peaceful&quot;],&#10;            &quot;high_spectral&quot;: [&quot;bright&quot;, &quot;excited&quot;, &quot;energetic&quot;, &quot;powerful&quot;],&#10;            &quot;low_spectral&quot;: [&quot;warm&quot;, &quot;calm&quot;, &quot;gentle&quot;, &quot;soothing&quot;]&#10;        }&#10;    &#10;    def _create_tempo_emotion_mapping(self) -&gt; Dict[str, str]:&#10;        &quot;&quot;&quot;Mapping giữa tempo và emotion chính&quot;&quot;&quot;&#10;        return {&#10;            &quot;very_slow&quot;: &quot;calm&quot;,      # &lt; 70 BPM&#10;            &quot;slow&quot;: &quot;gentle&quot;,         # 70-90 BPM&#10;            &quot;moderate&quot;: &quot;happy&quot;,      # 90-120 BPM&#10;            &quot;fast&quot;: &quot;energetic&quot;,      # 120-160 BPM&#10;            &quot;very_fast&quot;: &quot;excited&quot;    # &gt; 160 BPM&#10;        }&#10;    &#10;    def _analyze_music_emotion(self, music_analysis: MusicAnalysisResult) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích emotion từ đặc trưng âm nhạc&quot;&quot;&quot;&#10;        tempo = music_analysis.tempo&#10;        &#10;        # Phân loại tempo&#10;        if tempo &lt; 70:&#10;            tempo_category = &quot;very_slow&quot;&#10;        elif tempo &lt; 90:&#10;            tempo_category = &quot;slow&quot;&#10;        elif tempo &lt; 120:&#10;            tempo_category = &quot;moderate&quot;&#10;        elif tempo &lt; 160:&#10;            tempo_category = &quot;fast&quot;&#10;        else:&#10;            tempo_category = &quot;very_fast&quot;&#10;        &#10;        # Phân tích energy từ spectral features&#10;        spectral_features = music_analysis.spectral_features&#10;        avg_spectral_centroid = np.mean(spectral_features.get(&quot;spectral_centroid&quot;, [0]))&#10;        avg_spectral_rolloff = np.mean(spectral_features.get(&quot;spectral_rolloff&quot;, [0]))&#10;        avg_zero_crossing = np.mean(spectral_features.get(&quot;zero_crossing_rate&quot;, [0]))&#10;        &#10;        # Tính energy level&#10;        energy_score = (avg_spectral_centroid / 4000.0 + &#10;                       avg_spectral_rolloff / 8000.0 + &#10;                       avg_zero_crossing * 10) / 3&#10;        &#10;        if energy_score &gt; 0.7:&#10;            energy_category = &quot;high_energy&quot;&#10;        elif energy_score &gt; 0.4:&#10;            energy_category = &quot;medium_energy&quot;&#10;        else:&#10;            energy_category = &quot;low_energy&quot;&#10;        &#10;        # Xác định emotion chính&#10;        primary_emotion = self.tempo_emotion_mapping[tempo_category]&#10;        &#10;        # Lấy danh sách emotions phù hợp&#10;        suitable_emotions = []&#10;        suitable_emotions.extend(self.emotion_mapping.get(tempo_category.replace(&quot;_&quot;, &quot;_tempo&quot;), []))&#10;        suitable_emotions.extend(self.emotion_mapping.get(energy_category, []))&#10;        &#10;        # Loại bỏ duplicate và thêm primary emotion&#10;        suitable_emotions = list(set(suitable_emotions))&#10;        if primary_emotion not in suitable_emotions:&#10;            suitable_emotions.insert(0, primary_emotion)&#10;        &#10;        return {&#10;            &quot;primary_emotion&quot;: primary_emotion,&#10;            &quot;suitable_emotions&quot;: suitable_emotions,&#10;            &quot;tempo_category&quot;: tempo_category,&#10;            &quot;energy_category&quot;: energy_category,&#10;            &quot;energy_score&quot;: energy_score,&#10;            &quot;tempo&quot;: tempo&#10;        }&#10;    &#10;    def _select_actions_for_segment(self, &#10;                                   emotion_analysis: Dict[str, Any],&#10;                                   segment_duration: float,&#10;                                   beat_count: int,&#10;                                   is_climax: bool = False) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Chọn actions phù hợp cho một segment&quot;&quot;&quot;&#10;        &#10;        suitable_emotions = emotion_analysis[&quot;suitable_emotions&quot;]&#10;        energy_category = emotion_analysis[&quot;energy_category&quot;]&#10;        tempo_category = emotion_analysis[&quot;tempo_category&quot;]&#10;        &#10;        # Lấy actions phù hợp với emotion&#10;        candidate_actions = []&#10;        for emotion in suitable_emotions:&#10;            actions = self.actions_service.get_actions_by_emotion(emotion)&#10;            candidate_actions.extend(actions)&#10;        &#10;        # Loại bỏ duplicate&#10;        unique_actions = {}&#10;        for action in candidate_actions:&#10;            unique_actions[action.name] = action&#10;        candidate_actions = list(unique_actions.values())&#10;        &#10;        # Lọc actions theo tempo và energy&#10;        filtered_actions = []&#10;        for action in candidate_actions:&#10;            # Với tempo nhanh, ưu tiên actions có thể interrupt&#10;            if tempo_category in [&quot;fast&quot;, &quot;very_fast&quot;]:&#10;                if action.can_interrupt or action.duration_estimate &lt;= 3.0:&#10;                    filtered_actions.append(action)&#10;            # Với tempo chậm, có thể dùng actions dài hơn&#10;            elif tempo_category in [&quot;slow&quot;, &quot;very_slow&quot;]:&#10;                if action.duration_estimate &lt;= segment_duration:&#10;                    filtered_actions.append(action)&#10;            else:&#10;                if action.duration_estimate &lt;= segment_duration * 0.8:&#10;                    filtered_actions.append(action)&#10;        &#10;        if not filtered_actions:&#10;            filtered_actions = candidate_actions[:5]  # Fallback&#10;        &#10;        # Chọn actions dựa trên beat count và duration&#10;        selected_actions = []&#10;        remaining_duration = segment_duration&#10;        &#10;        # Nếu là climax, ưu tiên dance actions&#10;        if is_climax:&#10;            dance_actions = [a for a in filtered_actions if a.category == &quot;dance&quot;]&#10;            if dance_actions:&#10;                # Chọn 1-2 dance actions cho climax&#10;                selected_dance = random.choice(dance_actions)&#10;                if selected_dance.duration_estimate &lt;= remaining_duration:&#10;                    selected_actions.append(selected_dance)&#10;                    remaining_duration -= selected_dance.duration_estimate&#10;        &#10;        # Thêm actions khác để fill remaining duration&#10;        while remaining_duration &gt; 1.0 and len(selected_actions) &lt; beat_count:&#10;            suitable_actions = [a for a in filtered_actions &#10;                              if a.duration_estimate &lt;= remaining_duration and a not in selected_actions]&#10;            &#10;            if not suitable_actions:&#10;                break&#10;                &#10;            # Ưu tiên actions với intensity phù hợp&#10;            if energy_category == &quot;high_energy&quot;:&#10;                high_intensity = [a for a in suitable_actions if a.intensity in [&quot;high&quot;, &quot;medium&quot;]]&#10;                if high_intensity:&#10;                    suitable_actions = high_intensity&#10;            elif energy_category == &quot;low_energy&quot;:&#10;                low_intensity = [a for a in suitable_actions if a.intensity in [&quot;low&quot;, &quot;medium&quot;]]&#10;                if low_intensity:&#10;                    suitable_actions = low_intensity&#10;            &#10;            selected_action = random.choice(suitable_actions)&#10;            selected_actions.append(selected_action)&#10;            remaining_duration -= selected_action.duration_estimate&#10;        &#10;        return selected_actions&#10;    &#10;    def _select_expressions_for_segment(self, &#10;                                       emotion_analysis: Dict[str, Any],&#10;                                       action_count: int) -&gt; List[AlphaExpression]:&#10;        &quot;&quot;&quot;Chọn expressions phù hợp cho segment&quot;&quot;&quot;&#10;        &#10;        suitable_emotions = emotion_analysis[&quot;suitable_emotions&quot;]&#10;        &#10;        # Lấy expressions phù hợp&#10;        candidate_expressions = []&#10;        for emotion in suitable_emotions:&#10;            expressions = self.actions_service.get_expressions_by_emotion(emotion)&#10;            candidate_expressions.extend(expressions)&#10;        &#10;        # Loại bỏ duplicate&#10;        unique_expressions = {}&#10;        for expr in candidate_expressions:&#10;            unique_expressions[expr.name] = expr&#10;        candidate_expressions = list(unique_expressions.values())&#10;        &#10;        if not candidate_expressions:&#10;            # Fallback to neutral expressions&#10;            candidate_expressions = self.actions_service.get_expressions_by_emotion(&quot;neutral&quot;)&#10;        &#10;        # Chọn expressions (thường ít hơn actions)&#10;        expression_count = min(len(candidate_expressions), max(1, action_count // 2))&#10;        selected_expressions = random.sample(candidate_expressions, expression_count)&#10;        &#10;        return selected_expressions&#10;    &#10;    def _create_robot_actions(self, &#10;                            actions: List[AlphaAction], &#10;                            expressions: List[AlphaExpression],&#10;                            segment_start: float,&#10;                            segment_duration: float) -&gt; List[RobotActionData]:&#10;        &quot;&quot;&quot;Tạo RobotActionData objects từ actions và expressions&quot;&quot;&quot;&#10;&#10;        robot_actions = []&#10;        current_time = segment_start&#10;        &#10;        # Thêm expressions trước&#10;        for i, expression in enumerate(expressions):&#10;            robot_action = RobotActionData(&#10;                type=&quot;expression&quot;,&#10;                name=expression.name,&#10;                start_time=current_time + i * 0.5,  # Stagger expressions&#10;                duration=2.0,  # Default expression duration&#10;                intensity=expression.intensity,&#10;                parameters={&quot;emotion&quot;: expression.emotion_type}&#10;            )&#10;            robot_actions.append(robot_action)&#10;&#10;        # Thêm actions&#10;        for action in actions:&#10;            if current_time + action.duration_estimate &lt;= segment_start + segment_duration:&#10;                robot_action = RobotActionData(&#10;                    type=&quot;action&quot; if action.category != &quot;dance&quot; else &quot;dance&quot;,&#10;                    name=action.name,&#10;                    start_time=current_time,&#10;                    duration=action.duration_estimate,&#10;                    intensity=action.intensity,&#10;                    parameters={&#10;                        &quot;can_interrupt&quot;: action.can_interrupt,&#10;                        &quot;category&quot;: action.category,&#10;                        &quot;emotion&quot;: action.emotion_type&#10;                    }&#10;                )&#10;                robot_actions.append(robot_action)&#10;                current_time += action.duration_estimate&#10;            else:&#10;                break&#10;        &#10;        return robot_actions&#10;    &#10;    async def create_intelligent_choreography(self, &#10;                                            music_analysis: MusicAnalysisResult,&#10;                                            preferences: Optional[Dict[str, Any]] = None) -&gt; ChoreographyData:&#10;        &quot;&quot;&quot;Tạo choreography thông minh từ phân tích nhạc&quot;&quot;&quot;&#10;        &#10;        try:&#10;            print(f&quot;Creating intelligent choreography for: {music_analysis.filename}&quot;)&#10;            &#10;            # Phân tích emotion từ nhạc&#10;            emotion_analysis = self._analyze_music_emotion(music_analysis)&#10;            print(f&quot;Music emotion analysis: {emotion_analysis}&quot;)&#10;            &#10;            # Tạo segments dựa trên beats và structure&#10;            segments = self._create_intelligent_segments(music_analysis, emotion_analysis)&#10;            &#10;            choreography_segments = []&#10;            &#10;            for i, segment in enumerate(segments):&#10;                segment_start = segment[&quot;start_time&quot;]&#10;                segment_duration = segment[&quot;duration&quot;]&#10;                beat_count = segment[&quot;beat_count&quot;]&#10;                is_climax = segment.get(&quot;is_climax&quot;, False)&#10;                &#10;                print(f&quot;Processing segment {i+1}: {segment_start:.1f}s - {segment_start + segment_duration:.1f}s&quot;)&#10;                &#10;                # Chọn actions cho segment&#10;                actions = self._select_actions_for_segment(&#10;                    emotion_analysis, segment_duration, beat_count, is_climax&#10;                )&#10;                &#10;                # Chọn expressions cho segment&#10;                expressions = self._select_expressions_for_segment(&#10;                    emotion_analysis, len(actions)&#10;                )&#10;                &#10;                # Tạo robot actions&#10;                robot_actions = self._create_robot_actions(&#10;                    actions, expressions, segment_start, segment_duration&#10;                )&#10;                &#10;                # Tạo choreography segment&#10;                choreography_segment = ChoreographySegment(&#10;                    start_time=segment_start,&#10;                    end_time=segment_start + segment_duration,&#10;                    action=RobotAction.DANCE,  # Use enum value&#10;                    parameters={&#10;                        &quot;actions&quot;: [action.dict() for action in robot_actions],&#10;                        &quot;tempo&quot;: music_analysis.tempo,&#10;                        &quot;primary_emotion&quot;: emotion_analysis[&quot;primary_emotion&quot;]&#10;                    },&#10;                    energy_level=&quot;medium&quot; if emotion_analysis[&quot;energy_score&quot;] &gt; 0.5 else &quot;low&quot;&#10;                )&#10;                &#10;                choreography_segments.append(choreography_segment)&#10;            &#10;            # Tạo choreography data&#10;            choreography_id = str(uuid.uuid4())&#10;            choreography_data = ChoreographyData(&#10;                id=choreography_id,&#10;                music_analysis_id=music_analysis.id,&#10;                filename=music_analysis.filename,&#10;                duration=music_analysis.duration,&#10;                segments=choreography_segments,&#10;                style=&quot;ai_generated&quot;,&#10;                created_at=datetime.now().isoformat(),&#10;                metadata={&#10;                    &quot;emotion_analysis&quot;: emotion_analysis,&#10;                    &quot;total_segments&quot;: len(choreography_segments),&#10;                    &quot;total_actions&quot;: sum(len(seg.actions) for seg in choreography_segments)&#10;                }&#10;            )&#10;            &#10;            print(f&quot;Created choreography with {len(choreography_segments)} segments&quot;)&#10;            return choreography_data&#10;            &#10;        except Exception as e:&#10;            print(f&quot;Error creating intelligent choreography: {e}&quot;)&#10;            raise&#10;    &#10;    def _create_intelligent_segments(self,&#10;                                   music_analysis: MusicAnalysisResult, &#10;                                   emotion_analysis: Dict[str, Any]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Tạo segments thông minh dựa trên phân tích nhạc&quot;&quot;&quot;&#10;        &#10;        duration = music_analysis.duration&#10;        tempo = music_analysis.tempo&#10;        beats = music_analysis.beats if music_analysis.beats else []&#10;        &#10;        segments = []&#10;        &#10;        # Tính segment length dựa trên tempo&#10;        if tempo &gt; 140:&#10;            base_segment_length = 4.0  # Fast songs - shorter segments&#10;        elif tempo &gt; 100:&#10;            base_segment_length = 6.0  # Medium tempo&#10;        else:&#10;            base_segment_length = 8.0  # Slow songs - longer segments&#10;        &#10;        current_time = 0.0&#10;        segment_count = 0&#10;        &#10;        while current_time &lt; duration:&#10;            segment_length = min(base_segment_length, duration - current_time)&#10;            &#10;            # Tính số beats trong segment&#10;            beats_in_segment = []&#10;            for beat_time in beats:&#10;                if current_time &lt;= beat_time &lt; current_time + segment_length:&#10;                    beats_in_segment.append(beat_time)&#10;            &#10;            beat_count = len(beats_in_segment)&#10;            if beat_count == 0:&#10;                beat_count = max(1, int(segment_length * tempo / 60))  # Estimate beats&#10;            &#10;            # Xác định climax (thường ở giữa bài)&#10;            is_climax = (duration * 0.4 &lt;= current_time &lt;= duration * 0.7)&#10;            &#10;            segment = {&#10;                &quot;start_time&quot;: current_time,&#10;                &quot;duration&quot;: segment_length,&#10;                &quot;beat_count&quot;: beat_count,&#10;                &quot;is_climax&quot;: is_climax,&#10;                &quot;beats&quot;: beats_in_segment&#10;            }&#10;            &#10;            segments.append(segment)&#10;            current_time += segment_length&#10;            segment_count += 1&#10;            &#10;            # Giới hạn số segments để tránh quá phức tạp&#10;            if segment_count &gt;= 20:&#10;                break&#10;        &#10;        return segments&#10;&#10;# Singleton instance&#10;ai_choreographer_service = AIChoreographerService()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;AI Choreographer Service&#10;Tạo choreography tự động dựa trên phân tích âm nhạc và AI&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import numpy as np&#10;import random&#10;from typing import List, Dict, Any, Tuple, Optional&#10;import uuid&#10;from datetime import datetime&#10;from pathlib import Path&#10;&#10;from app.services.alpha_mini_actions import alpha_mini_actions_service, AlphaAction, AlphaExpression&#10;from app.models.schemas import MusicAnalysisResult, ChoreographyData, ChoreographySegment, RobotAction, RobotActionData&#10;&#10;class AIChoreographerService:&#10;    &quot;&quot;&quot;Service tạo choreography thông minh dựa trên AI và phân tích nhạc&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.actions_service = alpha_mini_actions_service&#10;        self.emotion_mapping = self._create_emotion_mapping()&#10;        self.tempo_emotion_mapping = self._create_tempo_emotion_mapping()&#10;        &#10;    def _create_emotion_mapping(self) -&gt; Dict[str, List[str]]:&#10;        &quot;&quot;&quot;Mapping giữa đặc trưng âm nhạc và emotions&quot;&quot;&quot;&#10;        return {&#10;            &quot;high_energy&quot;: [&quot;energetic&quot;, &quot;excited&quot;, &quot;powerful&quot;, &quot;happy&quot;],&#10;            &quot;medium_energy&quot;: [&quot;happy&quot;, &quot;friendly&quot;, &quot;playful&quot;, &quot;confident&quot;],&#10;            &quot;low_energy&quot;: [&quot;calm&quot;, &quot;gentle&quot;, &quot;peaceful&quot;, &quot;graceful&quot;],&#10;            &quot;fast_tempo&quot;: [&quot;energetic&quot;, &quot;excited&quot;, &quot;powerful&quot;, &quot;athletic&quot;],&#10;            &quot;medium_tempo&quot;: [&quot;happy&quot;, &quot;friendly&quot;, &quot;balanced&quot;, &quot;confident&quot;],&#10;            &quot;slow_tempo&quot;: [&quot;calm&quot;, &quot;graceful&quot;, &quot;gentle&quot;, &quot;peaceful&quot;],&#10;            &quot;high_spectral&quot;: [&quot;bright&quot;, &quot;excited&quot;, &quot;energetic&quot;, &quot;powerful&quot;],&#10;            &quot;low_spectral&quot;: [&quot;warm&quot;, &quot;calm&quot;, &quot;gentle&quot;, &quot;soothing&quot;]&#10;        }&#10;    &#10;    def _create_tempo_emotion_mapping(self) -&gt; Dict[str, str]:&#10;        &quot;&quot;&quot;Mapping giữa tempo và emotion chính&quot;&quot;&quot;&#10;        return {&#10;            &quot;very_slow&quot;: &quot;calm&quot;,      # &lt; 70 BPM&#10;            &quot;slow&quot;: &quot;gentle&quot;,         # 70-90 BPM&#10;            &quot;moderate&quot;: &quot;happy&quot;,      # 90-120 BPM&#10;            &quot;fast&quot;: &quot;energetic&quot;,      # 120-160 BPM&#10;            &quot;very_fast&quot;: &quot;excited&quot;    # &gt; 160 BPM&#10;        }&#10;    &#10;    def _analyze_music_emotion(self, music_analysis: MusicAnalysisResult) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích emotion từ đặc trưng âm nhạc&quot;&quot;&quot;&#10;        tempo = music_analysis.tempo&#10;        &#10;        # Phân loại tempo&#10;        if tempo &lt; 70:&#10;            tempo_category = &quot;very_slow&quot;&#10;        elif tempo &lt; 90:&#10;            tempo_category = &quot;slow&quot;&#10;        elif tempo &lt; 120:&#10;            tempo_category = &quot;moderate&quot;&#10;        elif tempo &lt; 160:&#10;            tempo_category = &quot;fast&quot;&#10;        else:&#10;            tempo_category = &quot;very_fast&quot;&#10;        &#10;        # Phân tích energy từ spectral features&#10;        spectral_features = music_analysis.spectral_features&#10;        avg_spectral_centroid = np.mean(spectral_features.get(&quot;spectral_centroid&quot;, [0]))&#10;        avg_spectral_rolloff = np.mean(spectral_features.get(&quot;spectral_rolloff&quot;, [0]))&#10;        avg_zero_crossing = np.mean(spectral_features.get(&quot;zero_crossing_rate&quot;, [0]))&#10;        &#10;        # Tính energy level&#10;        energy_score = (avg_spectral_centroid / 4000.0 + &#10;                       avg_spectral_rolloff / 8000.0 + &#10;                       avg_zero_crossing * 10) / 3&#10;        &#10;        if energy_score &gt; 0.7:&#10;            energy_category = &quot;high_energy&quot;&#10;        elif energy_score &gt; 0.4:&#10;            energy_category = &quot;medium_energy&quot;&#10;        else:&#10;            energy_category = &quot;low_energy&quot;&#10;        &#10;        # Xác định emotion chính&#10;        primary_emotion = self.tempo_emotion_mapping[tempo_category]&#10;        &#10;        # Lấy danh sách emotions phù hợp&#10;        suitable_emotions = []&#10;        suitable_emotions.extend(self.emotion_mapping.get(tempo_category.replace(&quot;_&quot;, &quot;_tempo&quot;), []))&#10;        suitable_emotions.extend(self.emotion_mapping.get(energy_category, []))&#10;        &#10;        # Loại bỏ duplicate và thêm primary emotion&#10;        suitable_emotions = list(set(suitable_emotions))&#10;        if primary_emotion not in suitable_emotions:&#10;            suitable_emotions.insert(0, primary_emotion)&#10;        &#10;        return {&#10;            &quot;primary_emotion&quot;: primary_emotion,&#10;            &quot;suitable_emotions&quot;: suitable_emotions,&#10;            &quot;tempo_category&quot;: tempo_category,&#10;            &quot;energy_category&quot;: energy_category,&#10;            &quot;energy_score&quot;: energy_score,&#10;            &quot;tempo&quot;: tempo&#10;        }&#10;    &#10;    def _select_actions_for_segment(self, &#10;                                   emotion_analysis: Dict[str, Any],&#10;                                   segment_duration: float,&#10;                                   beat_count: int,&#10;                                   is_climax: bool = False) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Chọn actions phù hợp cho một segment&quot;&quot;&quot;&#10;        &#10;        suitable_emotions = emotion_analysis[&quot;suitable_emotions&quot;]&#10;        energy_category = emotion_analysis[&quot;energy_category&quot;]&#10;        tempo_category = emotion_analysis[&quot;tempo_category&quot;]&#10;        &#10;        # Lấy actions phù hợp với emotion&#10;        candidate_actions = []&#10;        for emotion in suitable_emotions:&#10;            actions = self.actions_service.get_actions_by_emotion(emotion)&#10;            candidate_actions.extend(actions)&#10;        &#10;        # Loại bỏ duplicate&#10;        unique_actions = {}&#10;        for action in candidate_actions:&#10;            unique_actions[action.name] = action&#10;        candidate_actions = list(unique_actions.values())&#10;        &#10;        # Lọc actions theo tempo và energy&#10;        filtered_actions = []&#10;        for action in candidate_actions:&#10;            # Với tempo nhanh, ưu tiên actions có thể interrupt&#10;            if tempo_category in [&quot;fast&quot;, &quot;very_fast&quot;]:&#10;                if action.can_interrupt or action.duration_estimate &lt;= 3.0:&#10;                    filtered_actions.append(action)&#10;            # Với tempo chậm, có thể dùng actions dài hơn&#10;            elif tempo_category in [&quot;slow&quot;, &quot;very_slow&quot;]:&#10;                if action.duration_estimate &lt;= segment_duration:&#10;                    filtered_actions.append(action)&#10;            else:&#10;                if action.duration_estimate &lt;= segment_duration * 0.8:&#10;                    filtered_actions.append(action)&#10;        &#10;        if not filtered_actions:&#10;            filtered_actions = candidate_actions[:5]  # Fallback&#10;        &#10;        # Chọn actions dựa trên beat count và duration&#10;        selected_actions = []&#10;        remaining_duration = segment_duration&#10;        &#10;        # Nếu là climax, ưu tiên dance actions&#10;        if is_climax:&#10;            dance_actions = [a for a in filtered_actions if a.category == &quot;dance&quot;]&#10;            if dance_actions:&#10;                # Chọn 1-2 dance actions cho climax&#10;                selected_dance = random.choice(dance_actions)&#10;                if selected_dance.duration_estimate &lt;= remaining_duration:&#10;                    selected_actions.append(selected_dance)&#10;                    remaining_duration -= selected_dance.duration_estimate&#10;        &#10;        # Thêm actions khác để fill remaining duration&#10;        while remaining_duration &gt; 1.0 and len(selected_actions) &lt; beat_count:&#10;            suitable_actions = [a for a in filtered_actions &#10;                              if a.duration_estimate &lt;= remaining_duration and a not in selected_actions]&#10;            &#10;            if not suitable_actions:&#10;                break&#10;                &#10;            # Ưu tiên actions với intensity phù hợp&#10;            if energy_category == &quot;high_energy&quot;:&#10;                high_intensity = [a for a in suitable_actions if a.intensity in [&quot;high&quot;, &quot;medium&quot;]]&#10;                if high_intensity:&#10;                    suitable_actions = high_intensity&#10;            elif energy_category == &quot;low_energy&quot;:&#10;                low_intensity = [a for a in suitable_actions if a.intensity in [&quot;low&quot;, &quot;medium&quot;]]&#10;                if low_intensity:&#10;                    suitable_actions = low_intensity&#10;            &#10;            selected_action = random.choice(suitable_actions)&#10;            selected_actions.append(selected_action)&#10;            remaining_duration -= selected_action.duration_estimate&#10;        &#10;        return selected_actions&#10;    &#10;    def _select_expressions_for_segment(self, &#10;                                       emotion_analysis: Dict[str, Any],&#10;                                       action_count: int) -&gt; List[AlphaExpression]:&#10;        &quot;&quot;&quot;Chọn expressions phù hợp cho segment&quot;&quot;&quot;&#10;        &#10;        suitable_emotions = emotion_analysis[&quot;suitable_emotions&quot;]&#10;        &#10;        # Lấy expressions phù hợp&#10;        candidate_expressions = []&#10;        for emotion in suitable_emotions:&#10;            expressions = self.actions_service.get_expressions_by_emotion(emotion)&#10;            candidate_expressions.extend(expressions)&#10;        &#10;        # Loại bỏ duplicate&#10;        unique_expressions = {}&#10;        for expr in candidate_expressions:&#10;            unique_expressions[expr.name] = expr&#10;        candidate_expressions = list(unique_expressions.values())&#10;        &#10;        if not candidate_expressions:&#10;            # Fallback to neutral expressions&#10;            candidate_expressions = self.actions_service.get_expressions_by_emotion(&quot;neutral&quot;)&#10;        &#10;        # Chọn expressions (thường ít hơn actions)&#10;        expression_count = min(len(candidate_expressions), max(1, action_count // 2))&#10;        selected_expressions = random.sample(candidate_expressions, expression_count)&#10;        &#10;        return selected_expressions&#10;    &#10;    def _create_robot_actions(self, &#10;                            actions: List[AlphaAction], &#10;                            expressions: List[AlphaExpression],&#10;                            segment_start: float,&#10;                            segment_duration: float) -&gt; List[RobotActionData]:&#10;        &quot;&quot;&quot;Tạo RobotActionData objects từ actions và expressions&quot;&quot;&quot;&#10;&#10;        robot_actions = []&#10;        current_time = segment_start&#10;        &#10;        # Thêm expressions trước&#10;        for i, expression in enumerate(expressions):&#10;            robot_action = RobotActionData(&#10;                type=&quot;expression&quot;,&#10;                name=expression.name,&#10;                start_time=current_time + i * 0.5,  # Stagger expressions&#10;                duration=2.0,  # Default expression duration&#10;                intensity=expression.intensity,&#10;                parameters={&quot;emotion&quot;: expression.emotion_type}&#10;            )&#10;            robot_actions.append(robot_action)&#10;&#10;        # Thêm actions&#10;        for action in actions:&#10;            if current_time + action.duration_estimate &lt;= segment_start + segment_duration:&#10;                robot_action = RobotActionData(&#10;                    type=&quot;action&quot; if action.category != &quot;dance&quot; else &quot;dance&quot;,&#10;                    name=action.name,&#10;                    start_time=current_time,&#10;                    duration=action.duration_estimate,&#10;                    intensity=action.intensity,&#10;                    parameters={&#10;                        &quot;can_interrupt&quot;: action.can_interrupt,&#10;                        &quot;category&quot;: action.category,&#10;                        &quot;emotion&quot;: action.emotion_type&#10;                    }&#10;                )&#10;                robot_actions.append(robot_action)&#10;                current_time += action.duration_estimate&#10;            else:&#10;                break&#10;        &#10;        return robot_actions&#10;    &#10;    async def create_intelligent_choreography(self, &#10;                                            music_analysis: MusicAnalysisResult,&#10;                                            preferences: Optional[Dict[str, Any]] = None) -&gt; ChoreographyData:&#10;        &quot;&quot;&quot;Tạo choreography thông minh từ phân tích nhạc&quot;&quot;&quot;&#10;        &#10;        try:&#10;            print(f&quot;Creating intelligent choreography for: {music_analysis.filename}&quot;)&#10;            &#10;            # Phân tích emotion từ nhạc&#10;            emotion_analysis = self._analyze_music_emotion(music_analysis)&#10;            print(f&quot;Music emotion analysis: {emotion_analysis}&quot;)&#10;            &#10;            # Tạo segments dựa trên beats và structure&#10;            segments = self._create_intelligent_segments(music_analysis, emotion_analysis)&#10;            &#10;            choreography_segments = []&#10;            &#10;            for i, segment in enumerate(segments):&#10;                segment_start = segment[&quot;start_time&quot;]&#10;                segment_duration = segment[&quot;duration&quot;]&#10;                beat_count = segment[&quot;beat_count&quot;]&#10;                is_climax = segment.get(&quot;is_climax&quot;, False)&#10;                &#10;                print(f&quot;Processing segment {i+1}: {segment_start:.1f}s - {segment_start + segment_duration:.1f}s&quot;)&#10;                &#10;                # Chọn actions cho segment&#10;                actions = self._select_actions_for_segment(&#10;                    emotion_analysis, segment_duration, beat_count, is_climax&#10;                )&#10;                &#10;                # Chọn expressions cho segment&#10;                expressions = self._select_expressions_for_segment(&#10;                    emotion_analysis, len(actions)&#10;                )&#10;                &#10;                # Tạo robot actions&#10;                robot_actions = self._create_robot_actions(&#10;                    actions, expressions, segment_start, segment_duration&#10;                )&#10;                &#10;                # Tạo choreography segment&#10;                choreography_segment = ChoreographySegment(&#10;                    start_time=segment_start,&#10;                    end_time=segment_start + segment_duration,&#10;                    action=RobotAction.DANCE,  # Use enum value&#10;                    parameters={&#10;                        &quot;actions&quot;: [action.dict() for action in robot_actions],&#10;                        &quot;tempo&quot;: music_analysis.tempo,&#10;                        &quot;primary_emotion&quot;: emotion_analysis[&quot;primary_emotion&quot;]&#10;                    },&#10;                    energy_level=&quot;medium&quot; if emotion_analysis[&quot;energy_score&quot;] &gt; 0.5 else &quot;low&quot;&#10;                )&#10;                &#10;                choreography_segments.append(choreography_segment)&#10;            &#10;            # Tạo choreography data&#10;            choreography_id = str(uuid.uuid4())&#10;            choreography_data = ChoreographyData(&#10;                id=choreography_id,&#10;                music_analysis_id=music_analysis.id,&#10;                name=f&quot;Auto-generated for {music_analysis.filename}&quot;,&#10;                music_file=music_analysis.filename,&#10;                segments=choreography_segments,&#10;                total_duration=music_analysis.duration,&#10;                bpm=music_analysis.tempo,&#10;                created_at=datetime.now(),&#10;                style_preferences={&#10;                    &quot;emotion_analysis&quot;: emotion_analysis,&#10;                    &quot;total_segments&quot;: len(choreography_segments),&#10;                    &quot;total_actions&quot;: sum(len(seg.parameters.get(&quot;actions&quot;, [])) for seg in choreography_segments)&#10;                }&#10;            )&#10;            &#10;            print(f&quot;Created choreography with {len(choreography_segments)} segments&quot;)&#10;            return choreography_data&#10;            &#10;        except Exception as e:&#10;            print(f&quot;Error creating intelligent choreography: {e}&quot;)&#10;            raise&#10;    &#10;    async def create_choreography_from_analysis(self, music_analysis: MusicAnalysisResult, filename: str) -&gt; ChoreographyData:&#10;        &quot;&quot;&quot;Tạo choreography từ kết quả phân tích nhạc&quot;&quot;&quot;&#10;        try:&#10;            # Phân tích emotion từ nhạc&#10;            emotion_analysis = self._analyze_music_emotion(music_analysis)&#10;&#10;            # Tạo segments từ beats&#10;            segments = self._create_segments_from_beats(&#10;                music_analysis.beats,&#10;                music_analysis.duration,&#10;                emotion_analysis&#10;            )&#10;&#10;            # Tạo choreography data&#10;            choreography_id = str(uuid.uuid4())&#10;&#10;            choreography = ChoreographyData(&#10;                id=choreography_id,&#10;                name=f&quot;Auto-generated for {filename}&quot;,  # Thêm field name&#10;                music_file=filename,&#10;                music_analysis_id=music_analysis.id,  # Thêm field music_analysis_id&#10;                segments=segments,&#10;                total_duration=music_analysis.duration,&#10;                bpm=music_analysis.tempo,&#10;                created_at=datetime.now(),&#10;                style_preferences={&#10;                    &quot;emotion_analysis&quot;: emotion_analysis,&#10;                    &quot;total_beats&quot;: len(music_analysis.beats),&#10;                    &quot;ai_generated&quot;: True&#10;                }&#10;            )&#10;&#10;            # Lưu choreography&#10;            choreography_dir = Path(&quot;data/choreography&quot;)&#10;            choreography_dir.mkdir(parents=True, exist_ok=True)&#10;&#10;            choreography_file = choreography_dir / f&quot;{choreography_id}.json&quot;&#10;            with open(choreography_file, 'w', encoding='utf-8') as f:&#10;                json.dump(choreography.dict(), f, indent=2, ensure_ascii=False, default=str)&#10;&#10;            print(f&quot;Choreography saved to: {choreography_file}&quot;)&#10;&#10;            return choreography&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error creating choreography: {e}&quot;)&#10;            raise&#10;&#10;    def _create_segments_from_beats(self, beats: List[float], duration: float, emotion_analysis: Dict[str, Any]) -&gt; List[ChoreographySegment]:&#10;        &quot;&quot;&quot;Tạo segments từ beats&quot;&quot;&quot;&#10;        if not beats:&#10;            return []&#10;&#10;        segments = []&#10;        min_segment_length = 1.0  # Tối thiểu 1 giây&#10;&#10;        print(f&quot;Debug: Creating segments from {len(beats)} beats, duration: {duration}s, min_length: {min_segment_length}s&quot;)&#10;&#10;        # Gom beats thành segments&#10;        segment_starts = []&#10;        current_start = 0.0&#10;&#10;        for i, beat in enumerate(beats):&#10;            if beat - current_start &gt;= min_segment_length:&#10;                segment_starts.append(current_start)&#10;                current_start = beat&#10;&#10;        # Thêm segment cuối&#10;        if current_start &lt; duration - min_segment_length:&#10;            segment_starts.append(current_start)&#10;&#10;        print(f&quot;Debug: Created {len(segment_starts)} segments: {segment_starts[:5]}&quot;)&#10;&#10;        # Tạo segments với actions&#10;        for i, start_time in enumerate(segment_starts):&#10;            # Tính end time&#10;            if i &lt; len(segment_starts) - 1:&#10;                end_time = min(segment_starts[i + 1], duration)&#10;            else:&#10;                end_time = duration&#10;&#10;            segment_duration = end_time - start_time&#10;&#10;            if segment_duration &lt; 0.5:  # Bỏ qua segment quá ngắn&#10;                continue&#10;&#10;            # Tính số beats trong segment này&#10;            beats_in_segment = [b for b in beats if start_time &lt;= b &lt; end_time]&#10;            beat_count = len(beats_in_segment)&#10;&#10;            # Xác định xem có phải là climax không (segment có nhiều beats)&#10;            avg_beats_per_segment = len(beats) / len(segment_starts) if segment_starts else 1&#10;            is_climax = beat_count &gt; avg_beats_per_segment * 1.2&#10;&#10;            # Chọn actions cho segment&#10;            actions = self._select_actions_for_segment_simple(&#10;                emotion_analysis, segment_duration, beat_count, is_climax&#10;            )&#10;&#10;            # Tạo segment&#10;            segment = ChoreographySegment(&#10;                start_time=start_time,&#10;                end_time=end_time,&#10;                action=RobotAction.DANCE,  # Thêm field action bắt buộc&#10;                parameters={&#10;                    &quot;actions&quot;: [{&quot;name&quot;: action.name, &quot;type&quot;: action.category, &quot;duration&quot;: action.duration_estimate} for action in actions],&#10;                    &quot;beat_count&quot;: beat_count,&#10;                    &quot;energy_level&quot;: emotion_analysis.get(&quot;energy_category&quot;, &quot;medium&quot;),&#10;                    &quot;primary_emotion&quot;: emotion_analysis.get(&quot;primary_emotion&quot;, &quot;happy&quot;),&#10;                    &quot;is_climax&quot;: is_climax&#10;                },&#10;                energy_level=emotion_analysis.get(&quot;energy_category&quot;, &quot;medium&quot;)&#10;            )&#10;&#10;            segments.append(segment)&#10;&#10;        print(f&quot;Generated {len(segments)} segments from beats&quot;)&#10;        return segments&#10;&#10;    def _select_actions_for_segment_simple(self, emotion_analysis: Dict[str, Any], segment_duration: float, beat_count: int, is_climax: bool = False) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Chọn actions đơn giản cho segment&quot;&quot;&quot;&#10;&#10;        # Lấy tất cả actions có sẵn&#10;        all_actions = self.actions_service.get_all_actions()&#10;&#10;        if not all_actions:&#10;            return []&#10;&#10;        # Lọc actions phù hợp với thời gian&#10;        suitable_actions = [a for a in all_actions if a.duration_estimate &lt;= segment_duration]&#10;&#10;        if not suitable_actions:&#10;            suitable_actions = all_actions[:10]  # Lấy 10 actions đầu làm fallback&#10;&#10;        # Số lượng actions cần chọn dựa trên duration và beats&#10;        num_actions = max(1, min(3, int(segment_duration / 2), beat_count // 2))&#10;&#10;        # Ưu tiên dance actions nếu là climax&#10;        if is_climax:&#10;            dance_actions = [a for a in suitable_actions if a.category == &quot;dance&quot;]&#10;            if dance_actions:&#10;                selected = random.sample(dance_actions, min(num_actions, len(dance_actions)))&#10;                return selected&#10;&#10;        # Chọn ngẫu nhiên từ actions phù hợp&#10;        selected = random.sample(suitable_actions, min(num_actions, len(suitable_actions)))&#10;        return selected&#10;&#10;    def _create_intelligent_segments(self,&#10;                                   music_analysis: MusicAnalysisResult, &#10;                                   emotion_analysis: Dict[str, Any]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Tạo segments thông minh dựa trên phân tích nhạc&quot;&quot;&quot;&#10;        &#10;        duration = music_analysis.duration&#10;        tempo = music_analysis.tempo&#10;        beats = music_analysis.beats if music_analysis.beats else []&#10;        &#10;        segments = []&#10;        &#10;        # Tính segment length dựa trên tempo&#10;        if tempo &gt; 140:&#10;            base_segment_length = 4.0  # Fast songs - shorter segments&#10;        elif tempo &gt; 100:&#10;            base_segment_length = 6.0  # Medium tempo&#10;        else:&#10;            base_segment_length = 8.0  # Slow songs - longer segments&#10;        &#10;        current_time = 0.0&#10;        segment_count = 0&#10;        &#10;        while current_time &lt; duration:&#10;            segment_length = min(base_segment_length, duration - current_time)&#10;            &#10;            # Tính số beats trong segment&#10;            beats_in_segment = []&#10;            for beat_time in beats:&#10;                if current_time &lt;= beat_time &lt; current_time + segment_length:&#10;                    beats_in_segment.append(beat_time)&#10;            &#10;            beat_count = len(beats_in_segment)&#10;            if beat_count == 0:&#10;                beat_count = max(1, int(segment_length * tempo / 60))  # Estimate beats&#10;            &#10;            # Xác định climax (thường ở giữa bài)&#10;            is_climax = (duration * 0.4 &lt;= current_time &lt;= duration * 0.7)&#10;            &#10;            segment = {&#10;                &quot;start_time&quot;: current_time,&#10;                &quot;duration&quot;: segment_length,&#10;                &quot;beat_count&quot;: beat_count,&#10;                &quot;is_climax&quot;: is_climax,&#10;                &quot;beats&quot;: beats_in_segment&#10;            }&#10;            &#10;            segments.append(segment)&#10;            current_time += segment_length&#10;            segment_count += 1&#10;            &#10;            # Giới hạn số segments để tránh quá phức tạp&#10;            if segment_count &gt;= 20:&#10;                break&#10;        &#10;        return segments&#10;&#10;# Singleton instance&#10;ai_choreographer_service = AIChoreographerService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/alpha_mini_actions.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/alpha_mini_actions.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Alpha Mini Robot Built-in Actions và Expressions&#10;Định nghĩa tất cả các hành động và biểu cảm có sẵn của robot Alpha Mini&#10;&quot;&quot;&quot;&#10;&#10;from typing import Dict, List, Any&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;&#10;@dataclass&#10;class AlphaAction:&#10;    &quot;&quot;&quot;Định nghĩa một hành động của Alpha Mini&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    can_interrupt: bool&#10;    category: str&#10;    intensity: str  # low, medium, high&#10;    duration_estimate: float  # giây&#10;    emotion_type: str  # happy, sad, energetic, calm, etc.&#10;&#10;@dataclass&#10;class AlphaExpression:&#10;    &quot;&quot;&quot;Định nghĩa một biểu cảm của Alpha Mini&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    emotion_type: str&#10;    intensity: str  # low, medium, high&#10;&#10;class ActionCategory(Enum):&#10;    DANCE = &quot;dance&quot;&#10;    BASIC_ACTION = &quot;basic_action&quot;&#10;    EXPRESSION = &quot;expression&quot;&#10;    GREETING = &quot;greeting&quot;&#10;    EMOTION = &quot;emotion&quot;&#10;&#10;class AlphaMiniActionsService:&#10;    &quot;&quot;&quot;Service quản lý tất cả actions và expressions của Alpha Mini&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.built_in_dances = self._init_built_in_dances()&#10;        self.built_in_actions = self._init_built_in_actions()&#10;        self.built_in_expressions = self._init_built_in_expressions()&#10;    &#10;    def _init_built_in_dances(self) -&gt; Dict[str, AlphaAction]:&#10;        &quot;&quot;&quot;Khởi tạo các điệu nhảy có sẵn&quot;&quot;&quot;&#10;        return {&#10;            &quot;w_stand_0001&quot;: AlphaAction(&quot;w_stand_0001&quot;, &quot;Hiccup&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 2.0, &quot;funny&quot;),&#10;            &quot;w_stand_0002&quot;: AlphaAction(&quot;w_stand_0002&quot;, &quot;Fart&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.5, &quot;funny&quot;),&#10;            &quot;w_stand_0003&quot;: AlphaAction(&quot;w_stand_0003&quot;, &quot;Stretching&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;calm&quot;),&#10;            &quot;w_stand_0008&quot;: AlphaAction(&quot;w_stand_0008&quot;, &quot;Sneeze&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;funny&quot;),&#10;            &quot;w_stand_0009&quot;: AlphaAction(&quot;w_stand_0009&quot;, &quot;Tickle&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.5, &quot;happy&quot;),&#10;            &quot;w_stand_0010&quot;: AlphaAction(&quot;w_stand_0010&quot;, &quot;Scare&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 2.0, &quot;surprise&quot;),&#10;            &#10;            # Các điệu nhảy chính&#10;            &quot;dance_0001en&quot;: AlphaAction(&quot;dance_0001en&quot;, &quot;Healthy Song and Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 15.0, &quot;energetic&quot;),&#10;            &quot;dance_0002en&quot;: AlphaAction(&quot;dance_0002en&quot;, &quot;Shaolin Hero Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 12.0, &quot;powerful&quot;),&#10;            &quot;dance_0003en&quot;: AlphaAction(&quot;dance_0003en&quot;, &quot;Youth Training Manual Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 18.0, &quot;energetic&quot;),&#10;            &quot;dance_0004en&quot;: AlphaAction(&quot;dance_0004en&quot;, &quot;Little Star&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 10.0, &quot;gentle&quot;),&#10;            &quot;dance_0005en&quot;: AlphaAction(&quot;dance_0005en&quot;, &quot;Grass Dance&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;calm&quot;),&#10;            &quot;dance_0006en&quot;: AlphaAction(&quot;dance_0006en&quot;, &quot;Seaweed Dance&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 12.0, &quot;flowing&quot;),&#10;            &quot;dance_0007en&quot;: AlphaAction(&quot;dance_0007en&quot;, &quot;I love taking a bath&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 10.0, &quot;happy&quot;),&#10;            &quot;dance_0008en&quot;: AlphaAction(&quot;dance_0008en&quot;, &quot;Chongerfei&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 14.0, &quot;energetic&quot;),&#10;            &quot;dance_0009en&quot;: AlphaAction(&quot;dance_0009en&quot;, &quot;Learn to Meow&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;cute&quot;),&#10;            &quot;dance_0011en&quot;: AlphaAction(&quot;dance_0011en&quot;, &quot;Dura Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 16.0, &quot;energetic&quot;),&#10;            &quot;dance_0013&quot;: AlphaAction(&quot;dance_0013&quot;, &quot;Buddha Girl&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 12.0, &quot;graceful&quot;),&#10;            &quot;custom_0035&quot;: AlphaAction(&quot;custom_0035&quot;, &quot;Happy birthday&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;happy&quot;),&#10;            &quot;014&quot;: AlphaAction(&quot;014&quot;, &quot;Tai Chi&quot;, False, ActionCategory.DANCE.value, &quot;low&quot;, 20.0, &quot;calm&quot;),&#10;        }&#10;    &#10;    def _init_built_in_actions(self) -&gt; Dict[str, AlphaAction]:&#10;        &quot;&quot;&quot;Khởi tạo các hành động cơ bản&quot;&quot;&quot;&#10;        return {&#10;            &quot;009&quot;: AlphaAction(&quot;009&quot;, &quot;Reset&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;012&quot;: AlphaAction(&quot;012&quot;, &quot;Push-ups&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 8.0, &quot;energetic&quot;),&#10;            &quot;016&quot;: AlphaAction(&quot;016&quot;, &quot;Golden Rooster Independent&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 5.0, &quot;balanced&quot;),&#10;            &quot;024&quot;: AlphaAction(&quot;024&quot;, &quot;Yoga&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 10.0, &quot;calm&quot;),&#10;            &quot;010&quot;: AlphaAction(&quot;010&quot;, &quot;Laughing&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 3.0, &quot;happy&quot;),&#10;            &quot;random_short2&quot;: AlphaAction(&quot;random_short2&quot;, &quot;Hug&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;affectionate&quot;),&#10;            &quot;027&quot;: AlphaAction(&quot;027&quot;, &quot;Sit down&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 3.0, &quot;calm&quot;),&#10;            &quot;031&quot;: AlphaAction(&quot;031&quot;, &quot;Squat&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;021&quot;: AlphaAction(&quot;021&quot;, &quot;Bent over&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;013&quot;: AlphaAction(&quot;013&quot;, &quot;Kung Fu&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 6.0, &quot;powerful&quot;),&#10;            &quot;018&quot;: AlphaAction(&quot;018&quot;, &quot;Raise your right leg&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;balanced&quot;),&#10;            &quot;019&quot;: AlphaAction(&quot;019&quot;, &quot;Raise left leg&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;balanced&quot;),&#10;            &quot;017&quot;: AlphaAction(&quot;017&quot;, &quot;Raise your hands&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;victorious&quot;),&#10;            &quot;015&quot;: AlphaAction(&quot;015&quot;, &quot;Welcome&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;friendly&quot;),&#10;            &quot;011&quot;: AlphaAction(&quot;011&quot;, &quot;Nodding&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;agreeing&quot;),&#10;            &quot;random_short3&quot;: AlphaAction(&quot;random_short3&quot;, &quot;Waving left hand&quot;, True, ActionCategory.GREETING.value, &quot;low&quot;, 1.5, &quot;friendly&quot;),&#10;            &quot;random_short4&quot;: AlphaAction(&quot;random_short4&quot;, &quot;Waving right hand&quot;, True, ActionCategory.GREETING.value, &quot;low&quot;, 1.5, &quot;friendly&quot;),&#10;            &quot;028&quot;: AlphaAction(&quot;028&quot;, &quot;Right Lunge&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;athletic&quot;),&#10;            &quot;037&quot;: AlphaAction(&quot;037&quot;, &quot;Shaking his head&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;disagreeing&quot;),&#10;            &quot;038&quot;: AlphaAction(&quot;038&quot;, &quot;Tilt head&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;curious&quot;),&#10;            &quot;Surveillance_001&quot;: AlphaAction(&quot;Surveillance_001&quot;, &quot;Say hello&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;friendly&quot;),&#10;            &quot;Surveillance_003&quot;: AlphaAction(&quot;Surveillance_003&quot;, &quot;Handshake&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 3.0, &quot;formal&quot;),&#10;            &quot;Surveillance_004&quot;: AlphaAction(&quot;Surveillance_004&quot;, &quot;Blow kisses&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;affectionate&quot;),&#10;            &quot;Surveillance_006&quot;: AlphaAction(&quot;Surveillance_006&quot;, &quot;Selling cute&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 3.0, &quot;cute&quot;),&#10;            &quot;007&quot;: AlphaAction(&quot;007&quot;, &quot;Sit and stand&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 4.0, &quot;neutral&quot;),&#10;            &quot;action_014&quot;: AlphaAction(&quot;action_014&quot;, &quot;Invite&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;welcoming&quot;),&#10;            &quot;action_016&quot;: AlphaAction(&quot;action_016&quot;, &quot;Goodbye&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;farewell&quot;),&#10;            &quot;action_012&quot;: AlphaAction(&quot;action_012&quot;, &quot;Seeking hug&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.5, &quot;needy&quot;),&#10;            &quot;action_004&quot;: AlphaAction(&quot;action_004&quot;, &quot;Wow&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 1.5, &quot;amazed&quot;),&#10;            &quot;action_005&quot;: AlphaAction(&quot;action_005&quot;, &quot;Like&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 1.5, &quot;approval&quot;),&#10;            &quot;action_006&quot;: AlphaAction(&quot;action_006&quot;, &quot;OK&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;agreeing&quot;),&#10;            &quot;action_018&quot;: AlphaAction(&quot;action_018&quot;, &quot;Hey ha&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 2.0, &quot;excited&quot;),&#10;            &quot;action_020&quot;: AlphaAction(&quot;action_020&quot;, &quot;嘚瑟&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;proud&quot;),&#10;            &quot;action_011&quot;: AlphaAction(&quot;action_011&quot;, &quot;Pretend to fly&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 4.0, &quot;playful&quot;),&#10;            &quot;action_013&quot;: AlphaAction(&quot;action_013&quot;, &quot;Make faces&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;funny&quot;),&#10;            &quot;action_015&quot;: AlphaAction(&quot;action_015&quot;, &quot;Ass Twist&quot;, True, ActionCategory.DANCE.value, &quot;medium&quot;, 3.0, &quot;playful&quot;),&#10;            &quot;action_007&quot;: AlphaAction(&quot;action_007&quot;, &quot;Kill you&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 2.0, &quot;aggressive&quot;),&#10;            &quot;action_019&quot;: AlphaAction(&quot;action_019&quot;, &quot;Hold your head&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;frustrated&quot;),&#10;        }&#10;    &#10;    def _init_built_in_expressions(self) -&gt; Dict[str, AlphaExpression]:&#10;        &quot;&quot;&quot;Khởi tạo các biểu cảm có sẵn&quot;&quot;&quot;&#10;        return {&#10;            # Basic expressions&#10;            &quot;codemao1&quot;: AlphaExpression(&quot;codemao1&quot;, &quot;Looking around&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;codemao2&quot;: AlphaExpression(&quot;codemao2&quot;, &quot;Sad&quot;, &quot;sad&quot;, &quot;medium&quot;),&#10;            &quot;codemao3&quot;: AlphaExpression(&quot;codemao3&quot;, &quot;Stretching sadness&quot;, &quot;sad&quot;, &quot;high&quot;),&#10;            &quot;codemao4&quot;: AlphaExpression(&quot;codemao4&quot;, &quot;Falling asleep&quot;, &quot;sleepy&quot;, &quot;medium&quot;),&#10;            &quot;codemao5&quot;: AlphaExpression(&quot;codemao5&quot;, &quot;Frightened&quot;, &quot;scared&quot;, &quot;high&quot;),&#10;            &quot;codemao6&quot;: AlphaExpression(&quot;codemao6&quot;, &quot;Sleepy&quot;, &quot;sleepy&quot;, &quot;medium&quot;),&#10;            &quot;codemao7&quot;: AlphaExpression(&quot;codemao7&quot;, &quot;Strange&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;codemao8&quot;: AlphaExpression(&quot;codemao8&quot;, &quot;Surprised&quot;, &quot;surprised&quot;, &quot;high&quot;),&#10;            &quot;codemao9&quot;: AlphaExpression(&quot;codemao9&quot;, &quot;Sneeze&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &quot;codemao10&quot;: AlphaExpression(&quot;codemao10&quot;, &quot;Exciting&quot;, &quot;excited&quot;, &quot;high&quot;),&#10;            &quot;codemao11&quot;: AlphaExpression(&quot;codemao11&quot;, &quot;Fighting Spirit&quot;, &quot;determined&quot;, &quot;high&quot;),&#10;            &quot;codemao12&quot;: AlphaExpression(&quot;codemao12&quot;, &quot;Hard work&quot;, &quot;focused&quot;, &quot;medium&quot;),&#10;            &quot;codemao13&quot;: AlphaExpression(&quot;codemao13&quot;, &quot;Question&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;codemao14&quot;: AlphaExpression(&quot;codemao14&quot;, &quot;Wake up&quot;, &quot;alert&quot;, &quot;medium&quot;),&#10;            &quot;codemao15&quot;: AlphaExpression(&quot;codemao15&quot;, &quot;Distress&quot;, &quot;worried&quot;, &quot;medium&quot;),&#10;            &quot;codemao16&quot;: AlphaExpression(&quot;codemao16&quot;, &quot;Cheap laugh&quot;, &quot;amused&quot;, &quot;medium&quot;),&#10;            &quot;codemao17&quot;: AlphaExpression(&quot;codemao17&quot;, &quot;Depressed&quot;, &quot;sad&quot;, &quot;high&quot;),&#10;            &quot;codemao18&quot;: AlphaExpression(&quot;codemao18&quot;, &quot;Desire&quot;, &quot;wanting&quot;, &quot;medium&quot;),&#10;            &quot;codemao19&quot;: AlphaExpression(&quot;codemao19&quot;, &quot;Love&quot;, &quot;loving&quot;, &quot;high&quot;),&#10;            &quot;codemao20&quot;: AlphaExpression(&quot;codemao20&quot;, &quot;Blink&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &#10;            # W type expressions&#10;            &quot;w_basic_0007-1&quot;: AlphaExpression(&quot;w_basic_0007-1&quot;, &quot;W type mobile&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0003-1&quot;: AlphaExpression(&quot;w_basic_0003-1&quot;, &quot;Look right&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0005-1&quot;: AlphaExpression(&quot;w_basic_0005-1&quot;, &quot;Look left&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0010-1&quot;: AlphaExpression(&quot;w_basic_0010-1&quot;, &quot;Look up&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0011-1&quot;: AlphaExpression(&quot;w_basic_0011-1&quot;, &quot;Look left and right&quot;, &quot;searching&quot;, &quot;medium&quot;),&#10;            &quot;w_basic_0012-1&quot;: AlphaExpression(&quot;w_basic_0012-1&quot;, &quot;Look up and down&quot;, &quot;searching&quot;, &quot;medium&quot;),&#10;            &#10;            # Emo expressions&#10;            &quot;emo_007&quot;: AlphaExpression(&quot;emo_007&quot;, &quot;Smile&quot;, &quot;happy&quot;, &quot;medium&quot;),&#10;            &quot;emo_010&quot;: AlphaExpression(&quot;emo_010&quot;, &quot;Shy&quot;, &quot;shy&quot;, &quot;medium&quot;),&#10;            &quot;emo_016&quot;: AlphaExpression(&quot;emo_016&quot;, &quot;Smile&quot;, &quot;happy&quot;, &quot;medium&quot;),&#10;            &quot;emo_028&quot;: AlphaExpression(&quot;emo_028&quot;, &quot;Cover your face&quot;, &quot;embarrassed&quot;, &quot;medium&quot;),&#10;            &quot;emo_008&quot;: AlphaExpression(&quot;emo_008&quot;, &quot;Irritation&quot;, &quot;annoyed&quot;, &quot;medium&quot;),&#10;            &quot;emo_014&quot;: AlphaExpression(&quot;emo_014&quot;, &quot;Poor&quot;, &quot;pitiful&quot;, &quot;medium&quot;),&#10;            &quot;emo_009&quot;: AlphaExpression(&quot;emo_009&quot;, &quot;Tears&quot;, &quot;crying&quot;, &quot;high&quot;),&#10;            &quot;emo_011&quot;: AlphaExpression(&quot;emo_011&quot;, &quot;Crying&quot;, &quot;crying&quot;, &quot;high&quot;),&#10;            &quot;emo_023&quot;: AlphaExpression(&quot;emo_023&quot;, &quot;Pain&quot;, &quot;hurt&quot;, &quot;high&quot;),&#10;            &quot;emo_013&quot;: AlphaExpression(&quot;emo_013&quot;, &quot;Get angry&quot;, &quot;angry&quot;, &quot;high&quot;),&#10;            &quot;emo_015&quot;: AlphaExpression(&quot;emo_015&quot;, &quot;Arrogance&quot;, &quot;proud&quot;, &quot;high&quot;),&#10;            &quot;emo_026&quot;: AlphaExpression(&quot;emo_026&quot;, &quot;White eyes&quot;, &quot;dismissive&quot;, &quot;medium&quot;),&#10;            &quot;emo_022&quot;: AlphaExpression(&quot;emo_022&quot;, &quot;Squeeze&quot;, &quot;focused&quot;, &quot;medium&quot;),&#10;            &quot;emo_019&quot;: AlphaExpression(&quot;emo_019&quot;, &quot;Hazy&quot;, &quot;dreamy&quot;, &quot;low&quot;),&#10;            &quot;emo_020&quot;: AlphaExpression(&quot;emo_020&quot;, &quot;Daze&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;emo_027&quot;: AlphaExpression(&quot;emo_027&quot;, &quot;Cool&quot;, &quot;confident&quot;, &quot;medium&quot;),&#10;            &quot;emo_029&quot;: AlphaExpression(&quot;emo_029&quot;, &quot;Witty&quot;, &quot;clever&quot;, &quot;medium&quot;),&#10;            &quot;emo_030&quot;: AlphaExpression(&quot;emo_030&quot;, &quot;Cross Eyes&quot;, &quot;silly&quot;, &quot;medium&quot;),&#10;            &quot;emo_031&quot;: AlphaExpression(&quot;emo_031&quot;, &quot;Reading glasses&quot;, &quot;studious&quot;, &quot;low&quot;),&#10;            &quot;emo_032&quot;: AlphaExpression(&quot;emo_032&quot;, &quot;Golden Glasses&quot;, &quot;cool&quot;, &quot;medium&quot;),&#10;        }&#10;    &#10;    def get_actions_by_emotion(self, emotion: str, intensity: str = None) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy các actions phù hợp với emotion&quot;&quot;&quot;&#10;        matching_actions = []&#10;        for action in self.built_in_actions.values():&#10;            if action.emotion_type == emotion:&#10;                if intensity is None or action.intensity == intensity:&#10;                    matching_actions.append(action)&#10;        &#10;        # Thêm dances phù hợp&#10;        for dance in self.built_in_dances.values():&#10;            if dance.emotion_type == emotion:&#10;                if intensity is None or dance.intensity == intensity:&#10;                    matching_actions.append(dance)&#10;                    &#10;        return matching_actions&#10;    &#10;    def get_expressions_by_emotion(self, emotion: str, intensity: str = None) -&gt; List[AlphaExpression]:&#10;        &quot;&quot;&quot;Lấy các expressions phù hợp với emotion&quot;&quot;&quot;&#10;        matching_expressions = []&#10;        for expression in self.built_in_expressions.values():&#10;            if expression.emotion_type == emotion:&#10;                if intensity is None or expression.intensity == intensity:&#10;                    matching_expressions.append(expression)&#10;        return matching_expressions&#10;    &#10;    def get_actions_by_category(self, category: str) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy actions theo category&quot;&quot;&quot;&#10;        matching_actions = []&#10;        for action in self.built_in_actions.values():&#10;            if action.category == category:&#10;                matching_actions.append(action)&#10;        &#10;        for dance in self.built_in_dances.values():&#10;            if dance.category == category:&#10;                matching_actions.append(dance)&#10;                &#10;        return matching_actions&#10;    &#10;    def get_interruptible_actions(self) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy các actions có thể bị interrupt (phù hợp cho beat nhanh)&quot;&quot;&quot;&#10;        interruptible = []&#10;        for action in self.built_in_actions.values():&#10;            if action.can_interrupt:&#10;                interruptible.append(action)&#10;        return interruptible&#10;&#10;# Singleton instance&#10;alpha_mini_actions_service = AlphaMiniActionsService()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Alpha Mini Robot Built-in Actions và Expressions&#10;Định nghĩa tất cả các hành động và biểu cảm có sẵn của robot Alpha Mini&#10;&quot;&quot;&quot;&#10;&#10;from typing import Dict, List, Any&#10;from dataclasses import dataclass&#10;from enum import Enum&#10;&#10;@dataclass&#10;class AlphaAction:&#10;    &quot;&quot;&quot;Định nghĩa một hành động của Alpha Mini&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    can_interrupt: bool&#10;    category: str&#10;    intensity: str  # low, medium, high&#10;    duration_estimate: float  # giây&#10;    emotion_type: str  # happy, sad, energetic, calm, etc.&#10;&#10;@dataclass&#10;class AlphaExpression:&#10;    &quot;&quot;&quot;Định nghĩa một biểu cảm của Alpha Mini&quot;&quot;&quot;&#10;    name: str&#10;    description: str&#10;    emotion_type: str&#10;    intensity: str  # low, medium, high&#10;&#10;class ActionCategory(Enum):&#10;    DANCE = &quot;dance&quot;&#10;    BASIC_ACTION = &quot;basic_action&quot;&#10;    EXPRESSION = &quot;expression&quot;&#10;    GREETING = &quot;greeting&quot;&#10;    EMOTION = &quot;emotion&quot;&#10;&#10;class AlphaMiniActionsService:&#10;    &quot;&quot;&quot;Service quản lý tất cả actions và expressions của Alpha Mini&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.built_in_dances = self._init_built_in_dances()&#10;        self.built_in_actions = self._init_built_in_actions()&#10;        self.built_in_expressions = self._init_built_in_expressions()&#10;    &#10;    def _init_built_in_dances(self) -&gt; Dict[str, AlphaAction]:&#10;        &quot;&quot;&quot;Khởi tạo các điệu nhảy có sẵn&quot;&quot;&quot;&#10;        return {&#10;            &quot;w_stand_0001&quot;: AlphaAction(&quot;w_stand_0001&quot;, &quot;Hiccup&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 2.0, &quot;funny&quot;),&#10;            &quot;w_stand_0002&quot;: AlphaAction(&quot;w_stand_0002&quot;, &quot;Fart&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.5, &quot;funny&quot;),&#10;            &quot;w_stand_0003&quot;: AlphaAction(&quot;w_stand_0003&quot;, &quot;Stretching&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;calm&quot;),&#10;            &quot;w_stand_0008&quot;: AlphaAction(&quot;w_stand_0008&quot;, &quot;Sneeze&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;funny&quot;),&#10;            &quot;w_stand_0009&quot;: AlphaAction(&quot;w_stand_0009&quot;, &quot;Tickle&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.5, &quot;happy&quot;),&#10;            &quot;w_stand_0010&quot;: AlphaAction(&quot;w_stand_0010&quot;, &quot;Scare&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 2.0, &quot;surprise&quot;),&#10;            &#10;            # Các điệu nhảy chính&#10;            &quot;dance_0001en&quot;: AlphaAction(&quot;dance_0001en&quot;, &quot;Healthy Song and Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 15.0, &quot;energetic&quot;),&#10;            &quot;dance_0002en&quot;: AlphaAction(&quot;dance_0002en&quot;, &quot;Shaolin Hero Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 12.0, &quot;powerful&quot;),&#10;            &quot;dance_0003en&quot;: AlphaAction(&quot;dance_0003en&quot;, &quot;Youth Training Manual Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 18.0, &quot;energetic&quot;),&#10;            &quot;dance_0004en&quot;: AlphaAction(&quot;dance_0004en&quot;, &quot;Little Star&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 10.0, &quot;gentle&quot;),&#10;            &quot;dance_0005en&quot;: AlphaAction(&quot;dance_0005en&quot;, &quot;Grass Dance&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;calm&quot;),&#10;            &quot;dance_0006en&quot;: AlphaAction(&quot;dance_0006en&quot;, &quot;Seaweed Dance&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 12.0, &quot;flowing&quot;),&#10;            &quot;dance_0007en&quot;: AlphaAction(&quot;dance_0007en&quot;, &quot;I love taking a bath&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 10.0, &quot;happy&quot;),&#10;            &quot;dance_0008en&quot;: AlphaAction(&quot;dance_0008en&quot;, &quot;Chongerfei&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 14.0, &quot;energetic&quot;),&#10;            &quot;dance_0009en&quot;: AlphaAction(&quot;dance_0009en&quot;, &quot;Learn to Meow&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;cute&quot;),&#10;            &quot;dance_0011en&quot;: AlphaAction(&quot;dance_0011en&quot;, &quot;Dura Dance&quot;, False, ActionCategory.DANCE.value, &quot;high&quot;, 16.0, &quot;energetic&quot;),&#10;            &quot;dance_0013&quot;: AlphaAction(&quot;dance_0013&quot;, &quot;Buddha Girl&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 12.0, &quot;graceful&quot;),&#10;            &quot;custom_0035&quot;: AlphaAction(&quot;custom_0035&quot;, &quot;Happy birthday&quot;, False, ActionCategory.DANCE.value, &quot;medium&quot;, 8.0, &quot;happy&quot;),&#10;            &quot;014&quot;: AlphaAction(&quot;014&quot;, &quot;Tai Chi&quot;, False, ActionCategory.DANCE.value, &quot;low&quot;, 20.0, &quot;calm&quot;),&#10;        }&#10;    &#10;    def _init_built_in_actions(self) -&gt; Dict[str, AlphaAction]:&#10;        &quot;&quot;&quot;Khởi tạo các hành động cơ bản&quot;&quot;&quot;&#10;        return {&#10;            &quot;009&quot;: AlphaAction(&quot;009&quot;, &quot;Reset&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;012&quot;: AlphaAction(&quot;012&quot;, &quot;Push-ups&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 8.0, &quot;energetic&quot;),&#10;            &quot;016&quot;: AlphaAction(&quot;016&quot;, &quot;Golden Rooster Independent&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 5.0, &quot;balanced&quot;),&#10;            &quot;024&quot;: AlphaAction(&quot;024&quot;, &quot;Yoga&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 10.0, &quot;calm&quot;),&#10;            &quot;010&quot;: AlphaAction(&quot;010&quot;, &quot;Laughing&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 3.0, &quot;happy&quot;),&#10;            &quot;random_short2&quot;: AlphaAction(&quot;random_short2&quot;, &quot;Hug&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;affectionate&quot;),&#10;            &quot;027&quot;: AlphaAction(&quot;027&quot;, &quot;Sit down&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 3.0, &quot;calm&quot;),&#10;            &quot;031&quot;: AlphaAction(&quot;031&quot;, &quot;Squat&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;021&quot;: AlphaAction(&quot;021&quot;, &quot;Bent over&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;neutral&quot;),&#10;            &quot;013&quot;: AlphaAction(&quot;013&quot;, &quot;Kung Fu&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 6.0, &quot;powerful&quot;),&#10;            &quot;018&quot;: AlphaAction(&quot;018&quot;, &quot;Raise your right leg&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;balanced&quot;),&#10;            &quot;019&quot;: AlphaAction(&quot;019&quot;, &quot;Raise left leg&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 3.0, &quot;balanced&quot;),&#10;            &quot;017&quot;: AlphaAction(&quot;017&quot;, &quot;Raise your hands&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;victorious&quot;),&#10;            &quot;015&quot;: AlphaAction(&quot;015&quot;, &quot;Welcome&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;friendly&quot;),&#10;            &quot;011&quot;: AlphaAction(&quot;011&quot;, &quot;Nodding&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;agreeing&quot;),&#10;            &quot;random_short3&quot;: AlphaAction(&quot;random_short3&quot;, &quot;Waving left hand&quot;, True, ActionCategory.GREETING.value, &quot;low&quot;, 1.5, &quot;friendly&quot;),&#10;            &quot;random_short4&quot;: AlphaAction(&quot;random_short4&quot;, &quot;Waving right hand&quot;, True, ActionCategory.GREETING.value, &quot;low&quot;, 1.5, &quot;friendly&quot;),&#10;            &quot;028&quot;: AlphaAction(&quot;028&quot;, &quot;Right Lunge&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 2.0, &quot;athletic&quot;),&#10;            &quot;037&quot;: AlphaAction(&quot;037&quot;, &quot;Shaking his head&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;disagreeing&quot;),&#10;            &quot;038&quot;: AlphaAction(&quot;038&quot;, &quot;Tilt head&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;curious&quot;),&#10;            &quot;Surveillance_001&quot;: AlphaAction(&quot;Surveillance_001&quot;, &quot;Say hello&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;friendly&quot;),&#10;            &quot;Surveillance_003&quot;: AlphaAction(&quot;Surveillance_003&quot;, &quot;Handshake&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 3.0, &quot;formal&quot;),&#10;            &quot;Surveillance_004&quot;: AlphaAction(&quot;Surveillance_004&quot;, &quot;Blow kisses&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;affectionate&quot;),&#10;            &quot;Surveillance_006&quot;: AlphaAction(&quot;Surveillance_006&quot;, &quot;Selling cute&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 3.0, &quot;cute&quot;),&#10;            &quot;007&quot;: AlphaAction(&quot;007&quot;, &quot;Sit and stand&quot;, False, ActionCategory.BASIC_ACTION.value, &quot;medium&quot;, 4.0, &quot;neutral&quot;),&#10;            &quot;action_014&quot;: AlphaAction(&quot;action_014&quot;, &quot;Invite&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;welcoming&quot;),&#10;            &quot;action_016&quot;: AlphaAction(&quot;action_016&quot;, &quot;Goodbye&quot;, True, ActionCategory.GREETING.value, &quot;medium&quot;, 2.0, &quot;farewell&quot;),&#10;            &quot;action_012&quot;: AlphaAction(&quot;action_012&quot;, &quot;Seeking hug&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.5, &quot;needy&quot;),&#10;            &quot;action_004&quot;: AlphaAction(&quot;action_004&quot;, &quot;Wow&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 1.5, &quot;amazed&quot;),&#10;            &quot;action_005&quot;: AlphaAction(&quot;action_005&quot;, &quot;Like&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 1.5, &quot;approval&quot;),&#10;            &quot;action_006&quot;: AlphaAction(&quot;action_006&quot;, &quot;OK&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;low&quot;, 1.0, &quot;agreeing&quot;),&#10;            &quot;action_018&quot;: AlphaAction(&quot;action_018&quot;, &quot;Hey ha&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 2.0, &quot;excited&quot;),&#10;            &quot;action_020&quot;: AlphaAction(&quot;action_020&quot;, &quot;嘚瑟&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;proud&quot;),&#10;            &quot;action_011&quot;: AlphaAction(&quot;action_011&quot;, &quot;Pretend to fly&quot;, True, ActionCategory.BASIC_ACTION.value, &quot;high&quot;, 4.0, &quot;playful&quot;),&#10;            &quot;action_013&quot;: AlphaAction(&quot;action_013&quot;, &quot;Make faces&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;funny&quot;),&#10;            &quot;action_015&quot;: AlphaAction(&quot;action_015&quot;, &quot;Ass Twist&quot;, True, ActionCategory.DANCE.value, &quot;medium&quot;, 3.0, &quot;playful&quot;),&#10;            &quot;action_007&quot;: AlphaAction(&quot;action_007&quot;, &quot;Kill you&quot;, True, ActionCategory.EMOTION.value, &quot;high&quot;, 2.0, &quot;aggressive&quot;),&#10;            &quot;action_019&quot;: AlphaAction(&quot;action_019&quot;, &quot;Hold your head&quot;, True, ActionCategory.EMOTION.value, &quot;medium&quot;, 2.0, &quot;frustrated&quot;),&#10;        }&#10;    &#10;    def _init_built_in_expressions(self) -&gt; Dict[str, AlphaExpression]:&#10;        &quot;&quot;&quot;Khởi tạo các biểu cảm có sẵn&quot;&quot;&quot;&#10;        return {&#10;            # Basic expressions&#10;            &quot;codemao1&quot;: AlphaExpression(&quot;codemao1&quot;, &quot;Looking around&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;codemao2&quot;: AlphaExpression(&quot;codemao2&quot;, &quot;Sad&quot;, &quot;sad&quot;, &quot;medium&quot;),&#10;            &quot;codemao3&quot;: AlphaExpression(&quot;codemao3&quot;, &quot;Stretching sadness&quot;, &quot;sad&quot;, &quot;high&quot;),&#10;            &quot;codemao4&quot;: AlphaExpression(&quot;codemao4&quot;, &quot;Falling asleep&quot;, &quot;sleepy&quot;, &quot;medium&quot;),&#10;            &quot;codemao5&quot;: AlphaExpression(&quot;codemao5&quot;, &quot;Frightened&quot;, &quot;scared&quot;, &quot;high&quot;),&#10;            &quot;codemao6&quot;: AlphaExpression(&quot;codemao6&quot;, &quot;Sleepy&quot;, &quot;sleepy&quot;, &quot;medium&quot;),&#10;            &quot;codemao7&quot;: AlphaExpression(&quot;codemao7&quot;, &quot;Strange&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;codemao8&quot;: AlphaExpression(&quot;codemao8&quot;, &quot;Surprised&quot;, &quot;surprised&quot;, &quot;high&quot;),&#10;            &quot;codemao9&quot;: AlphaExpression(&quot;codemao9&quot;, &quot;Sneeze&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &quot;codemao10&quot;: AlphaExpression(&quot;codemao10&quot;, &quot;Exciting&quot;, &quot;excited&quot;, &quot;high&quot;),&#10;            &quot;codemao11&quot;: AlphaExpression(&quot;codemao11&quot;, &quot;Fighting Spirit&quot;, &quot;determined&quot;, &quot;high&quot;),&#10;            &quot;codemao12&quot;: AlphaExpression(&quot;codemao12&quot;, &quot;Hard work&quot;, &quot;focused&quot;, &quot;medium&quot;),&#10;            &quot;codemao13&quot;: AlphaExpression(&quot;codemao13&quot;, &quot;Question&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;codemao14&quot;: AlphaExpression(&quot;codemao14&quot;, &quot;Wake up&quot;, &quot;alert&quot;, &quot;medium&quot;),&#10;            &quot;codemao15&quot;: AlphaExpression(&quot;codemao15&quot;, &quot;Distress&quot;, &quot;worried&quot;, &quot;medium&quot;),&#10;            &quot;codemao16&quot;: AlphaExpression(&quot;codemao16&quot;, &quot;Cheap laugh&quot;, &quot;amused&quot;, &quot;medium&quot;),&#10;            &quot;codemao17&quot;: AlphaExpression(&quot;codemao17&quot;, &quot;Depressed&quot;, &quot;sad&quot;, &quot;high&quot;),&#10;            &quot;codemao18&quot;: AlphaExpression(&quot;codemao18&quot;, &quot;Desire&quot;, &quot;wanting&quot;, &quot;medium&quot;),&#10;            &quot;codemao19&quot;: AlphaExpression(&quot;codemao19&quot;, &quot;Love&quot;, &quot;loving&quot;, &quot;high&quot;),&#10;            &quot;codemao20&quot;: AlphaExpression(&quot;codemao20&quot;, &quot;Blink&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &#10;            # W type expressions&#10;            &quot;w_basic_0007-1&quot;: AlphaExpression(&quot;w_basic_0007-1&quot;, &quot;W type mobile&quot;, &quot;neutral&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0003-1&quot;: AlphaExpression(&quot;w_basic_0003-1&quot;, &quot;Look right&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0005-1&quot;: AlphaExpression(&quot;w_basic_0005-1&quot;, &quot;Look left&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0010-1&quot;: AlphaExpression(&quot;w_basic_0010-1&quot;, &quot;Look up&quot;, &quot;curious&quot;, &quot;low&quot;),&#10;            &quot;w_basic_0011-1&quot;: AlphaExpression(&quot;w_basic_0011-1&quot;, &quot;Look left and right&quot;, &quot;searching&quot;, &quot;medium&quot;),&#10;            &quot;w_basic_0012-1&quot;: AlphaExpression(&quot;w_basic_0012-1&quot;, &quot;Look up and down&quot;, &quot;searching&quot;, &quot;medium&quot;),&#10;            &#10;            # Emo expressions&#10;            &quot;emo_007&quot;: AlphaExpression(&quot;emo_007&quot;, &quot;Smile&quot;, &quot;happy&quot;, &quot;medium&quot;),&#10;            &quot;emo_010&quot;: AlphaExpression(&quot;emo_010&quot;, &quot;Shy&quot;, &quot;shy&quot;, &quot;medium&quot;),&#10;            &quot;emo_016&quot;: AlphaExpression(&quot;emo_016&quot;, &quot;Smile&quot;, &quot;happy&quot;, &quot;medium&quot;),&#10;            &quot;emo_028&quot;: AlphaExpression(&quot;emo_028&quot;, &quot;Cover your face&quot;, &quot;embarrassed&quot;, &quot;medium&quot;),&#10;            &quot;emo_008&quot;: AlphaExpression(&quot;emo_008&quot;, &quot;Irritation&quot;, &quot;annoyed&quot;, &quot;medium&quot;),&#10;            &quot;emo_014&quot;: AlphaExpression(&quot;emo_014&quot;, &quot;Poor&quot;, &quot;pitiful&quot;, &quot;medium&quot;),&#10;            &quot;emo_009&quot;: AlphaExpression(&quot;emo_009&quot;, &quot;Tears&quot;, &quot;crying&quot;, &quot;high&quot;),&#10;            &quot;emo_011&quot;: AlphaExpression(&quot;emo_011&quot;, &quot;Crying&quot;, &quot;crying&quot;, &quot;high&quot;),&#10;            &quot;emo_023&quot;: AlphaExpression(&quot;emo_023&quot;, &quot;Pain&quot;, &quot;hurt&quot;, &quot;high&quot;),&#10;            &quot;emo_013&quot;: AlphaExpression(&quot;emo_013&quot;, &quot;Get angry&quot;, &quot;angry&quot;, &quot;high&quot;),&#10;            &quot;emo_015&quot;: AlphaExpression(&quot;emo_015&quot;, &quot;Arrogance&quot;, &quot;proud&quot;, &quot;high&quot;),&#10;            &quot;emo_026&quot;: AlphaExpression(&quot;emo_026&quot;, &quot;White eyes&quot;, &quot;dismissive&quot;, &quot;medium&quot;),&#10;            &quot;emo_022&quot;: AlphaExpression(&quot;emo_022&quot;, &quot;Squeeze&quot;, &quot;focused&quot;, &quot;medium&quot;),&#10;            &quot;emo_019&quot;: AlphaExpression(&quot;emo_019&quot;, &quot;Hazy&quot;, &quot;dreamy&quot;, &quot;low&quot;),&#10;            &quot;emo_020&quot;: AlphaExpression(&quot;emo_020&quot;, &quot;Daze&quot;, &quot;confused&quot;, &quot;medium&quot;),&#10;            &quot;emo_027&quot;: AlphaExpression(&quot;emo_027&quot;, &quot;Cool&quot;, &quot;confident&quot;, &quot;medium&quot;),&#10;            &quot;emo_029&quot;: AlphaExpression(&quot;emo_029&quot;, &quot;Witty&quot;, &quot;clever&quot;, &quot;medium&quot;),&#10;            &quot;emo_030&quot;: AlphaExpression(&quot;emo_030&quot;, &quot;Cross Eyes&quot;, &quot;silly&quot;, &quot;medium&quot;),&#10;            &quot;emo_031&quot;: AlphaExpression(&quot;emo_031&quot;, &quot;Reading glasses&quot;, &quot;studious&quot;, &quot;low&quot;),&#10;            &quot;emo_032&quot;: AlphaExpression(&quot;emo_032&quot;, &quot;Golden Glasses&quot;, &quot;cool&quot;, &quot;medium&quot;),&#10;        }&#10;    &#10;    def get_all_actions(self) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy tất cả actions có sẵn&quot;&quot;&quot;&#10;        all_actions = []&#10;        all_actions.extend(self.built_in_dances.values())&#10;        all_actions.extend(self.built_in_actions.values())&#10;        return all_actions&#10;    &#10;    def get_actions_by_emotion(self, emotion: str) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy actions theo emotion&quot;&quot;&quot;&#10;        all_actions = self.get_all_actions()&#10;        return [action for action in all_actions if emotion.lower() in action.emotion_type.lower()]&#10;    &#10;    def get_expressions_by_emotion(self, emotion: str) -&gt; List[AlphaExpression]:&#10;        &quot;&quot;&quot;Lấy expressions theo emotion&quot;&quot;&quot;&#10;        all_expressions = list(self.built_in_expressions.values())&#10;        if emotion == &quot;neutral&quot;:&#10;            return all_expressions[:5]  # Return some default expressions&#10;        return [expr for expr in all_expressions if emotion.lower() in expr.emotion_type.lower()]&#10;    &#10;    def get_actions_by_category(self, category: str) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy actions theo category&quot;&quot;&quot;&#10;        all_actions = self.get_all_actions()&#10;        return [action for action in all_actions if action.category == category]&#10;    &#10;    def get_dance_actions(self) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy tất cả dance actions&quot;&quot;&quot;&#10;        return list(self.built_in_dances.values())&#10;    &#10;    def get_basic_actions(self) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy tất cả basic actions&quot;&quot;&quot;&#10;        return list(self.built_in_actions.values())&#10;    &#10;    def get_action_by_name(self, name: str) -&gt; AlphaAction:&#10;        &quot;&quot;&quot;Lấy action theo tên&quot;&quot;&quot;&#10;        # Tìm trong dances&#10;        if name in self.built_in_dances:&#10;            return self.built_in_dances[name]&#10;        # Tìm trong actions&#10;        if name in self.built_in_actions:&#10;            return self.built_in_actions[name]&#10;        return None&#10;    &#10;    def get_interruptible_actions(self) -&gt; List[AlphaAction]:&#10;        &quot;&quot;&quot;Lấy các actions có thể bị interrupt (phù hợp cho beat nhanh)&quot;&quot;&quot;&#10;        interruptible = []&#10;        for action in self.built_in_actions.values():&#10;            if action.can_interrupt:&#10;                interruptible.append(action)&#10;        return interruptible&#10;&#10;# Singleton instance&#10;alpha_mini_actions_service = AlphaMiniActionsService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/alpha_mini_robot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/alpha_mini_robot.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Alpha Mini Robot Service&#10;Service để điều khiển robot Alpha Mini của UBtech&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import logging&#10;from typing import Optional, List, Dict, Any&#10;from mini.apis.api_behavior import StartBehavior, StopBehavior, ControlBehaviorResponse&#10;from mini.apis.api_expression import PlayExpression, PlayExpressionResponse&#10;from mini.apis.api_sound import StartPlayTTS, StopPlayTTS, ControlTTSResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;from mini.dns.dns_browser import WiFiDevice&#10;import mini.mini_sdk as MiniSdk&#10;import os&#10;&#10;# Import websocket patch&#10;from websocket_patch import apply_websocket_patch&#10;apply_websocket_patch()&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class AlphaMiniRobotService:&#10;    &quot;&quot;&quot;Service để điều khiển robot Alpha Mini&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.device: Optional[WiFiDevice] = None&#10;        self.is_connected = False&#10;        self.is_in_program_mode = False&#10;        self.current_music_task = None&#10;&#10;        # Setup SDK như trong example thành công&#10;        MiniSdk.set_log_level(logging.INFO)&#10;        MiniSdk.set_robot_type(MiniSdk.RobotType.EDU)&#10;&#10;    async def find_and_connect(self, device_serial: str = &quot;000341&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Tìm và kết nối robot sử dụng phương pháp từ UBtech SDK đã test thành công&quot;&quot;&quot;&#10;        try:&#10;            # Sử dụng phương pháp kết nối từ UBtech example đã hoạt động&#10;            print(f&quot; Searching for robot with serial ending: {device_serial}&quot;)&#10;&#10;            # Tìm theo serial number (chỉ cần đuôi serial)&#10;            self.device = await MiniSdk.get_device_by_name(device_serial, 10)&#10;            print(f&quot;Device search result: {self.device}&quot;)&#10;&#10;            if not self.device:&#10;                # Thử tìm tất cả devices&#10;                print(&quot; Searching for all available robots...&quot;)&#10;                devices = await MiniSdk.get_device_list(10)&#10;                print(f&quot;All devices found: {devices}&quot;)&#10;&#10;                if devices and len(devices) &gt; 0:&#10;                    self.device = devices[0] if isinstance(devices, (list, tuple)) else None&#10;&#10;            if not self.device:&#10;                logger.error(&quot;❌ No robot found&quot;)&#10;                return False&#10;&#10;            # Kết nối như trong example&#10;            print(f&quot; Connecting to robot: {self.device.name}&quot;)&#10;            connected = await MiniSdk.connect(self.device)&#10;&#10;            if connected:&#10;                self.is_connected = True&#10;                print(&quot;✅ Connection successful!&quot;)&#10;&#10;                # Vào chế độ programming&#10;                print(&quot; Entering programming mode...&quot;)&#10;                await asyncio.sleep(2)  # Wait for connection to stabilize&#10;                await MiniSdk.enter_program()&#10;                self.is_in_program_mode = True&#10;                print(&quot;✅ Programming mode activated!&quot;)&#10;&#10;                return True&#10;            else:&#10;                logger.error(&quot;❌ Failed to connect to robot&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;❌ Error connecting to robot: {e}&quot;)&#10;            return False&#10;&#10;    async def disconnect(self):&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#10;        try:&#10;            if self.is_in_program_mode:&#10;                await MiniSdk.quit_program()&#10;                self.is_in_program_mode = False&#10;&#10;            if self.is_connected:&#10;                await MiniSdk.release()&#10;                self.is_connected = False&#10;                self.device = None&#10;&#10;            print(&quot; Robot disconnected successfully&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error disconnecting robot: {e}&quot;)&#10;&#10;    async def execute_action(self, action_name: str, duration: float = 2.0) -&gt; bool:&#10;        &quot;&quot;&quot;Thực hiện action trên robot&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            # Thử với các định dạng tên action khác nhau&#10;            action_variants = [&#10;                action_name,&#10;                f&quot;{action_name}.ubx&quot;,&#10;                action_name.replace('.ubx', ''),&#10;            ]&#10;&#10;            for variant in action_variants:&#10;                try:&#10;                    print(f&quot; Executing action: {variant}&quot;)&#10;                    block = StartBehavior(name=variant)&#10;                    result_type, response = await block.execute()&#10;&#10;                    if (result_type == MiniApiResultType.Success and&#10;                        response and response.isSuccess):&#10;                        print(f&quot;✅ Action {variant} executed successfully&quot;)&#10;                        await asyncio.sleep(duration)&#10;                        return True&#10;                    else:&#10;                        print(f&quot;⚠️ Action {variant} failed: {response.resultCode if response else 'No response'}&quot;)&#10;&#10;                except Exception as action_error:&#10;                    print(f&quot;⚠️ Failed to execute {variant}: {action_error}&quot;)&#10;                    continue&#10;&#10;            return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error executing action {action_name}: {e}&quot;)&#10;            return False&#10;&#10;    async def play_expression(self, expression_name: str) -&gt; bool:&#10;        &quot;&quot;&quot;Phát expression trên robot&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            expression_variants = [&#10;                expression_name,&#10;                f&quot;{expression_name}.ubx&quot;,&#10;                expression_name.replace('.ubx', ''),&#10;            ]&#10;&#10;            for variant in expression_variants:&#10;                try:&#10;                    print(f&quot; Playing expression: {variant}&quot;)&#10;                    block = PlayExpression(express_name=variant)&#10;                    result_type, response = await block.execute()&#10;&#10;                    if (result_type == MiniApiResultType.Success and&#10;                        response and response.isSuccess):&#10;                        print(f&quot;✅ Expression {variant} played successfully&quot;)&#10;                        return True&#10;                    else:&#10;                        print(f&quot;⚠️ Expression {variant} failed: {response.resultCode if response else 'No response'}&quot;)&#10;&#10;                except Exception as expr_error:&#10;                    print(f&quot;⚠️ Failed to play {variant}: {expr_error}&quot;)&#10;                    continue&#10;&#10;            return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error playing expression {expression_name}: {e}&quot;)&#10;            return False&#10;&#10;    async def speak_text(self, text: str) -&gt; bool:&#10;        &quot;&quot;&quot;Robot nói text&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            block = StartPlayTTS(text=text)&#10;            result_type, response = await block.execute()&#10;&#10;            if result_type == MiniApiResultType.Success and response and response.isSuccess:&#10;                print(f&quot;✅ Robot spoke: {text}&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠️ Failed to speak text: {response.resultCode if response else 'No response'}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error speaking text: {e}&quot;)&#10;            return False&#10;&#10;    async def stop_current_action(self):&#10;        &quot;&quot;&quot;Dừng action hiện tại&quot;&quot;&quot;&#10;        try:&#10;            if self.is_connected and self.is_in_program_mode:&#10;                block = StopBehavior()&#10;                await block.execute()&#10;                print(&quot; Stopped current action&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error stopping action: {e}&quot;)&#10;&#10;# Global instance&#10;alpha_mini_robot_service = AlphaMiniRobotService()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Alpha Mini Robot Service&#10;Service để điều khiển robot Alpha Mini của UBtech&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import logging&#10;from typing import Optional, List, Dict, Any&#10;from mini.apis.api_behavior import StartBehavior, StopBehavior, ControlBehaviorResponse&#10;from mini.apis.api_expression import PlayExpression, PlayExpressionResponse&#10;from mini.apis.api_sound import StartPlayTTS, StopPlayTTS, ControlTTSResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;from mini.dns.dns_browser import WiFiDevice&#10;import mini.mini_sdk as MiniSdk&#10;import os&#10;&#10;# Import websocket patch&#10;from websocket_patch import apply_websocket_patch&#10;apply_websocket_patch()&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class AlphaMiniRobotService:&#10;    &quot;&quot;&quot;Service để điều khiển robot Alpha Mini&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.device: Optional[WiFiDevice] = None&#10;        self.is_connected = False&#10;        self.is_in_program_mode = False&#10;        self.current_music_task = None&#10;&#10;        # Setup SDK như trong example thành công&#10;        MiniSdk.set_log_level(logging.INFO)&#10;        MiniSdk.set_robot_type(MiniSdk.RobotType.EDU)&#10;&#10;    async def find_and_connect(self, device_serial: str = &quot;000341&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Tìm và kết nối robot sử dụng phương pháp từ UBtech SDK đã test thành công&quot;&quot;&quot;&#10;        try:&#10;            # Sử dụng phương pháp kết nối từ UBtech example đã hoạt động&#10;            print(f&quot; Searching for robot with serial ending: {device_serial}&quot;)&#10;&#10;            # Tìm theo serial number (chỉ cần đuôi serial)&#10;            self.device = await MiniSdk.get_device_by_name(device_serial, 10)&#10;            print(f&quot;Device search result: {self.device}&quot;)&#10;&#10;            if not self.device:&#10;                # Thử tìm tất cả devices&#10;                print(&quot; Searching for all available robots...&quot;)&#10;                devices = await MiniSdk.get_device_list(10)&#10;                print(f&quot;All devices found: {devices}&quot;)&#10;&#10;                if devices and len(devices) &gt; 0:&#10;                    self.device = devices[0] if isinstance(devices, (list, tuple)) else None&#10;&#10;            if not self.device:&#10;                logger.error(&quot;❌ No robot found&quot;)&#10;                return False&#10;&#10;            # Kết nối như trong example&#10;            print(f&quot; Connecting to robot: {self.device.name}&quot;)&#10;            connected = await MiniSdk.connect(self.device)&#10;&#10;            if connected:&#10;                self.is_connected = True&#10;                print(&quot;✅ Connection successful!&quot;)&#10;&#10;                # Vào chế độ programming&#10;                print(&quot; Entering programming mode...&quot;)&#10;                await asyncio.sleep(2)  # Wait for connection to stabilize&#10;                await MiniSdk.enter_program()&#10;                self.is_in_program_mode = True&#10;                print(&quot;✅ Programming mode activated!&quot;)&#10;&#10;                return True&#10;            else:&#10;                logger.error(&quot;❌ Failed to connect to robot&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;❌ Error connecting to robot: {e}&quot;)&#10;            return False&#10;&#10;    async def disconnect(self):&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#10;        try:&#10;            if self.is_in_program_mode:&#10;                await MiniSdk.quit_program()&#10;                self.is_in_program_mode = False&#10;&#10;            if self.is_connected:&#10;                await MiniSdk.release()&#10;                self.is_connected = False&#10;                self.device = None&#10;&#10;            print(&quot; Robot disconnected successfully&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error disconnecting robot: {e}&quot;)&#10;&#10;    async def execute_action(self, action_name: str, duration: float = 2.0) -&gt; bool:&#10;        &quot;&quot;&quot;Thực hiện action trên robot&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            # Kiểm tra nếu là dance action thì dùng StartBehavior&#10;            if action_name.startswith(&quot;dance_&quot;) or action_name in [&quot;013&quot;, &quot;015&quot;, &quot;024&quot;]:&#10;                print(f&quot; Executing DANCE: {action_name}&quot;)&#10;                # Sử dụng StartBehavior cho dance&#10;                block = StartBehavior(name=action_name)&#10;                result_type, response = await block.execute()&#10;                &#10;                if (result_type == MiniApiResultType.Success and &#10;                    response and response.isSuccess):&#10;                    print(f&quot;✅ Dance {action_name} started successfully&quot;)&#10;                    # Chờ dance hoàn thành&#10;                    await asyncio.sleep(min(duration, 10.0))  # Max 10 giây&#10;                    &#10;                    # Dừng dance sau khi hết thời gian&#10;                    try:&#10;                        stop_block = StopBehavior()&#10;                        await stop_block.execute()&#10;                        print(f&quot; Dance {action_name} stopped&quot;)&#10;                    except:&#10;                        pass&#10;                    &#10;                    return True&#10;                else:&#10;                    print(f&quot;⚠️ Dance {action_name} failed: {response.resultCode if response else 'No response'}&quot;)&#10;                    return False&#10;            else:&#10;                # Với basic actions, vẫn dùng StartBehavior nhưng với timeout ngắn hơn&#10;                print(f&quot; Executing ACTION: {action_name}&quot;)&#10;                &#10;                # Thử với các định dạng tên action khác nhau&#10;                action_variants = [action_name, f&quot;{action_name}.ubx&quot;]&#10;                &#10;                for variant in action_variants:&#10;                    try:&#10;                        block = StartBehavior(name=variant)&#10;                        result_type, response = await block.execute()&#10;                        &#10;                        if (result_type == MiniApiResultType.Success and &#10;                            response and response.isSuccess):&#10;                            print(f&quot;✅ Action {variant} executed successfully&quot;)&#10;                            await asyncio.sleep(min(duration, 3.0))  # Max 3 giây cho basic actions&#10;                            return True&#10;                        else:&#10;                            print(f&quot;⚠️ Action {variant} failed: {response.resultCode if response else 'No response'}&quot;)&#10;                            &#10;                    except Exception as action_error:&#10;                        print(f&quot;⚠️ Failed to execute {variant}: {action_error}&quot;)&#10;                        continue&#10;                &#10;                return False&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error executing action {action_name}: {e}&quot;)&#10;            return False&#10;&#10;    async def play_expression(self, expression_name: str) -&gt; bool:&#10;        &quot;&quot;&quot;Phát expression trên robot&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            expression_variants = [&#10;                expression_name,&#10;                f&quot;{expression_name}.ubx&quot;,&#10;                expression_name.replace('.ubx', ''),&#10;            ]&#10;&#10;            for variant in expression_variants:&#10;                try:&#10;                    print(f&quot; Playing expression: {variant}&quot;)&#10;                    block = PlayExpression(express_name=variant)&#10;                    result_type, response = await block.execute()&#10;&#10;                    if (result_type == MiniApiResultType.Success and&#10;                        response and response.isSuccess):&#10;                        print(f&quot;✅ Expression {variant} played successfully&quot;)&#10;                        return True&#10;                    else:&#10;                        print(f&quot;⚠️ Expression {variant} failed: {response.resultCode if response else 'No response'}&quot;)&#10;&#10;                except Exception as expr_error:&#10;                    print(f&quot;⚠️ Failed to play {variant}: {expr_error}&quot;)&#10;                    continue&#10;&#10;            return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error playing expression {expression_name}: {e}&quot;)&#10;            return False&#10;&#10;    async def speak_text(self, text: str) -&gt; bool:&#10;        &quot;&quot;&quot;Robot nói text&quot;&quot;&quot;&#10;        if not self.is_connected or not self.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            block = StartPlayTTS(text=text)&#10;            result_type, response = await block.execute()&#10;&#10;            if result_type == MiniApiResultType.Success and response and response.isSuccess:&#10;                print(f&quot;✅ Robot spoke: {text}&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠️ Failed to speak text: {response.resultCode if response else 'No response'}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error speaking text: {e}&quot;)&#10;            return False&#10;&#10;    async def stop_current_action(self):&#10;        &quot;&quot;&quot;Dừng action hiện tại&quot;&quot;&quot;&#10;        try:&#10;            if self.is_connected and self.is_in_program_mode:&#10;                block = StopBehavior()&#10;                await block.execute()&#10;                print(&quot; Stopped current action&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error stopping action: {e}&quot;)&#10;&#10;# Global instance&#10;alpha_mini_robot_service = AlphaMiniRobotService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/music_analysis.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/music_analysis.py" />
              <option name="originalContent" value="import librosa&#10;import numpy as np&#10;from scipy.signal import find_peaks&#10;from typing import List, Dict, Tuple, Any&#10;import json&#10;import os&#10;from datetime import datetime&#10;import uuid&#10;&#10;from app.core.config import settings&#10;from app.models.schemas import MusicAnalysisResult, BeatInfo&#10;&#10;class MusicAnalysisService:&#10;    &quot;&quot;&quot;Service chính để phân tích file nhạc và trích xuất đặc trưng âm thanh&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.sample_rate = settings.SAMPLE_RATE if hasattr(settings, 'SAMPLE_RATE') else 22050&#10;        self.hop_length = settings.HOP_LENGTH if hasattr(settings, 'HOP_LENGTH') else 512&#10;        self.frame_length = settings.FRAME_LENGTH if hasattr(settings, 'FRAME_LENGTH') else 2048&#10;&#10;    async def analyze_audio_file(self, file_path: str, filename: str) -&gt; MusicAnalysisResult:&#10;        &quot;&quot;&quot;Phân tích file nhạc và trả về kết quả phân tích&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot;Analyzing audio file: {filename}&quot;)&#10;&#10;            # Load audio file&#10;            y, sr = librosa.load(file_path, sr=self.sample_rate)&#10;            duration = librosa.get_duration(y=y, sr=sr)&#10;&#10;            print(f&quot;Audio loaded - Duration: {duration:.2f}s, Sample rate: {sr}&quot;)&#10;&#10;            # Phân tích tempo và beats&#10;            tempo, beats = self._analyze_tempo_and_beats(y, sr)&#10;&#10;            # Phân tích đặc trưng phổ&#10;            spectral_features = self._analyze_spectral_features(y, sr)&#10;&#10;            # Phân tích cường độ âm thanh&#10;            energy_analysis = self._analyze_energy_levels(y, sr)&#10;&#10;            # Tạo ID unique cho analysis&#10;            analysis_id = str(uuid.uuid4())&#10;&#10;            # Lưu kết quả phân tích&#10;            result = MusicAnalysisResult(&#10;                id=analysis_id,&#10;                filename=filename,&#10;                duration=duration,&#10;                tempo=tempo,&#10;                beats=beats.tolist() if beats is not None else [],&#10;                spectral_features=spectral_features,&#10;                energy_analysis=energy_analysis,&#10;                analysis_timestamp=datetime.now(),&#10;                file_path=file_path&#10;            )&#10;&#10;            # Lưu kết quả vào file JSON&#10;            await self._save_analysis_result(result)&#10;&#10;            print(f&quot;Analysis completed - Tempo: {tempo:.1f} BPM, Beats: {len(beats) if beats is not None else 0}&quot;)&#10;&#10;            return result&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing audio file: {str(e)}&quot;)&#10;            raise&#10;&#10;    def _analyze_tempo_and_beats(self, y: np.ndarray, sr: int) -&gt; Tuple[float, np.ndarray]:&#10;        &quot;&quot;&quot;Phân tích tempo và vị trí các beats&quot;&quot;&quot;&#10;        try:&#10;            # Estimate tempo&#10;            tempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=self.hop_length)&#10;&#10;            # Convert beats to time&#10;            beat_times = librosa.times_like(beats, sr=sr, hop_length=self.hop_length)&#10;&#10;            return float(tempo), beat_times&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in tempo analysis: {e}&quot;)&#10;            return 120.0, np.array([])&#10;&#10;    def _analyze_spectral_features(self, y: np.ndarray, sr: int) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích đặc trưng phổ của âm thanh&quot;&quot;&quot;&#10;        try:&#10;            # Tính MFCC (Mel-frequency cepstral coefficients)&#10;            mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)&#10;&#10;            # Tính spectral centroid (tần số trung tâm)&#10;            spectral_centroids = librosa.feature.spectral_centroid(y=y, sr=sr)&#10;&#10;            # Tính chroma features&#10;            chroma = librosa.feature.chroma_stft(y=y, sr=sr)&#10;&#10;            # Tính zero crossing rate&#10;            zcr = librosa.feature.zero_crossing_rate(y)&#10;&#10;            return {&#10;                &quot;mfcc_mean&quot;: np.mean(mfccs, axis=1).tolist(),&#10;                &quot;mfcc_std&quot;: np.std(mfccs, axis=1).tolist(),&#10;                &quot;spectral_centroid_mean&quot;: float(np.mean(spectral_centroids)),&#10;                &quot;spectral_centroid_std&quot;: float(np.std(spectral_centroids)),&#10;                &quot;chroma_mean&quot;: np.mean(chroma, axis=1).tolist(),&#10;                &quot;chroma_std&quot;: np.std(chroma, axis=1).tolist(),&#10;                &quot;zcr_mean&quot;: float(np.mean(zcr)),&#10;                &quot;zcr_std&quot;: float(np.std(zcr))&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in spectral analysis: {e}&quot;)&#10;            return {}&#10;&#10;    def _analyze_energy_levels(self, y: np.ndarray, sr: int) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích mức năng lượng âm thanh theo thời gian&quot;&quot;&quot;&#10;        try:&#10;            # Tính RMS energy&#10;            rms = librosa.feature.rms(y=y, hop_length=self.hop_length)&#10;&#10;            # Tính onset strength&#10;            onset_envelope = librosa.onset.onset_strength(y=y, sr=sr, hop_length=self.hop_length)&#10;&#10;            # Tìm peaks trong onset envelope&#10;            peaks, _ = find_peaks(onset_envelope, height=np.mean(onset_envelope))&#10;&#10;            # Convert frames to time&#10;            times = librosa.times_like(rms, sr=sr, hop_length=self.hop_length)&#10;            peak_times = librosa.frames_to_time(peaks, sr=sr, hop_length=self.hop_length)&#10;&#10;            return {&#10;                &quot;rms_energy&quot;: rms[0].tolist(),&#10;                &quot;rms_times&quot;: times.tolist(),&#10;                &quot;onset_strength&quot;: onset_envelope.tolist(),&#10;                &quot;onset_peaks&quot;: peak_times.tolist(),&#10;                &quot;energy_mean&quot;: float(np.mean(rms)),&#10;                &quot;energy_std&quot;: float(np.std(rms)),&#10;                &quot;peak_count&quot;: len(peaks)&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in energy analysis: {e}&quot;)&#10;            return {}&#10;&#10;    async def _save_analysis_result(self, result: MusicAnalysisResult):&#10;        &quot;&quot;&quot;Lưu kết quả phân tích vào file JSON&quot;&quot;&quot;&#10;        try:&#10;            analysis_dir = &quot;data/analysis&quot;&#10;            os.makedirs(analysis_dir, exist_ok=True)&#10;&#10;            filename = f&quot;{result.id}.json&quot;&#10;            filepath = os.path.join(analysis_dir, filename)&#10;&#10;            # Convert to dict and save&#10;            result_dict = {&#10;                &quot;id&quot;: result.id,&#10;                &quot;filename&quot;: result.filename,&#10;                &quot;duration&quot;: result.duration,&#10;                &quot;tempo&quot;: result.tempo,&#10;                &quot;beats&quot;: result.beats,&#10;                &quot;spectral_features&quot;: result.spectral_features,&#10;                &quot;energy_analysis&quot;: result.energy_analysis,&#10;                &quot;analysis_timestamp&quot;: result.analysis_timestamp.isoformat(),&#10;                &quot;file_path&quot;: result.file_path&#10;            }&#10;&#10;            with open(filepath, 'w', encoding='utf-8') as f:&#10;                json.dump(result_dict, f, indent=2, ensure_ascii=False)&#10;&#10;            print(f&quot;Analysis result saved to: {filepath}&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving analysis result: {e}&quot;)&#10;&#10;    async def load_analysis_result(self, analysis_id: str) -&gt; MusicAnalysisResult:&#10;        &quot;&quot;&quot;Load kết quả phân tích từ file JSON&quot;&quot;&quot;&#10;        try:&#10;            filepath = os.path.join(&quot;data/analysis&quot;, f&quot;{analysis_id}.json&quot;)&#10;&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;&#10;            return MusicAnalysisResult(&#10;                id=data[&quot;id&quot;],&#10;                filename=data[&quot;filename&quot;],&#10;                duration=data[&quot;duration&quot;],&#10;                tempo=data[&quot;tempo&quot;],&#10;                beats=data[&quot;beats&quot;],&#10;                spectral_features=data[&quot;spectral_features&quot;],&#10;                energy_analysis=data[&quot;energy_analysis&quot;],&#10;                analysis_timestamp=datetime.fromisoformat(data[&quot;analysis_timestamp&quot;]),&#10;                file_path=data[&quot;file_path&quot;]&#10;            )&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading analysis result: {e}&quot;)&#10;            raise&#10;&#10;    def get_beat_segments(self, beats: List[float], duration: float, min_segment_length: float = 0.5) -&gt; List[Tuple[float, float]]:&#10;        &quot;&quot;&quot;Tạo các segments dựa trên beats&quot;&quot;&quot;&#10;        if not beats or len(beats) &lt; 2:&#10;            # Fallback: tạo segments đều&#10;            segments = []&#10;            segment_length = max(min_segment_length, duration / 10)  # Chia làm 10 phần&#10;            for i in range(int(duration / segment_length)):&#10;                start = i * segment_length&#10;                end = min((i + 1) * segment_length, duration)&#10;                segments.append((start, end))&#10;            return segments&#10;&#10;        segments = []&#10;        for i in range(len(beats) - 1):&#10;            start_time = beats[i]&#10;            end_time = beats[i + 1]&#10;&#10;            # Chỉ thêm segment nếu đủ dài&#10;            if end_time - start_time &gt;= min_segment_length:&#10;                segments.append((start_time, end_time))&#10;&#10;        return segments&#10;&#10;&#10;# Global service instance&#10;music_analysis_service = MusicAnalysisService()&#10;" />
              <option name="updatedContent" value="import librosa&#10;import numpy as np&#10;from scipy.signal import find_peaks&#10;from typing import List, Dict, Tuple, Any&#10;import json&#10;import os&#10;from datetime import datetime&#10;import uuid&#10;&#10;from app.core.config import settings&#10;from app.models.schemas import MusicAnalysisResult, BeatInfo&#10;&#10;class MusicAnalysisService:&#10;    &quot;&quot;&quot;Service chính để phân tích file nhạc và trích xuất đặc trưng âm thanh&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.sample_rate = settings.SAMPLE_RATE if hasattr(settings, 'SAMPLE_RATE') else 22050&#10;        self.hop_length = settings.HOP_LENGTH if hasattr(settings, 'HOP_LENGTH') else 512&#10;        self.frame_length = settings.FRAME_LENGTH if hasattr(settings, 'FRAME_LENGTH') else 2048&#10;&#10;    async def analyze_audio_file(self, file_path: str, filename: str) -&gt; MusicAnalysisResult:&#10;        &quot;&quot;&quot;Phân tích file nhạc và trả về kết quả phân tích&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot;Analyzing audio file: {filename}&quot;)&#10;&#10;            # Load audio file&#10;            y, sr = librosa.load(file_path, sr=self.sample_rate)&#10;            duration = librosa.get_duration(y=y, sr=sr)&#10;&#10;            print(f&quot;Audio loaded - Duration: {duration:.2f}s, Sample rate: {sr}&quot;)&#10;&#10;            # Phân tích tempo và beats&#10;            tempo, beats = self._analyze_tempo_and_beats(y, sr)&#10;&#10;            # Phân tích đặc trưng phổ&#10;            spectral_features = self._analyze_spectral_features(y, sr)&#10;&#10;            # Phân tích cường độ âm thanh&#10;            energy_analysis = self._analyze_energy_levels(y, sr)&#10;&#10;            # Tạo ID unique cho analysis&#10;            analysis_id = str(uuid.uuid4())&#10;&#10;            # Lưu kết quả phân tích&#10;            result = MusicAnalysisResult(&#10;                id=analysis_id,&#10;                filename=filename,&#10;                duration=duration,&#10;                tempo=tempo,&#10;                beats=beats.tolist() if beats is not None else [],&#10;                spectral_features=spectral_features,&#10;                energy_analysis=energy_analysis,&#10;                analysis_timestamp=datetime.now(),&#10;                file_path=file_path&#10;            )&#10;&#10;            # Lưu kết quả vào file JSON&#10;            await self._save_analysis_result(result)&#10;&#10;            print(f&quot;Analysis completed - Tempo: {tempo:.1f} BPM, Beats: {len(beats) if beats is not None else 0}&quot;)&#10;&#10;            return result&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error analyzing audio file: {str(e)}&quot;)&#10;            raise&#10;&#10;    def _analyze_tempo_and_beats(self, y: np.ndarray, sr: int) -&gt; Tuple[float, np.ndarray]:&#10;        &quot;&quot;&quot;Phân tích tempo và vị trí các beats&quot;&quot;&quot;&#10;        try:&#10;            # Estimate tempo&#10;            tempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=self.hop_length)&#10;&#10;            # Convert beats to time&#10;            beat_times = librosa.times_like(beats, sr=sr, hop_length=self.hop_length)&#10;&#10;            return float(tempo), beat_times&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in tempo analysis: {e}&quot;)&#10;            return 120.0, np.array([])&#10;&#10;    def _analyze_spectral_features(self, y: np.ndarray, sr: int) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích đặc trưng phổ của âm thanh&quot;&quot;&quot;&#10;        try:&#10;            # Tính MFCC (Mel-frequency cepstral coefficients)&#10;            mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)&#10;&#10;            # Tính spectral centroid (tần số trung tâm)&#10;            spectral_centroids = librosa.feature.spectral_centroid(y=y, sr=sr)&#10;&#10;            # Tính chroma features&#10;            chroma = librosa.feature.chroma_stft(y=y, sr=sr)&#10;&#10;            # Tính zero crossing rate&#10;            zcr = librosa.feature.zero_crossing_rate(y)&#10;&#10;            return {&#10;                &quot;mfcc_mean&quot;: np.mean(mfccs, axis=1).tolist(),&#10;                &quot;mfcc_std&quot;: np.std(mfccs, axis=1).tolist(),&#10;                &quot;spectral_centroid_mean&quot;: float(np.mean(spectral_centroids)),&#10;                &quot;spectral_centroid_std&quot;: float(np.std(spectral_centroids)),&#10;                &quot;chroma_mean&quot;: np.mean(chroma, axis=1).tolist(),&#10;                &quot;chroma_std&quot;: np.std(chroma, axis=1).tolist(),&#10;                &quot;zcr_mean&quot;: float(np.mean(zcr)),&#10;                &quot;zcr_std&quot;: float(np.std(zcr))&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in spectral analysis: {e}&quot;)&#10;            return {}&#10;&#10;    def _analyze_energy_levels(self, y: np.ndarray, sr: int) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Phân tích mức năng lượng âm thanh theo thời gian&quot;&quot;&quot;&#10;        try:&#10;            # Tính RMS energy&#10;            rms = librosa.feature.rms(y=y, hop_length=self.hop_length)&#10;&#10;            # Tính onset strength&#10;            onset_envelope = librosa.onset.onset_strength(y=y, sr=sr, hop_length=self.hop_length)&#10;&#10;            # Tìm peaks trong onset envelope&#10;            peaks, _ = find_peaks(onset_envelope, height=np.mean(onset_envelope))&#10;&#10;            # Convert frames to time&#10;            times = librosa.times_like(rms, sr=sr, hop_length=self.hop_length)&#10;            peak_times = librosa.frames_to_time(peaks, sr=sr, hop_length=self.hop_length)&#10;&#10;            return {&#10;                &quot;rms_energy&quot;: rms[0].tolist(),&#10;                &quot;rms_times&quot;: times.tolist(),&#10;                &quot;onset_strength&quot;: onset_envelope.tolist(),&#10;                &quot;onset_peaks&quot;: peak_times.tolist(),&#10;                &quot;energy_mean&quot;: float(np.mean(rms)),&#10;                &quot;energy_std&quot;: float(np.std(rms)),&#10;                &quot;peak_count&quot;: len(peaks)&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in energy analysis: {e}&quot;)&#10;            return {}&#10;&#10;    async def _save_analysis_result(self, result: MusicAnalysisResult):&#10;        &quot;&quot;&quot;Lưu kết quả phân tích vào file JSON&quot;&quot;&quot;&#10;        try:&#10;            analysis_dir = &quot;data/analysis&quot;&#10;            os.makedirs(analysis_dir, exist_ok=True)&#10;&#10;            filename = f&quot;{result.id}.json&quot;&#10;            filepath = os.path.join(analysis_dir, filename)&#10;&#10;            # Convert to dict and save&#10;            result_dict = {&#10;                &quot;id&quot;: result.id,&#10;                &quot;filename&quot;: result.filename,&#10;                &quot;duration&quot;: result.duration,&#10;                &quot;tempo&quot;: result.tempo,&#10;                &quot;beats&quot;: result.beats,&#10;                &quot;spectral_features&quot;: result.spectral_features,&#10;                &quot;energy_analysis&quot;: result.energy_analysis,&#10;                &quot;analysis_timestamp&quot;: result.analysis_timestamp.isoformat(),&#10;                &quot;file_path&quot;: result.file_path&#10;            }&#10;&#10;            with open(filepath, 'w', encoding='utf-8') as f:&#10;                json.dump(result_dict, f, indent=2, ensure_ascii=False)&#10;&#10;            print(f&quot;Analysis result saved to: {filepath}&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving analysis result: {e}&quot;)&#10;&#10;    async def load_analysis_result(self, analysis_id: str) -&gt; MusicAnalysisResult:&#10;        &quot;&quot;&quot;Load kết quả phân tích từ file JSON&quot;&quot;&quot;&#10;        try:&#10;            filepath = os.path.join(&quot;data/analysis&quot;, f&quot;{analysis_id}.json&quot;)&#10;&#10;            with open(filepath, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;&#10;            return MusicAnalysisResult(&#10;                id=data[&quot;id&quot;],&#10;                filename=data[&quot;filename&quot;],&#10;                duration=data[&quot;duration&quot;],&#10;                tempo=data[&quot;tempo&quot;],&#10;                beats=data[&quot;beats&quot;],&#10;                spectral_features=data[&quot;spectral_features&quot;],&#10;                energy_analysis=data[&quot;energy_analysis&quot;],&#10;                analysis_timestamp=datetime.fromisoformat(data[&quot;analysis_timestamp&quot;]),&#10;                file_path=data[&quot;file_path&quot;]&#10;            )&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading analysis result: {e}&quot;)&#10;            raise&#10;&#10;    def get_beat_segments(self, beats: List[float], duration: float, min_segment_length: float = 0.5) -&gt; List[Tuple[float, float]]:&#10;        &quot;&quot;&quot;Tạo các segments dựa trên beats&quot;&quot;&quot;&#10;        print(f&quot;Debug: Creating segments from {len(beats) if beats else 0} beats, duration: {duration}s, min_length: {min_segment_length}s&quot;)&#10;        &#10;        if not beats or len(beats) &lt; 2:&#10;            print(&quot;Debug: Not enough beats, using fallback method&quot;)&#10;            # Fallback: tạo segments đều&#10;            segments = []&#10;            segment_length = max(min_segment_length, duration / 8)  # Chia làm 8 phần&#10;            for i in range(int(duration / segment_length)):&#10;                start = i * segment_length&#10;                end = min((i + 1) * segment_length, duration)&#10;                segments.append((start, end))&#10;            print(f&quot;Debug: Created {len(segments)} fallback segments&quot;)&#10;            return segments&#10;&#10;        segments = []&#10;        # Tạo segments từ beats, nhóm beats lại nếu cần&#10;        i = 0&#10;        while i &lt; len(beats) - 1:&#10;            start_time = beats[i]&#10;            &#10;            # Tìm beat tiếp theo tạo segment đủ dài&#10;            j = i + 1&#10;            while j &lt; len(beats) and (beats[j] - start_time) &lt; min_segment_length:&#10;                j += 1&#10;            &#10;            if j &lt; len(beats):&#10;                end_time = beats[j]&#10;                segments.append((start_time, end_time))&#10;                i = j&#10;            else:&#10;                # Nếu không tìm được beat phù hợp, tạo segment cuối&#10;                end_time = min(start_time + min_segment_length * 2, duration)&#10;                segments.append((start_time, end_time))&#10;                break&#10;        &#10;        # Đảm bảo có ít nhất một vài segments&#10;        if not segments and duration &gt; 0:&#10;            print(&quot;Debug: No segments created, adding fallback segments&quot;)&#10;            # Tạo ít nhất 3 segments&#10;            segment_duration = duration / 3&#10;            for i in range(3):&#10;                start = i * segment_duration&#10;                end = min((i + 1) * segment_duration, duration)&#10;                segments.append((start, end))&#10;        &#10;        print(f&quot;Debug: Created {len(segments)} segments: {segments[:5]}&quot;)  # Show first 5&#10;        return segments&#10;&#10;&#10;# Global service instance&#10;music_analysis_service = MusicAnalysisService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/robot_audio.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/robot_audio.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Robot Audio Service - Phát nhạc qua robot Alpha Mini&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;import logging&#10;from typing import Optional&#10;from mini.apis.api_sound import StartPlayAudio, StopPlayAudio, ControlAudioResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class RobotAudioService:&#10;    &quot;&quot;&quot;Service để phát âm thanh qua robot Alpha Mini&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.is_playing = False&#10;        self.current_audio = None&#10;&#10;    async def play_audio_file(self, file_path: str, robot_service) -&gt; bool:&#10;        &quot;&quot;&quot;Phát file âm thanh qua robot&quot;&quot;&quot;&#10;        if not robot_service.is_connected or not robot_service.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;&#10;        try:&#10;            if not os.path.exists(file_path):&#10;                logger.error(f&quot;Audio file not found: {file_path}&quot;)&#10;                return False&#10;&#10;            print(f&quot; Playing audio through robot: {os.path.basename(file_path)}&quot;)&#10;&#10;            # Chuyển đổi file path thành tên file để robot có thể phát&#10;            filename = os.path.basename(file_path)&#10;&#10;            # Thử phát audio qua robot&#10;            block = StartPlayAudio(file_name=filename)&#10;            result_type, response = await block.execute()&#10;&#10;            if result_type == MiniApiResultType.Success and response and response.isSuccess:&#10;                self.is_playing = True&#10;                self.current_audio = filename&#10;                print(f&quot;✅ Audio playing successfully: {filename}&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠️ Failed to play audio: {response.resultCode if response else 'No response'}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error playing audio file: {e}&quot;)&#10;            return False&#10;&#10;    async def stop_audio(self, robot_service) -&gt; bool:&#10;        &quot;&quot;&quot;Dừng phát âm thanh&quot;&quot;&quot;&#10;        try:&#10;            if self.is_playing and robot_service.is_connected:&#10;                block = StopPlayAudio()&#10;                result_type, response = await block.execute()&#10;&#10;                if result_type == MiniApiResultType.Success:&#10;                    self.is_playing = False&#10;                    self.current_audio = None&#10;                    print(&quot; Audio stopped&quot;)&#10;                    return True&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error stopping audio: {e}&quot;)&#10;&#10;        return False&#10;&#10;# Global instance&#10;robot_audio_service = RobotAudioService()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Robot Audio Service - Phát âm thanh qua robot Alpha Mini&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;import logging&#10;from typing import Optional&#10;from mini.apis.api_sound import StartPlayTTS, StopPlayTTS, ControlTTSResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class RobotAudioService:&#10;    &quot;&quot;&quot;Service để phát âm thanh qua robot Alpha Mini&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.is_playing = False&#10;        self.current_audio = None&#10;        &#10;    async def play_text_to_speech(self, text: str, robot_service) -&gt; bool:&#10;        &quot;&quot;&quot;Phát text-to-speech qua robot&quot;&quot;&quot;&#10;        if not robot_service.is_connected or not robot_service.is_in_program_mode:&#10;            logger.error(&quot;Robot not connected or not in program mode&quot;)&#10;            return False&#10;            &#10;        try:&#10;            print(f&quot;️ Robot speaking: {text}&quot;)&#10;            &#10;            block = StartPlayTTS(text=text)&#10;            result_type, response = await block.execute()&#10;            &#10;            if result_type == MiniApiResultType.Success and response and response.isSuccess:&#10;                self.is_playing = True&#10;                print(f&quot;✅ TTS playing successfully&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠️ Failed to play TTS: {response.resultCode if response else 'No response'}&quot;)&#10;                return False&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error playing TTS: {e}&quot;)&#10;            return False&#10;    &#10;    async def announce_music_info(self, filename: str, tempo: float, robot_service) -&gt; bool:&#10;        &quot;&quot;&quot;Thông báo thông tin bài nhạc&quot;&quot;&quot;&#10;        try:&#10;            # Tạo thông báo tiếng Việt&#10;            announcement = f&quot;Bắt đầu nhảy theo bài nhạc {filename}. Nhịp độ {tempo:.0f} BPM&quot;&#10;            return await self.play_text_to_speech(announcement, robot_service)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error announcing music info: {e}&quot;)&#10;            return False&#10;    &#10;    async def stop_audio(self, robot_service) -&gt; bool:&#10;        &quot;&quot;&quot;Dừng phát âm thanh&quot;&quot;&quot;&#10;        try:&#10;            if self.is_playing and robot_service.is_connected:&#10;                block = StopPlayTTS()&#10;                result_type, response = await block.execute()&#10;                &#10;                if result_type == MiniApiResultType.Success:&#10;                    self.is_playing = False&#10;                    self.current_audio = None&#10;                    print(&quot; Audio stopped&quot;)&#10;                    return True&#10;                    &#10;        except Exception as e:&#10;            logger.error(f&quot;Error stopping audio: {e}&quot;)&#10;            &#10;        return False&#10;&#10;# Global instance&#10;robot_audio_service = RobotAudioService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/utils/helpers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/utils/helpers.py" />
              <option name="updatedContent" value="import os&#10;import uuid&#10;import json&#10;from typing import Any, Dict&#10;from datetime import datetime&#10;import aiofiles&#10;&#10;async def ensure_directories():&#10;    &quot;&quot;&quot;Đảm bảo tất cả thư mục cần thiết đều tồn tại&quot;&quot;&quot;&#10;    directories = [&#10;        &quot;uploads/music&quot;,&#10;        &quot;uploads/ubx&quot;, &#10;        &quot;data/analysis&quot;,&#10;        &quot;data/choreography&quot;&#10;    ]&#10;    &#10;    for directory in directories:&#10;        os.makedirs(directory, exist_ok=True)&#10;&#10;def generate_unique_id() -&gt; str:&#10;    &quot;&quot;&quot;Tạo ID unique&quot;&quot;&quot;&#10;    return str(uuid.uuid4())&#10;&#10;async def save_json_file(data: Dict[str, Any], file_path: str):&#10;    &quot;&quot;&quot;Lưu dữ liệu JSON vào file&quot;&quot;&quot;&#10;    async with aiofiles.open(file_path, 'w', encoding='utf-8') as f:&#10;        await f.write(json.dumps(data, ensure_ascii=False, indent=2, default=str))&#10;&#10;async def load_json_file(file_path: str) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Load dữ liệu JSON từ file&quot;&quot;&quot;&#10;    async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:&#10;        content = await f.read()&#10;        return json.loads(content)&#10;&#10;def validate_audio_file(filename: str, allowed_extensions: list) -&gt; bool:&#10;    &quot;&quot;&quot;Kiểm tra định dạng file audio&quot;&quot;&quot;&#10;    return any(filename.lower().endswith(ext) for ext in allowed_extensions)&#10;&#10;def format_duration(seconds: float) -&gt; str:&#10;    &quot;&quot;&quot;Format thời gian từ giây sang mm:ss&quot;&quot;&quot;&#10;    minutes = int(seconds // 60)&#10;    seconds = int(seconds % 60)&#10;    return f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;def calculate_file_size_mb(size_bytes: int) -&gt; float:&#10;    &quot;&quot;&quot;Tính kích thước file theo MB&quot;&quot;&quot;&#10;    return round(size_bytes / (1024 * 1024), 2)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/demo_complete_music_dance.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo_complete_music_dance.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Complete Alpha Mini Music Dance Demo&#10;Robot sẽ phát nhạc từ file import và nhảy liên tục theo choreography&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import os&#10;import sys&#10;from pathlib import Path&#10;from typing import Optional&#10;import time&#10;&#10;# Add project root to path&#10;sys.path.append(str(Path(__file__).parent))&#10;&#10;from app.services.music_analysis import MusicAnalysisService&#10;from app.services.ai_choreographer import ai_choreographer_service&#10;from app.services.alpha_mini_robot import alpha_mini_robot_service&#10;from app.services.robot_audio import robot_audio_service&#10;&#10;class CompleteMusicDanceDemo:&#10;    &quot;&quot;&quot;Demo hoàn chỉnh với robot nhảy và phát nhạc đồng thời&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.music_analysis_service = MusicAnalysisService()&#10;        self.choreographer = ai_choreographer_service&#10;        self.robot_service = alpha_mini_robot_service&#10;        self.audio_service = robot_audio_service&#10;        &#10;    async def run_full_demo(self, music_file_path: str):&#10;        &quot;&quot;&quot;Chạy demo hoàn chỉnh với nhạc và choreography&quot;&quot;&quot;&#10;        &#10;        if not os.path.exists(music_file_path):&#10;            print(f&quot;❌ File không tồn tại: {music_file_path}&quot;)&#10;            return&#10;            &#10;        filename = os.path.basename(music_file_path)&#10;        print(f&quot; Bắt đầu demo với file: {filename}&quot;)&#10;        &#10;        try:&#10;            # Bước 1: Kết nối robot&#10;            print(&quot; Đang kết nối robot...&quot;)&#10;            connected = await self.robot_service.find_and_connect(&quot;000341&quot;)&#10;            if not connected:&#10;                print(&quot;❌ Không thể kết nối robot&quot;)&#10;                return&#10;                &#10;            # Bước 2: Phân tích nhạc&#10;            print(&quot; Phân tích nhạc...&quot;)&#10;            music_analysis = await self.music_analysis_service.analyze_audio_file(&#10;                music_file_path, filename&#10;            )&#10;            &#10;            print(f&quot;✅ Phân tích hoàn thành:&quot;)&#10;            print(f&quot;   - Thời lượng: {music_analysis.duration:.2f}s&quot;)&#10;            print(f&quot;   - Tempo: {music_analysis.tempo:.1f} BPM&quot;)&#10;            print(f&quot;   - Số beats: {len(music_analysis.beats)}&quot;)&#10;            &#10;            # Bước 3: Tạo choreography&#10;            print(&quot; Tạo choreography...&quot;)&#10;            choreography = await self.choreographer.create_choreography_from_analysis(&#10;                music_analysis, filename&#10;            )&#10;            &#10;            print(f&quot;✅ Choreography tạo thành công với {len(choreography.segments)} segments&quot;)&#10;            &#10;            # Bước 4: Thực hiện performance&#10;            await self.perform_with_music(music_file_path, choreography, music_analysis)&#10;            &#10;        except Exception as e:&#10;            print(f&quot;❌ Lỗi trong demo: {e}&quot;)&#10;        finally:&#10;            # Ngắt kết nối robot&#10;            await self.robot_service.disconnect()&#10;    &#10;    async def perform_with_music(self, music_file_path: str, choreography, music_analysis):&#10;        &quot;&quot;&quot;Thực hiện performance với nhạc và choreography đồng bộ&quot;&quot;&quot;&#10;        &#10;        print(&quot; Bắt đầu performance...&quot;)&#10;        print(&quot; Phát nhạc và bắt đầu choreography...&quot;)&#10;        &#10;        # Bắt đầu phát nhạc (external audio player vì robot audio có thể không hỗ trợ file custom)&#10;        music_task = None&#10;        try:&#10;            music_task = asyncio.create_task(&#10;                self.play_external_audio(music_file_path, music_analysis.duration)&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;⚠️ Không thể phát nhạc: {e}&quot;)&#10;        &#10;        # Thực hiện choreography từ đầu đến cuối&#10;        start_time = time.time()&#10;        &#10;        for i, segment in enumerate(choreography.segments):&#10;            current_time = time.time() - start_time&#10;            &#10;            # Kiểm tra timing&#10;            if current_time &lt; segment.start_time:&#10;                wait_time = segment.start_time - current_time&#10;                if wait_time &gt; 0:&#10;                    await asyncio.sleep(wait_time)&#10;            &#10;            # Thực hiện segment&#10;            await self.execute_segment(segment, i + 1)&#10;        &#10;        print(&quot; Performance hoàn thành!&quot;)&#10;        &#10;        # Dừng nhạc nếu còn đang phát&#10;        if music_task and not music_task.done():&#10;            music_task.cancel()&#10;    &#10;    async def execute_segment(self, segment, segment_num):&#10;        &quot;&quot;&quot;Thực hiện một segment choreography&quot;&quot;&quot;&#10;        &#10;        actions = segment.parameters.get(&quot;actions&quot;, [])&#10;        primary_emotion = segment.parameters.get(&quot;primary_emotion&quot;, &quot;unknown&quot;)&#10;        energy_level = segment.parameters.get(&quot;energy_level&quot;, &quot;medium&quot;)&#10;        &#10;        print(f&quot; Segment {segment_num}: {primary_emotion} ({energy_level} energy)&quot;)&#10;        print(f&quot;   Thời gian: {segment.start_time:.1f}s - {segment.end_time:.1f}s&quot;)&#10;        &#10;        segment_duration = segment.end_time - segment.start_time&#10;        &#10;        if len(actions) == 0:&#10;            await asyncio.sleep(segment_duration)&#10;            return&#10;        &#10;        # Chia đều thời gian cho các actions trong segment&#10;        action_duration = segment_duration / len(actions)&#10;        &#10;        for j, action in enumerate(actions):&#10;            action_name = action.get(&quot;name&quot;, &quot;unknown&quot;)&#10;            action_type = action.get(&quot;type&quot;, &quot;action&quot;)&#10;            &#10;            print(f&quot;   Action {j+1}: {action_name} ({action_type})&quot;)&#10;            &#10;            # Tạo tasks đồng thời cho action và expression&#10;            tasks = []&#10;            &#10;            # Action chính&#10;            if action_type in [&quot;dance&quot;, &quot;action&quot;, &quot;movement&quot;]:&#10;                tasks.append(&#10;                    asyncio.create_task(&#10;                        self.robot_service.execute_action(action_name, action_duration)&#10;                    )&#10;                )&#10;            elif action_type == &quot;expression&quot;:&#10;                tasks.append(&#10;                    asyncio.create_task(&#10;                        self.robot_service.play_expression(action_name)&#10;                    )&#10;                )&#10;            &#10;            # Thêm expression ngẫu nhiên để robot sinh động hơn&#10;            if j % 2 == 0 and primary_emotion != &quot;unknown&quot;:&#10;                # Thêm expression phù hợp với cảm xúc&#10;                emotion_expressions = {&#10;                    &quot;happy&quot;: [&quot;codemao10&quot;, &quot;emo_007&quot;, &quot;codemao20&quot;],&#10;                    &quot;energetic&quot;: [&quot;codemao11&quot;, &quot;codemao12&quot;, &quot;emo_007&quot;],&#10;                    &quot;calm&quot;: [&quot;codemao19&quot;, &quot;emo_010&quot;, &quot;codemao6&quot;],&#10;                    &quot;sad&quot;: [&quot;codemao2&quot;, &quot;codemao15&quot;, &quot;emo_009&quot;],&#10;                    &quot;excited&quot;: [&quot;codemao8&quot;, &quot;codemao10&quot;, &quot;codemao11&quot;]&#10;                }&#10;                &#10;                if primary_emotion in emotion_expressions:&#10;                    expression = emotion_expressions[primary_emotion][j % len(emotion_expressions[primary_emotion])]&#10;                    tasks.append(&#10;                        asyncio.create_task(&#10;                            self.robot_service.play_expression(expression)&#10;                        )&#10;                    )&#10;            &#10;            # Chờ các tasks hoàn thành hoặc timeout&#10;            if tasks:&#10;                try:&#10;                    await asyncio.wait_for(&#10;                        asyncio.gather(*tasks, return_exceptions=True),&#10;                        timeout=action_duration + 1.0&#10;                    )&#10;                except asyncio.TimeoutError:&#10;                    print(f&quot;⚠️ Action timeout: {action_name}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;⚠️ Action error: {e}&quot;)&#10;            else:&#10;                await asyncio.sleep(action_duration)&#10;    &#10;    async def play_external_audio(self, file_path: str, duration: float):&#10;        &quot;&quot;&quot;Phát nhạc bằng audio player external&quot;&quot;&quot;&#10;        try:&#10;            # Sử dụng pygame để phát nhạc&#10;            import pygame&#10;            &#10;            pygame.mixer.init()&#10;            pygame.mixer.music.load(file_path)&#10;            pygame.mixer.music.play()&#10;            &#10;            print(f&quot; Phát nhạc: {os.path.basename(file_path)}&quot;)&#10;            &#10;            # Chờ nhạc phát xong&#10;            await asyncio.sleep(duration)&#10;            &#10;            pygame.mixer.music.stop()&#10;            pygame.mixer.quit()&#10;            &#10;        except Exception as e:&#10;            print(f&quot;⚠️ Lỗi phát nhạc: {e}&quot;)&#10;            # Fallback: chỉ chờ thời gian&#10;            await asyncio.sleep(duration)&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main function&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini Complete Music Dance Demo&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    # Tìm file nhạc trong thư mục uploads/music&#10;    music_dir = Path(&quot;uploads/music&quot;)&#10;    music_files = []&#10;    &#10;    if music_dir.exists():&#10;        for ext in ['*.mp3', '*.wav', '*.m4a']:&#10;            music_files.extend(list(music_dir.glob(ext)))&#10;    &#10;    if not music_files:&#10;        print(&quot;❌ Không tìm thấy file nhạc trong uploads/music/&quot;)&#10;        print(&quot;   Hãy thêm file nhạc (.mp3, .wav, .m4a) vào thư mục này&quot;)&#10;        return&#10;    &#10;    # Hiển thị danh sách file nhạc&#10;    print(f&quot; Tìm thấy {len(music_files)} file nhạc:&quot;)&#10;    for i, file in enumerate(music_files, 1):&#10;        print(f&quot;   {i}. {file.name}&quot;)&#10;    &#10;    # Chọn file đầu tiên hoặc cho user chọn&#10;    selected_file = music_files[0]&#10;    print(f&quot;\n Sử dụng file: {selected_file.name}&quot;)&#10;    &#10;    # Chạy demo&#10;    demo = CompleteMusicDanceDemo()&#10;    await demo.run_full_demo(str(selected_file))&#10;&#10;if __name__ == '__main__':&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;alpha-mini-backend&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Backend system for Alpha Mini robot music analysis and dance choreography&quot;,&#10;  &quot;main&quot;: &quot;src/server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node src/server.js&quot;,&#10;    &quot;dev&quot;: &quot;nodemon src/server.js&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;ubtech&quot;, &quot;alpha-mini&quot;, &quot;music-analysis&quot;, &quot;robotics&quot;, &quot;dance&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;MIT&quot;,&#10;  &quot;dependencies&quot;: {&#10;    &quot;express&quot;: &quot;^4.18.2&quot;,&#10;    &quot;multer&quot;: &quot;^1.4.5-lts.1&quot;,&#10;    &quot;cors&quot;: &quot;^2.8.5&quot;,&#10;    &quot;dotenv&quot;: &quot;^16.3.1&quot;,&#10;    &quot;node-wav&quot;: &quot;^0.0.2&quot;,&#10;    &quot;music-tempo&quot;: &quot;^0.1.1&quot;,&#10;    &quot;web-audio-beat-detector&quot;: &quot;^8.0.4&quot;,&#10;    &quot;fft-js&quot;: &quot;^0.0.12&quot;,&#10;    &quot;socket.io&quot;: &quot;^4.7.2&quot;,&#10;    &quot;uuid&quot;: &quot;^9.0.0&quot;,&#10;    &quot;fs-extra&quot;: &quot;^11.1.1&quot;,&#10;    &quot;path&quot;: &quot;^0.12.7&quot;,&#10;    &quot;axios&quot;: &quot;^1.4.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;nodemon&quot;: &quot;^3.0.1&quot;,&#10;    &quot;jest&quot;: &quot;^29.6.1&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/robot_connection.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/robot_connection.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Robot Connection Module - Based on working UBtech example&#10;Kết nối robot Alpha Mini sử dụng phương pháp đã test thành công&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import logging&#10;&#10;# Apply websocket compatibility patch before importing Mini SDK&#10;from websocket_patch import apply_websocket_patch&#10;apply_websocket_patch()&#10;&#10;import mini.mini_sdk as MiniSdk&#10;from mini.dns.dns_browser import WiFiDevice&#10;&#10;&#10;class RobotConnection:&#10;    &quot;&quot;&quot;Class quản lý kết nối robot Alpha Mini&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.device = None&#10;        self.is_connected = False&#10;        self.is_in_program_mode = False&#10;        &#10;        # Set log level and robot type như trong example thành công&#10;        MiniSdk.set_log_level(logging.INFO)&#10;        MiniSdk.set_robot_type(MiniSdk.RobotType.EDU)&#10;&#10;    async def find_device_by_serial(self, serial_suffix=&quot;000341&quot;, timeout=10):&#10;        &quot;&quot;&quot;Tìm robot theo đuôi serial number&quot;&quot;&quot;&#10;        try:&#10;            result = await MiniSdk.get_device_by_name(serial_suffix, timeout)&#10;            print(f&quot;find_device_by_serial result: {result}&quot;)&#10;            return result&#10;        except Exception as e:&#10;            print(f&quot;Error finding device by serial: {e}&quot;)&#10;            return None&#10;&#10;    async def find_all_devices(self, timeout=10):&#10;        &quot;&quot;&quot;Tìm tất cả devices&quot;&quot;&quot;&#10;        try:&#10;            results = await MiniSdk.get_device_list(timeout)&#10;            print(f&quot;find_all_devices results = {results}&quot;)&#10;            return results&#10;        except Exception as e:&#10;            print(f&quot;Error finding devices: {e}&quot;)&#10;            return []&#10;&#10;    async def connect(self, device: WiFiDevice) -&gt; bool:&#10;        &quot;&quot;&quot;Kết nối với device&quot;&quot;&quot;&#10;        try:&#10;            success = await MiniSdk.connect(device)&#10;            if success:&#10;                self.device = device&#10;                self.is_connected = True&#10;                print(f&quot;Successfully connected to {device.name}&quot;)&#10;            return success&#10;        except Exception as e:&#10;            print(f&quot;Error connecting to device: {e}&quot;)&#10;            return False&#10;&#10;    async def enter_program_mode(self):&#10;        &quot;&quot;&quot;Vào chế độ programming&quot;&quot;&quot;&#10;        try:&#10;            await MiniSdk.enter_program()&#10;            self.is_in_program_mode = True&#10;            print(&quot;Entered programming mode successfully&quot;)&#10;            # Wait for robot to finish announcement&#10;            await asyncio.sleep(2)&#10;        except Exception as e:&#10;            print(f&quot;Error entering program mode: {e}&quot;)&#10;            raise&#10;&#10;    async def disconnect(self):&#10;        &quot;&quot;&quot;Ngắt kết nối và giải phóng tài nguyên&quot;&quot;&quot;&#10;        try:&#10;            if self.is_in_program_mode:&#10;                await MiniSdk.quit_program()&#10;                self.is_in_program_mode = False&#10;            &#10;            if self.is_connected:&#10;                await MiniSdk.release()&#10;                self.is_connected = False&#10;                self.device = None&#10;            &#10;            print(&quot;Robot disconnected successfully&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error during disconnect: {e}&quot;)&#10;&#10;    async def find_and_connect_auto(self, serial_suffix=&quot;000341&quot;):&#10;        &quot;&quot;&quot;Tự động tìm và kết nối robot&quot;&quot;&quot;&#10;        # Thử tìm theo serial trước&#10;        device = await self.find_device_by_serial(serial_suffix)&#10;        &#10;        if not device:&#10;            # Nếu không tìm thấy theo serial, tìm tất cả&#10;            devices = await self.find_all_devices()&#10;            if devices and len(devices) &gt; 0:&#10;                device = devices[0]&#10;        &#10;        if not device:&#10;            print(&quot;No robot found&quot;)&#10;            return False&#10;            &#10;        # Kết nối&#10;        if await self.connect(device):&#10;            print(&quot;Connection successful, entering program mode...&quot;)&#10;            await asyncio.sleep(2)  # Wait for connection to stabilize&#10;            await self.enter_program_mode()&#10;            return True&#10;        else:&#10;            print(&quot;Failed to connect to device&quot;)&#10;            return False&#10;&#10;&#10;# Global instance&#10;robot_connection = RobotConnection()&#10;&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Test connection&quot;&quot;&quot;&#10;    try:&#10;        success = await robot_connection.find_and_connect_auto()&#10;        if success:&#10;            print(&quot;Connection test completed successfully!&quot;)&#10;            await asyncio.sleep(2)&#10;            await robot_connection.disconnect()&#10;        else:&#10;            print(&quot;Connection test failed&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error in main: {e}&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_complete_demo.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_complete_demo.bat" />
              <option name="updatedContent" value="@echo off&#10;echo Starting Alpha Mini Complete Music Dance Demo...&#10;echo ===============================================&#10;&#10;cd /d &quot;D:\AlphaMini\alpha-mini-backend&quot;&#10;&#10;echo Activating virtual environment...&#10;call .venv\Scripts\activate.bat&#10;&#10;echo Running complete music dance demo...&#10;python demo_complete_music_dance.py&#10;&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_full_demo.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_full_demo.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ======================================&#10;echo    ALPHA MINI AI MUSIC CHOREOGRAPHER&#10;echo ======================================&#10;echo.&#10;echo Buoc 1: Phan tich nhac va tao choreography AI...&#10;python demo_ai_music_choreographer.py&#10;echo.&#10;echo Buoc 2: Robot nhay theo nhac (neu robot online)...&#10;python demo_robot_dance_with_music.py&#10;echo.&#10;echo ======================================&#10;echo    HOAN THANH!&#10;echo ======================================&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/setup.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/setup.bat" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo    Alpha Mini Backend Setup Script&#10;echo ========================================&#10;&#10;echo Step 1: Checking Python installation...&#10;python --version &gt;nul 2&gt;&amp;1&#10;if errorlevel 1 (&#10;    echo.&#10;    echo ❌ Python NOT FOUND!&#10;    echo.&#10;    echo Please install Python first:&#10;    echo.&#10;    echo Method 1 - Microsoft Store ^(Recommended^):&#10;    echo   1. Press Win + S, search &quot;Microsoft Store&quot;&#10;    echo   2. Search for &quot;Python 3.11&quot; or &quot;Python 3.10&quot;&#10;    echo   3. Click Install&#10;    echo.&#10;    echo Method 2 - Official Website:&#10;    echo   1. Go to: https://www.python.org/downloads/&#10;    echo   2. Download Python 3.10 or 3.11&#10;    echo   3. IMPORTANT: Check &quot;Add Python to PATH&quot; during installation&#10;    echo.&#10;    echo Method 3 - Using winget ^(if available^):&#10;    echo   winget install Python.Python.3.11&#10;    echo.&#10;    echo After installing Python, run this script again.&#10;    echo.&#10;    pause&#10;    exit /b 1&#10;) else (&#10;    echo ✅ Python found!&#10;    python --version&#10;)&#10;&#10;echo.&#10;echo Step 2: Checking pip...&#10;python -m pip --version &gt;nul 2&gt;&amp;1&#10;if errorlevel 1 (&#10;    echo ❌ pip not found! Installing pip...&#10;    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py&#10;    python get-pip.py&#10;    del get-pip.py&#10;) else (&#10;    echo ✅ pip found!&#10;    python -m pip --version&#10;)&#10;&#10;echo.&#10;echo Step 3: Upgrading pip to latest version...&#10;python -m pip install --upgrade pip&#10;&#10;echo.&#10;echo Step 4: Installing required packages...&#10;echo This may take a few minutes, please wait...&#10;python -m pip install -r requirements.txt&#10;&#10;echo.&#10;echo Step 5: Creating necessary directories...&#10;if not exist &quot;uploads\music&quot; (&#10;    mkdir uploads\music&#10;    echo ✅ Created uploads\music&#10;)&#10;if not exist &quot;uploads\ubx&quot; (&#10;    mkdir uploads\ubx&#10;    echo ✅ Created uploads\ubx&#10;)&#10;if not exist &quot;data\analysis&quot; (&#10;    mkdir data\analysis&#10;    echo ✅ Created data\analysis&#10;)&#10;if not exist &quot;data\choreography&quot; (&#10;    mkdir data\choreography&#10;    echo ✅ Created data\choreography&#10;)&#10;&#10;echo.&#10;echo Step 6: Testing critical imports...&#10;python -c &quot;import sys; print('Python version:', sys.version)&quot;&#10;echo Testing FastAPI...&#10;python -c &quot;import fastapi; print('✅ FastAPI OK')&quot; 2&gt;nul || echo &quot;❌ FastAPI failed&quot;&#10;echo Testing librosa...&#10;python -c &quot;import librosa; print('✅ librosa OK')&quot; 2&gt;nul || echo &quot;❌ librosa failed&quot;&#10;echo Testing numpy...&#10;python -c &quot;import numpy; print('✅ numpy OK')&quot; 2&gt;nul || echo &quot;❌ numpy failed&quot;&#10;echo Testing pydantic...&#10;python -c &quot;import pydantic_settings; print('✅ pydantic-settings OK')&quot; 2&gt;nul || echo &quot;❌ pydantic-settings failed&quot;&#10;&#10;echo.&#10;echo Step 7: Final test - importing main modules...&#10;python -c &quot;from app.core.config import settings; print('✅ Config loaded successfully')&quot; 2&gt;nul || (&#10;    echo &quot;❌ Config import failed. Checking for issues...&quot;&#10;    python -c &quot;from app.core.config import settings&quot;&#10;)&#10;&#10;echo.&#10;echo ========================================&#10;echo    Setup Summary&#10;echo ========================================&#10;echo.&#10;echo If all steps completed successfully, you can now:&#10;echo   1. Run: start.bat&#10;echo   2. Or run: python main.py&#10;echo.&#10;echo Server will be available at:&#10;echo   - Main API: http://127.0.0.1:8000&#10;echo   - Documentation: http://127.0.0.1:8000/docs&#10;echo   - WebSocket: ws://127.0.0.1:8000/ws/{robot_id}&#10;echo.&#10;echo For troubleshooting, check the error messages above.&#10;echo.&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/setup_fixed.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/setup_fixed.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo    Alpha Mini Backend Setup Script&#10;echo ========================================&#10;&#10;echo Detecting Python installation...&#10;set PYTHON_CMD=&#10;set PYTHON_FOUND=0&#10;&#10;:: Try different Python commands&#10;for %%p in (python py python3 C:\Users\%USERNAME%\AppData\Local\Microsoft\WindowsApps\python.exe) do (&#10;    %%p --version &gt;nul 2&gt;&amp;1&#10;    if not errorlevel 1 (&#10;        set PYTHON_CMD=%%p&#10;        set PYTHON_FOUND=1&#10;        goto :python_found&#10;    )&#10;)&#10;&#10;:python_found&#10;if %PYTHON_FOUND%==0 (&#10;    echo ❌ Python not found in any location!&#10;    echo.&#10;    echo Please install Python:&#10;    echo 1. Go to Microsoft Store and install Python 3.11&#10;    echo 2. Or download from https://python.org and check &quot;Add to PATH&quot;&#10;    echo.&#10;    echo Then disable Windows Python aliases:&#10;    echo 1. Open Settings ^&gt; Apps ^&gt; Advanced app settings&#10;    echo 2. Go to App execution aliases&#10;    echo 3. Turn OFF python.exe and python3.exe&#10;    echo.&#10;    pause&#10;    exit /b 1&#10;)&#10;&#10;echo ✅ Found Python at: %PYTHON_CMD%&#10;%PYTHON_CMD% --version&#10;&#10;echo.&#10;echo Checking pip...&#10;%PYTHON_CMD% -m pip --version &gt;nul 2&gt;&amp;1&#10;if errorlevel 1 (&#10;    echo ❌ pip not found! This is unusual...&#10;    pause&#10;    exit /b 1&#10;) else (&#10;    echo ✅ pip is working!&#10;)&#10;&#10;echo.&#10;echo Upgrading pip...&#10;%PYTHON_CMD% -m pip install --upgrade pip&#10;&#10;echo.&#10;echo Installing dependencies...&#10;echo This may take a few minutes...&#10;%PYTHON_CMD% -m pip install -r requirements.txt&#10;&#10;if errorlevel 1 (&#10;    echo.&#10;    echo ❌ Some packages failed to install.&#10;    echo Let's try installing them one by one...&#10;    echo.&#10;    echo Installing critical packages...&#10;    %PYTHON_CMD% -m pip install fastapi uvicorn&#10;    %PYTHON_CMD% -m pip install pydantic pydantic-settings&#10;    %PYTHON_CMD% -m pip install python-multipart aiofiles&#10;    %PYTHON_CMD% -m pip install numpy scipy&#10;    echo.&#10;    echo Installing librosa ^(this may take longer^)...&#10;    %PYTHON_CMD% -m pip install librosa&#10;    echo.&#10;    echo Installing remaining packages...&#10;    %PYTHON_CMD% -m pip install python-socketio websockets requests python-dotenv&#10;)&#10;&#10;echo.&#10;echo Creating directories...&#10;if not exist &quot;uploads\music&quot; mkdir uploads\music&#10;if not exist &quot;uploads\ubx&quot; mkdir uploads\ubx&#10;if not exist &quot;data\analysis&quot; mkdir data\analysis&#10;if not exist &quot;data\choreography&quot; mkdir data\choreography&#10;&#10;echo.&#10;echo Testing imports...&#10;echo Testing FastAPI...&#10;%PYTHON_CMD% -c &quot;import fastapi; print('✅ FastAPI OK')&quot; || echo &quot;❌ FastAPI failed&quot;&#10;echo Testing librosa...&#10;%PYTHON_CMD% -c &quot;import librosa; print('✅ librosa OK')&quot; || echo &quot;❌ librosa failed&quot;&#10;echo Testing pydantic...&#10;%PYTHON_CMD% -c &quot;import pydantic_settings; print('✅ pydantic-settings OK')&quot; || echo &quot;❌ pydantic-settings failed&quot;&#10;&#10;echo.&#10;echo Creating Python launcher script...&#10;echo @echo off &gt; python_launcher.bat&#10;echo %PYTHON_CMD% %%* &gt;&gt; python_launcher.bat&#10;&#10;echo.&#10;echo ========================================&#10;echo    Setup Complete!&#10;echo ========================================&#10;echo.&#10;echo Python command found: %PYTHON_CMD%&#10;echo.&#10;echo To start the server:&#10;echo 1. Run: start.bat&#10;echo 2. Or run: python_launcher.bat main.py&#10;echo.&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/server.js" />
              <option name="updatedContent" value="const express = require('express');&#10;const cors = require('cors');&#10;const http = require('http');&#10;const socketIO = require('socket.io');&#10;require('dotenv').config();&#10;&#10;const musicController = require('./controllers/musicController');&#10;const choreographyController = require('./controllers/choreographyController');&#10;const robotController = require('./controllers/robotController');&#10;&#10;const app = express();&#10;const server = http.createServer(app);&#10;const io = socketIO(server, {&#10;  cors: {&#10;    origin: &quot;*&quot;,&#10;    methods: [&quot;GET&quot;, &quot;POST&quot;]&#10;  }&#10;});&#10;&#10;// Middleware&#10;app.use(cors());&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: true }));&#10;&#10;// Routes&#10;app.use('/api/music', musicController);&#10;app.use('/api/choreography', choreographyController);&#10;app.use('/api/robot', robotController);&#10;&#10;// Socket.io for real-time communication with robot&#10;io.on('connection', (socket) =&gt; {&#10;  console.log('Client connected:', socket.id);&#10;  &#10;  socket.on('robot-status', (data) =&gt; {&#10;    console.log('Robot status:', data);&#10;  });&#10;  &#10;  socket.on('disconnect', () =&gt; {&#10;    console.log('Client disconnected:', socket.id);&#10;  });&#10;});&#10;&#10;// Make io accessible to controllers&#10;app.set('io', io);&#10;&#10;const PORT = process.env.PORT || 3000;&#10;&#10;server.listen(PORT, () =&gt; {&#10;  console.log(`Alpha Mini Backend Server running on port ${PORT}`);&#10;  console.log(`WebSocket server ready for robot communication`);&#10;});&#10;&#10;module.exports = app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/start.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/start.bat" />
              <option name="originalContent" value="@echo off&#10;echo ========================================&#10;echo    Starting Alpha Mini Backend Server&#10;echo ========================================&#10;&#10;echo Checking server files...&#10;if not exist &quot;main.py&quot; (&#10;    echo ERROR: main.py not found!&#10;    pause&#10;    exit /b 1&#10;)&#10;&#10;echo Starting FastAPI server...&#10;echo Server will be available at: http://127.0.0.1:8000&#10;echo API Documentation at: http://127.0.0.1:8000/docs&#10;echo.&#10;echo Press Ctrl+C to stop the server&#10;echo.&#10;&#10;python main.py&#10;" />
              <option name="updatedContent" value="@echo off&#10;echo ========================================&#10;echo    Starting Alpha Mini Backend Server&#10;echo ========================================&#10;&#10;echo Checking server files...&#10;if not exist &quot;main.py&quot; (&#10;    echo ERROR: main.py not found!&#10;    pause&#10;    exit /b 1&#10;)&#10;&#10;echo Starting FastAPI server...&#10;echo Server will be available at: http://127.0.0.1:8000&#10;echo API Documentation at: http://127.0.0.1:8000/docs&#10;echo.&#10;echo Press Ctrl+C to stop the server&#10;echo.&#10;&#10;python main.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_behaviors.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_behaviors.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test available behaviors and expressions on Alpha Mini robot&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import sys&#10;import os&#10;&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_available_behaviors():&#10;    &quot;&quot;&quot;Test different behaviors to see what makes the robot actually move&quot;&quot;&quot;&#10;    print(&quot;Testing Available Robot Behaviors&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    # Connect to robot&#10;    devices = await robot_service.search_all_robots(timeout=5)&#10;    if not devices:&#10;        print(&quot;No robot found!&quot;)&#10;        return&#10;    &#10;    connected = await robot_service.connect_robot(devices[0])&#10;    if not connected:&#10;        print(&quot;Failed to connect!&quot;)&#10;        return&#10;    &#10;    print(&quot;Robot connected! Testing behaviors...&quot;)&#10;    &#10;    # Test different dance behaviors&#10;    dance_behaviors = [&#10;        &quot;dance_0001&quot;, &quot;dance_0002&quot;, &quot;dance_0003&quot;, &quot;dance_0004&quot;, &#10;        &quot;dance_0005&quot;, &quot;dance_0006&quot;, &quot;dance_0007&quot;, &quot;dance_0008&quot;,&#10;        &quot;dance_0001en&quot;, &quot;dance_0002en&quot;, &quot;dance_0003en&quot;, &quot;dance_0004en&quot;,&#10;        &quot;dance_0005en&quot;, &quot;dance_0006en&quot;, &quot;dance_0007en&quot;, &quot;dance_0008en&quot;&#10;    ]&#10;    &#10;    for i, behavior in enumerate(dance_behaviors[:5]):  # Test first 5&#10;        try:&#10;            print(f&quot;\n{i+1}. Testing behavior: {behavior}&quot;)&#10;            success = await robot_service._start_behavior(behavior)&#10;            if success:&#10;                print(f&quot;   ✅ {behavior} started successfully!&quot;)&#10;                await asyncio.sleep(5)  # Let it run for 5 seconds&#10;                await robot_service._stop_current_behavior()&#10;                await asyncio.sleep(1)  # Brief pause between behaviors&#10;            else:&#10;                print(f&quot;   ❌ {behavior} failed to start&quot;)&#10;        except Exception as e:&#10;            print(f&quot;   ❌ {behavior} error: {e}&quot;)&#10;    &#10;    # Test some expressions that might have movement&#10;    movement_expressions = [&#10;        &quot;codemao1&quot;, &quot;codemao7&quot;, &quot;codemao10&quot;, &quot;codemao11&quot;, &quot;codemao12&quot;, &#10;        &quot;codemao14&quot;, &quot;codemao18&quot;, &quot;happy&quot;, &quot;excited&quot;&#10;    ]&#10;    &#10;    print(f&quot;\nTesting movement expressions...&quot;)&#10;    for i, expression in enumerate(movement_expressions[:3]):  # Test first 3&#10;        try:&#10;            print(f&quot;\n{i+1}. Testing expression: {expression}&quot;)&#10;            success = await robot_service._play_expression(expression)&#10;            if success:&#10;                print(f&quot;   ✅ {expression} played successfully!&quot;)&#10;                await asyncio.sleep(3)  # Let it play&#10;            else:&#10;                print(f&quot;   ❌ {expression} failed&quot;)&#10;        except Exception as e:&#10;            print(f&quot;   ❌ {expression} error: {e}&quot;)&#10;    &#10;    # Test sports/exercise behaviors&#10;    sports_behaviors = [&#10;        &quot;sports_0001&quot;, &quot;sports_0002&quot;, &quot;sports_0003&quot;, &quot;sports_0004&quot;&#10;    ]&#10;    &#10;    print(f&quot;\nTesting sports behaviors...&quot;)&#10;    for i, behavior in enumerate(sports_behaviors[:2]):  # Test first 2&#10;        try:&#10;            print(f&quot;\n{i+1}. Testing sports: {behavior}&quot;)&#10;            success = await robot_service._start_behavior(behavior)&#10;            if success:&#10;                print(f&quot;   ✅ {behavior} started successfully!&quot;)&#10;                await asyncio.sleep(4)  # Let it run&#10;                await robot_service._stop_current_behavior()&#10;                await asyncio.sleep(1)&#10;            else:&#10;                print(f&quot;   ❌ {behavior} failed to start&quot;)&#10;        except Exception as e:&#10;            print(f&quot;   ❌ {behavior} error: {e}&quot;)&#10;    &#10;    await robot_service.disconnect_robot()&#10;    print(&quot;\nTest completed!&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(test_available_behaviors())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_complete_music_dance.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_complete_music_dance.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Complete robot performance: Play imported music + synchronized dance&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;from app.services.music_analysis import music_analysis_service&#10;from app.services.choreography import choreography_service&#10;&#10;async def test_full_music_dance_performance():&#10;    &quot;&quot;&quot;Complete performance: robot plays imported music and dances synchronously&quot;&quot;&quot;&#10;    print(&quot; Complete Music + Dance Performance Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;This will:&quot;)&#10;    print(&quot;   Play your imported music from computer speakers&quot;)&#10;    print(&quot;   Robot will dance SYNCHRONOUSLY to the music&quot;)&#10;    print(&quot;   Combined: Music playback + Robot dance + Expressions&quot;)&#10;    print(&quot;   Full performance with proper timing&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;\n1. Connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;&#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;&#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect to robot&quot;)&#10;            return False&#10;&#10;        print(&quot;✅ Robot connected successfully!&quot;)&#10;&#10;        # Step 2: Find and analyze music&#10;        print(&quot;\n2. Finding and analyzing music...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        clean_name = music_file.replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;        print(f&quot;   Selected: {clean_name}&quot;)&#10;&#10;        # Analyze music&#10;        print(&quot;   Analyzing rhythm and beats...&quot;)&#10;        analysis_result = await music_analysis_service.analyze_audio_file(music_path, music_file)&#10;        if not analysis_result:&#10;            print(&quot;❌ Failed to analyze music&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        print(f&quot;   ✅ Analysis complete:&quot;)&#10;        print(f&quot;     - Duration: {analysis_result.duration:.1f}s&quot;)&#10;        print(f&quot;     - BPM: {analysis_result.tempo:.1f}&quot;)&#10;        print(f&quot;     - Beats: {len(analysis_result.beats)}&quot;)&#10;&#10;        # Step 3: Generate choreography&#10;        print(&quot;\n3. Generating synchronized choreography...&quot;)&#10;        choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;        if not choreography:&#10;            print(&quot;❌ Failed to generate choreography&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        # Limit to 60 seconds for demo&#10;        demo_segments = []&#10;        for segment in choreography.segments:&#10;            if segment.start_time &lt; 60.0:  # First 60 seconds&#10;                demo_segments.append(segment)&#10;            else:&#10;                break&#10;        choreography.segments = demo_segments&#10;&#10;        print(f&quot;   ✅ Choreography ready:&quot;)&#10;        print(f&quot;     - Total segments: {len(choreography.segments)}&quot;)&#10;        print(f&quot;     - Demo duration: 60 seconds&quot;)&#10;&#10;        # Step 4: Robot introduction&#10;        print(&quot;\n4. Robot introduction...&quot;)&#10;        from mini.apis.api_sound import StartPlayTTS&#10;&#10;        intro_text = f&quot;Xin chào! Tôi sẽ phát nhạc {clean_name} và nhảy đồng bộ. Chuẩn bị xem nhé!&quot;&#10;        intro_tts = StartPlayTTS(text=intro_text)&#10;        await intro_tts.execute()&#10;        await asyncio.sleep(4)&#10;&#10;        # Step 5: Execute COMPLETE performance&#10;        print(&quot;\n5. Starting COMPLETE synchronized performance...&quot;)&#10;        print(&quot;    Music will play from speakers&quot;)&#10;        print(&quot;    Robot will dance in sync&quot;)&#10;        print(&quot;    Expressions will match the music&quot;)&#10;        print(&quot;   ⏱️  Duration: 60 seconds&quot;)&#10;        print(&quot;\n    Starting in 3 seconds...&quot;)&#10;        await asyncio.sleep(3)&#10;&#10;        # Use the COMPLETE performance method&#10;        success = await robot_service.execute_choreography_with_music(choreography, music_path)&#10;&#10;        if success:&#10;            # Final robot speech&#10;            await asyncio.sleep(2)&#10;            final_text = f&quot;Kết thúc! Tôi đã nhảy {len(choreography.segments)} động tác theo nhạc {clean_name}. Các bạn thấy thế nào?&quot;&#10;            final_tts = StartPlayTTS(text=final_text)&#10;            await final_tts.execute()&#10;            await asyncio.sleep(4)&#10;&#10;            # Final bow&#10;            await robot_service._start_behavior(&quot;015&quot;)  # Welcome bow&#10;            await asyncio.sleep(2)&#10;            await robot_service._stop_current_behavior()&#10;&#10;            print(&quot; Complete Music + Dance Performance SUCCESS!&quot;)&#10;            print(&quot;   ✅ Music played from speakers&quot;)&#10;            print(&quot;   ✅ Robot danced synchronously&quot;)&#10;            print(&quot;   ✅ Expressions matched music timing&quot;)&#10;        else:&#10;            print(&quot;❌ Performance failed&quot;)&#10;&#10;        # Step 6: Disconnect&#10;        print(&quot;\n6. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;&#10;        return success&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_music_with_computer_and_robot_dance():&#10;    &quot;&quot;&quot;Alternative: Play music from computer while robot dances and speaks&quot;&quot;&quot;&#10;    print(&quot;\n Music from Computer + Robot Dance + TTS&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;&#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;&#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;&#10;        print(&quot;✅ Robot connected&quot;)&#10;&#10;        # Find music&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if not music_files:&#10;            print(&quot;❌ No music files found&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        music_path = os.path.join(music_dir, music_files[0])&#10;        clean_name = music_files[0].replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;&#10;        # Robot announces&#10;        from mini.apis.api_sound import StartPlayTTS&#10;        announce_text = f&quot;Bây giờ tôi sẽ nhảy theo bài {clean_name}. Nhạc sẽ phát từ máy tính, tôi sẽ nhảy!&quot;&#10;        announce_tts = StartPlayTTS(text=announce_text)&#10;        await announce_tts.execute()&#10;        await asyncio.sleep(4)&#10;&#10;        # Start music from computer&#10;        print(&quot; Starting music playback from computer...&quot;)&#10;        music_task = asyncio.create_task(robot_service.audio_player.play_audio_file(music_path))&#10;&#10;        # Wait for music to start&#10;        await asyncio.sleep(1)&#10;&#10;        # Robot dance sequence during music&#10;        print(&quot; Robot starting dance sequence...&quot;)&#10;&#10;        dance_moves = [&#10;            (&quot;random_short3&quot;, &quot;Vẫy tay trái!&quot;, 3),&#10;            (&quot;random_short4&quot;, &quot;Vẫy tay phải!&quot;, 3),&#10;            (&quot;015&quot;, &quot;Chào mừng!&quot;, 3),&#10;            (&quot;action_005&quot;, &quot;Thích!&quot;, 2),&#10;            (&quot;action_006&quot;, &quot;OK!&quot;, 2),&#10;            (&quot;random_short3&quot;, &quot;Lại vẫy tay!&quot;, 3),&#10;            (&quot;random_short4&quot;, &quot;Và tay kia!&quot;, 3),&#10;        ]&#10;&#10;        for action_id, comment, duration in dance_moves:&#10;            # Robot comments during dance&#10;            comment_tts = StartPlayTTS(text=comment)&#10;            await comment_tts.execute()&#10;            await asyncio.sleep(1)&#10;&#10;            # Do the movement&#10;            success = await robot_service._start_behavior(action_id)&#10;            if success:&#10;                await asyncio.sleep(duration)&#10;                await robot_service._stop_current_behavior()&#10;&#10;            await asyncio.sleep(0.5)&#10;&#10;        # Final comment&#10;        final_comment = &quot;Kết thúc! Nhạc hay và tôi nhảy đẹp!&quot;&#10;        final_tts = StartPlayTTS(text=final_comment)&#10;        await final_tts.execute()&#10;        await asyncio.sleep(3)&#10;&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Music + Dance performance completed!&quot;)&#10;&#10;        return True&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini: Complete Music + Dance System&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    print(&quot;Test Options:&quot;)&#10;    print(&quot;1. Complete synchronized performance (music from computer + robot dance)&quot;)&#10;    print(&quot;2. Music from computer + Robot dance with TTS comments&quot;)&#10;    print(&quot;3. Both performances&quot;)&#10;&#10;    choice = input(&quot;\nEnter choice (1, 2, or 3): &quot;)&#10;&#10;    if choice == &quot;1&quot;:&#10;        await test_full_music_dance_performance()&#10;    elif choice == &quot;2&quot;:&#10;        await test_music_with_computer_and_robot_dance()&#10;    elif choice == &quot;3&quot;:&#10;        await test_full_music_dance_performance()&#10;        print(&quot;\n&quot; + &quot;=&quot;*60)&#10;        input(&quot;Press Enter for second performance...&quot;)&#10;        await test_music_with_computer_and_robot_dance()&#10;    else:&#10;        print(&quot;Invalid choice, running synchronized performance...&quot;)&#10;        await test_full_music_dance_performance()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Complete robot performance: Play imported music + synchronized dance&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;from app.services.music_analysis import music_analysis_service&#10;from app.services.choreography import choreography_service&#10;&#10;async def test_full_music_dance_performance():&#10;    &quot;&quot;&quot;Complete performance: robot plays imported music and dances synchronously&quot;&quot;&quot;&#10;    print(&quot; Complete Music + Dance Performance Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;This will:&quot;)&#10;    print(&quot;   Play your imported music from computer speakers&quot;)&#10;    print(&quot;   Robot will dance SYNCHRONOUSLY to the music&quot;)&#10;    print(&quot;   Combined: Music playback + Robot dance + Expressions&quot;)&#10;    print(&quot;   Full performance with proper timing&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;\n1. Connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;&#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;&#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect to robot&quot;)&#10;            return False&#10;&#10;        print(&quot;✅ Robot connected successfully!&quot;)&#10;&#10;        # Step 2: Find and analyze music&#10;        print(&quot;\n2. Finding and analyzing music...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        clean_name = music_file.replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;        print(f&quot;   Selected: {clean_name}&quot;)&#10;&#10;        # Analyze music&#10;        print(&quot;   Analyzing rhythm and beats...&quot;)&#10;        analysis_result = await music_analysis_service.analyze_audio_file(music_path, music_file)&#10;        if not analysis_result:&#10;            print(&quot;❌ Failed to analyze music&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        print(f&quot;   ✅ Analysis complete:&quot;)&#10;        print(f&quot;     - Duration: {analysis_result.duration:.1f}s&quot;)&#10;        print(f&quot;     - BPM: {analysis_result.tempo:.1f}&quot;)&#10;        print(f&quot;     - Beats: {len(analysis_result.beats)}&quot;)&#10;&#10;        # Step 3: Generate choreography&#10;        print(&quot;\n3. Generating synchronized choreography...&quot;)&#10;        choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;        if not choreography:&#10;            print(&quot;❌ Failed to generate choreography&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        # Limit to 60 seconds for demo&#10;        demo_segments = []&#10;        for segment in choreography.segments:&#10;            if segment.start_time &lt; 60.0:  # First 60 seconds&#10;                demo_segments.append(segment)&#10;            else:&#10;                break&#10;        choreography.segments = demo_segments&#10;&#10;        print(f&quot;   ✅ Choreography ready:&quot;)&#10;        print(f&quot;     - Total segments: {len(choreography.segments)}&quot;)&#10;        print(f&quot;     - Demo duration: 60 seconds&quot;)&#10;&#10;        # Step 4: Robot introduction&#10;        print(&quot;\n4. Robot introduction...&quot;)&#10;        from mini.apis.api_sound import StartPlayTTS&#10;&#10;        intro_text = f&quot;Xin chào! Tôi sẽ phát nhạc {clean_name} và nhảy đồng bộ. Chuẩn bị xem nhé!&quot;&#10;        intro_tts = StartPlayTTS(text=intro_text)&#10;        await intro_tts.execute()&#10;        await asyncio.sleep(4)&#10;&#10;        # Step 5: Execute COMPLETE performance&#10;        print(&quot;\n5. Starting COMPLETE synchronized performance...&quot;)&#10;        print(&quot;    Music will play from speakers&quot;)&#10;        print(&quot;    Robot will dance in sync&quot;)&#10;        print(&quot;    Expressions will match the music&quot;)&#10;        print(&quot;   ⏱️  Duration: 60 seconds&quot;)&#10;        print(&quot;\n    Starting in 3 seconds...&quot;)&#10;        await asyncio.sleep(3)&#10;&#10;        # Use the COMPLETE performance method&#10;        success = await robot_service.execute_choreography_with_music(choreography, music_path)&#10;&#10;        if success:&#10;            # Final robot speech&#10;            await asyncio.sleep(2)&#10;            final_text = f&quot;Kết thúc! Tôi đã nhảy {len(choreography.segments)} động tác theo nhạc {clean_name}. Các bạn thấy thế nào?&quot;&#10;            final_tts = StartPlayTTS(text=final_text)&#10;            await final_tts.execute()&#10;            await asyncio.sleep(4)&#10;&#10;            # Final bow&#10;            await robot_service._start_behavior(&quot;015&quot;)  # Welcome bow&#10;            await asyncio.sleep(2)&#10;            await robot_service._stop_current_behavior()&#10;&#10;            print(&quot; Complete Music + Dance Performance SUCCESS!&quot;)&#10;            print(&quot;   ✅ Music played from speakers&quot;)&#10;            print(&quot;   ✅ Robot danced synchronously&quot;)&#10;            print(&quot;   ✅ Expressions matched music timing&quot;)&#10;        else:&#10;            print(&quot;❌ Performance failed&quot;)&#10;&#10;        # Step 6: Disconnect&#10;        print(&quot;\n6. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;&#10;        return success&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_music_with_computer_and_robot_dance():&#10;    &quot;&quot;&quot;Alternative: Play music from computer while robot dances and speaks&quot;&quot;&quot;&#10;    print(&quot;\n Music from Computer + Robot Dance + TTS&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;&#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;&#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;&#10;        print(&quot;✅ Robot connected&quot;)&#10;&#10;        # Find music&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if not music_files:&#10;            print(&quot;❌ No music files found&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;&#10;        music_path = os.path.join(music_dir, music_files[0])&#10;        clean_name = music_files[0].replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;&#10;        # Robot announces&#10;        from mini.apis.api_sound import StartPlayTTS&#10;        announce_text = f&quot;Bây giờ tôi sẽ nhảy theo bài {clean_name}. Nhạc sẽ phát từ máy tính, tôi sẽ nhảy!&quot;&#10;        announce_tts = StartPlayTTS(text=announce_text)&#10;        await announce_tts.execute()&#10;        await asyncio.sleep(4)&#10;&#10;        # Start music from computer&#10;        print(&quot; Starting music playback from computer...&quot;)&#10;        music_task = asyncio.create_task(robot_service.audio_player.play_audio_file(music_path))&#10;&#10;        # Wait for music to start&#10;        await asyncio.sleep(1)&#10;&#10;        # Robot dance sequence during music&#10;        print(&quot; Robot starting dance sequence...&quot;)&#10;&#10;        dance_moves = [&#10;            (&quot;random_short3&quot;, &quot;Vẫy tay trái!&quot;, 3),&#10;            (&quot;random_short4&quot;, &quot;Vẫy tay phải!&quot;, 3),&#10;            (&quot;015&quot;, &quot;Chào mừng!&quot;, 3),&#10;            (&quot;action_005&quot;, &quot;Thích!&quot;, 2),&#10;            (&quot;action_006&quot;, &quot;OK!&quot;, 2),&#10;            (&quot;random_short3&quot;, &quot;Lại vẫy tay!&quot;, 3),&#10;            (&quot;random_short4&quot;, &quot;Và tay kia!&quot;, 3),&#10;        ]&#10;&#10;        for action_id, comment, duration in dance_moves:&#10;            # Robot comments during dance&#10;            comment_tts = StartPlayTTS(text=comment)&#10;            await comment_tts.execute()&#10;            await asyncio.sleep(1)&#10;&#10;            # Do the movement&#10;            success = await robot_service._start_behavior(action_id)&#10;            if success:&#10;                await asyncio.sleep(duration)&#10;                await robot_service._stop_current_behavior()&#10;&#10;            await asyncio.sleep(0.5)&#10;&#10;        # Final comment&#10;        final_comment = &quot;Kết thúc! Nhạc hay và tôi nhảy đẹp!&quot;&#10;        final_tts = StartPlayTTS(text=final_comment)&#10;        await final_tts.execute()&#10;        await asyncio.sleep(3)&#10;&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Music + Dance performance completed!&quot;)&#10;&#10;        return True&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_continuous_full_song_performance():&#10;    &quot;&quot;&quot;Robot plays music from its speakers and dances continuously for the entire song&quot;&quot;&quot;&#10;    print(&quot; CONTINUOUS FULL SONG PERFORMANCE&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;This will:&quot;)&#10;    print(&quot;   Robot plays music from its own speakers&quot;)&#10;    print(&quot;   Robot dances CONTINUOUSLY for the entire song&quot;)&#10;    print(&quot;   Emotions and expressions throughout&quot;)&#10;    print(&quot;   No interruptions - full song performance&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;\n1. Connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;        &#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect to robot&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected successfully!&quot;)&#10;        &#10;        # Step 2: Find and analyze music&#10;        print(&quot;\n2. Analyzing music for full song performance...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;        &#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        clean_name = music_file.replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;        print(f&quot;   Selected: {clean_name}&quot;)&#10;        &#10;        # Analyze music for FULL duration&#10;        print(&quot;   Analyzing FULL song rhythm and structure...&quot;)&#10;        analysis_result = await music_analysis_service.analyze_audio_file(music_path, music_file)&#10;        if not analysis_result:&#10;            print(&quot;❌ Failed to analyze music&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        full_duration = analysis_result.duration&#10;        print(f&quot;   ✅ Full song analysis:&quot;)&#10;        print(f&quot;     - Duration: {full_duration:.1f}s ({full_duration/60:.1f} minutes)&quot;)&#10;        print(f&quot;     - BPM: {analysis_result.tempo:.1f}&quot;)&#10;        print(f&quot;     - Total beats: {len(analysis_result.beats)}&quot;)&#10;        &#10;        # Step 3: Generate FULL song choreography&#10;        print(&quot;\n3. Generating continuous choreography for ENTIRE song...&quot;)&#10;        choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;        if not choreography:&#10;            print(&quot;❌ Failed to generate choreography&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        # Keep ALL segments for full song (no cutting)&#10;        full_segments = choreography.segments&#10;        print(f&quot;   ✅ Full song choreography ready:&quot;)&#10;        print(f&quot;     - Total segments: {len(full_segments)} (FULL SONG)&quot;)&#10;        print(f&quot;     - Performance duration: {full_duration:.1f} seconds&quot;)&#10;        print(f&quot;     - Continuous dance with emotions&quot;)&#10;        &#10;        # Step 4: Robot introduction&#10;        print(&quot;\n4. Robot preparing for full performance...&quot;)&#10;        from mini.apis.api_sound import StartPlayTTS&#10;        &#10;        intro_text = f&quot;Tôi sẽ biểu diễn toàn bộ bài {clean_name} từ đầu đến cuối! Nhạc từ loa tôi, nhảy liên tục với biểu cảm. Bắt đầu!&quot;&#10;        intro_tts = StartPlayTTS(text=intro_text)&#10;        await intro_tts.execute()&#10;        await asyncio.sleep(5)&#10;        &#10;        # Step 5: Execute FULL CONTINUOUS performance&#10;        print(f&quot;\n5.  STARTING CONTINUOUS FULL SONG PERFORMANCE...&quot;)&#10;        print(f&quot;    Music: {clean_name}&quot;)&#10;        print(f&quot;   ⏱️  Duration: {full_duration:.1f}s ({full_duration/60:.1f} minutes)&quot;)&#10;        print(f&quot;    Segments: {len(full_segments)} continuous dance moves&quot;)&#10;        print(f&quot;    With emotions and expressions&quot;)&#10;        print(f&quot;    Music from robot speakers&quot;)&#10;        print(&quot;\n    PERFORMANCE STARTING...&quot;)&#10;        &#10;        # Execute the FULL performance with music from robot AND dance&#10;        success = await robot_service.execute_full_continuous_performance(choreography, music_path)&#10;        &#10;        if success:&#10;            print(&quot;\n FULL SONG PERFORMANCE COMPLETED!&quot;)&#10;            print(&quot;   ✅ Robot played entire song from its speakers&quot;)&#10;            print(&quot;   ✅ Danced continuously throughout&quot;)&#10;            print(&quot;   ✅ Showed emotions and expressions&quot;)&#10;            print(&quot;   ✅ No interruptions or gaps&quot;)&#10;            &#10;            # Final applause&#10;            await asyncio.sleep(2)&#10;            final_text = f&quot;Hoàn thành! Tôi đã biểu diễn toàn bộ bài {clean_name}. Cảm ơn các bạn đã theo dõi!&quot;&#10;            final_tts = StartPlayTTS(text=final_text)&#10;            await final_tts.execute()&#10;            await asyncio.sleep(4)&#10;        else:&#10;            print(&quot;❌ Full song performance failed&quot;)&#10;            &#10;        # Step 6: Disconnect&#10;        print(&quot;\n6. Performance complete, disconnecting...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;        &#10;        return success&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in full song performance: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini: Complete Music + Dance System&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    print(&quot;Test Options:&quot;)&#10;    print(&quot;1. Complete synchronized performance (music from computer + robot dance)&quot;)&#10;    print(&quot;2. Music from computer + Robot dance with TTS comments&quot;)&#10;    print(&quot;3. Both performances&quot;)&#10;    print(&quot;4. Continuous full song performance (robot speakers + dance)&quot;)&#10;&#10;    choice = input(&quot;\nEnter choice (1, 2, 3, or 4): &quot;)&#10;&#10;    if choice == &quot;1&quot;:&#10;        await test_full_music_dance_performance()&#10;    elif choice == &quot;2&quot;:&#10;        await test_music_with_computer_and_robot_dance()&#10;    elif choice == &quot;3&quot;:&#10;        await test_full_music_dance_performance()&#10;        print(&quot;\n&quot; + &quot;=&quot;*60)&#10;        input(&quot;Press Enter for second performance...&quot;)&#10;        await test_music_with_computer_and_robot_dance()&#10;    elif choice == &quot;4&quot;:&#10;        await test_continuous_full_song_performance()&#10;    else:&#10;        print(&quot;Invalid choice, running synchronized performance...&quot;)&#10;        await test_full_music_dance_performance()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_complete_system.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_complete_system.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Test script for complete music analysis and choreography system&#10;Run this to test the full workflow: music analysis → choreography generation → robot execution&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import sys&#10;import os&#10;&#10;# Add the current directory to path&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from app.services.music_analysis import music_analysis_service&#10;from app.services.choreography import choreography_service&#10;from app.services.alpha_mini_robot import robot_service&#10;from app.services.ubx_manager import ubx_manager&#10;&#10;async def test_music_analysis_and_choreography():&#10;    &quot;&quot;&quot;Test complete workflow from music analysis to choreography generation&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Music Analysis and Choreography Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    try:&#10;        # Test 1: Check UBX database&#10;        print(&quot;\n1. Testing UBX Database...&quot;)&#10;        dance_actions = ubx_manager.get_actions_by_category(&quot;dance&quot;)&#10;        arm_actions = ubx_manager.get_actions_by_category(&quot;arm&quot;)&#10;        head_actions = ubx_manager.get_actions_by_category(&quot;head&quot;)&#10;        expression_actions = ubx_manager.get_actions_by_category(&quot;expression&quot;)&#10;&#10;        print(f&quot;   Dance actions: {len(dance_actions)} (examples: {dance_actions[:3]})&quot;)&#10;        print(f&quot;   Arm actions: {len(arm_actions)} (examples: {arm_actions[:3]})&quot;)&#10;        print(f&quot;   Head actions: {len(head_actions)} (examples: {head_actions[:3]})&quot;)&#10;        print(f&quot;   Expression actions: {len(expression_actions)} (examples: {expression_actions[:3]})&quot;)&#10;&#10;        # Test action selection&#10;        suitable_actions = ubx_manager.get_suitable_actions(&quot;high&quot;, 2.5, 140)&#10;        print(f&quot;   High energy actions for fast tempo: {suitable_actions[:5]}&quot;)&#10;&#10;        # Test 2: Check if we have any sample music files&#10;        print(&quot;\n2. Checking for sample music files...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        if not os.path.exists(music_dir):&#10;            os.makedirs(music_dir, exist_ok=True)&#10;&#10;        music_files = [f for f in os.listdir(music_dir) if f.endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if music_files:&#10;            print(f&quot;   Found {len(music_files)} music files:&quot;)&#10;            for file in music_files[:3]:  # Show first 3&#10;                print(f&quot;     - {file}&quot;)&#10;&#10;            # Test music analysis with first file&#10;            test_file = music_files[0]&#10;            file_path = os.path.join(music_dir, test_file)&#10;&#10;            print(f&quot;\n3. Analyzing music file: {test_file}&quot;)&#10;            analysis_result = await music_analysis_service.analyze_audio_file(file_path, test_file)&#10;&#10;            print(f&quot;   Analysis completed:&quot;)&#10;            print(f&quot;     Duration: {analysis_result.duration:.2f}s&quot;)&#10;            print(f&quot;     Tempo: {analysis_result.tempo:.1f} BPM&quot;)&#10;            print(f&quot;     Beats detected: {len(analysis_result.beats)}&quot;)&#10;            print(f&quot;     Energy mean: {analysis_result.energy_analysis.get('energy_mean', 0):.3f}&quot;)&#10;&#10;            # Test choreography generation&#10;            print(f&quot;\n4. Generating choreography...&quot;)&#10;            choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;&#10;            print(f&quot;   Choreography generated:&quot;)&#10;            print(f&quot;     ID: {choreography.id}&quot;)&#10;            print(f&quot;     Total segments: {len(choreography.segments)}&quot;)&#10;&#10;            # Show choreography preview&#10;            print(f&quot;\n5. Choreography Preview:&quot;)&#10;            preview = choreography_service.preview_choreography(choreography)&#10;            print(preview)&#10;&#10;            # Test robot connection (if available)&#10;            print(f&quot;\n6. Testing robot connection...&quot;)&#10;            devices = await robot_service.search_all_robots(timeout=5)&#10;&#10;            if devices:&#10;                print(f&quot;   Found {len(devices)} robot(s)&quot;)&#10;                connected = await robot_service.connect_robot(devices[0])&#10;&#10;                if connected:&#10;                    print(&quot;   Robot connected! Testing choreography execution...&quot;)&#10;&#10;                    # Execute first few segments as demo&#10;                    demo_segments = choreography.segments[:3]  # First 3 segments&#10;                    print(f&quot;   Executing {len(demo_segments)} demo segments...&quot;)&#10;&#10;                    for i, segment in enumerate(demo_segments):&#10;                        print(f&quot;   Segment {i+1}: {segment.parameters.get('action_name', 'Unknown')}&quot;)&#10;                        await robot_service.execute_robot_action(&#10;                            segment.action,&#10;                            segment.parameters,&#10;                            min(segment.end_time - segment.start_time, 3.0)  # Max 3 seconds per demo&#10;                        )&#10;&#10;                    await robot_service.disconnect_robot()&#10;                    print(&quot;   Demo completed and robot disconnected!&quot;)&#10;                else:&#10;                    print(&quot;   Could not connect to robot&quot;)&#10;            else:&#10;                print(&quot;   No robot found - choreography ready for future execution&quot;)&#10;&#10;        else:&#10;            print(&quot;   No music files found in uploads/music/&quot;)&#10;            print(&quot;   Please add some music files (.mp3, .wav, .m4a) to test the system&quot;)&#10;&#10;            # Create a demo choreography with synthetic data&#10;            print(&quot;\n3. Creating demo choreography with synthetic data...&quot;)&#10;            from app.models.schemas import MusicAnalysisResult&#10;            from datetime import datetime&#10;&#10;            # Create synthetic analysis&#10;            demo_analysis = MusicAnalysisResult(&#10;                id=&quot;demo-analysis&quot;,&#10;                filename=&quot;demo-song.mp3&quot;,&#10;                duration=30.0,&#10;                tempo=128.0,&#10;                beats=[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0],&#10;                spectral_features={&quot;mfcc_mean&quot;: [1.0, 2.0, 3.0]},&#10;                energy_analysis={&#10;                    &quot;energy_mean&quot;: 0.7,&#10;                    &quot;rms_energy&quot;: [0.5, 0.8, 0.9, 0.6, 0.7, 0.8, 0.9, 0.5, 0.6, 0.7, 0.8, 0.9],&#10;                    &quot;rms_times&quot;: [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0],&#10;                    &quot;onset_peaks&quot;: [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5],&#10;                    &quot;peak_count&quot;: 8&#10;                },&#10;                analysis_timestamp=datetime.now(),&#10;                file_path=&quot;demo-path&quot;&#10;            )&#10;&#10;            # Generate demo choreography&#10;            demo_choreography = await choreography_service.create_choreography_from_analysis(demo_analysis)&#10;&#10;            print(&quot;Demo choreography created:&quot;)&#10;            preview = choreography_service.preview_choreography(demo_choreography)&#10;            print(preview)&#10;&#10;        # Test 7: Show all saved choreographies&#10;        print(f&quot;\n7. Saved choreographies:&quot;)&#10;        all_choreographies = choreography_service.get_all_choreographies()&#10;        if all_choreographies:&#10;            for choreo in all_choreographies[:5]:  # Show first 5&#10;                print(f&quot;   - {choreo['name']} (BPM: {choreo['bpm']:.1f}, Segments: {choreo['segment_count']})&quot;)&#10;        else:&#10;            print(&quot;   No saved choreographies found&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;Test failed with error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;Test completed!&quot;)&#10;&#10;async def show_ubx_actions():&#10;    &quot;&quot;&quot;Show detailed information about available UBX actions&quot;&quot;&quot;&#10;    print(&quot;Available UBX Actions by Category&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    categories = [&quot;dance&quot;, &quot;arm&quot;, &quot;head&quot;, &quot;expression&quot;, &quot;pose&quot;, &quot;exercise&quot;, &quot;greeting&quot;]&#10;&#10;    for category in categories:&#10;        actions = ubx_manager.get_actions_by_category(category)&#10;        print(f&quot;\n{category.upper()} Actions ({len(actions)}):&quot;)&#10;&#10;        for action_id in actions[:10]:  # Show first 10 in each category&#10;            info = ubx_manager.get_action_info(action_id)&#10;            print(f&quot;  {action_id:15} - {info.get('name', 'Unknown')} [{info.get('energy', 'medium')} energy]&quot;)&#10;&#10;        if len(actions) &gt; 10:&#10;            print(f&quot;  ... and {len(actions) - 10} more&quot;)&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Complete System Test&quot;)&#10;    print(&quot;Select test mode:&quot;)&#10;    print(&quot;1. Complete workflow test (music analysis + choreography + robot)&quot;)&#10;    print(&quot;2. Show UBX actions database&quot;)&#10;&#10;    mode = input(&quot;Enter choice (1 or 2): &quot;).strip()&#10;&#10;    if mode == &quot;1&quot;:&#10;        await test_music_analysis_and_choreography()&#10;    elif mode == &quot;2&quot;:&#10;        await show_ubx_actions()&#10;    else:&#10;        print(&quot;Invalid choice, running complete test...&quot;)&#10;        await test_music_analysis_and_choreography()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test script for complete music analysis and choreography system&#10;Run this to test the full workflow: music analysis → choreography generation → robot execution&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import sys&#10;import os&#10;&#10;# Add the current directory to path&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from app.services.music_analysis import music_analysis_service&#10;from app.services.choreography import choreography_service&#10;from app.services.alpha_mini_robot import robot_service&#10;from app.services.ubx_manager import ubx_manager&#10;&#10;async def test_music_analysis_and_choreography():&#10;    &quot;&quot;&quot;Test complete workflow from music analysis to choreography generation&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Music Analysis and Choreography Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    try:&#10;        # Test 1: Check UBX database&#10;        print(&quot;\n1. Testing UBX Database...&quot;)&#10;        dance_actions = ubx_manager.get_actions_by_category(&quot;dance&quot;)&#10;        arm_actions = ubx_manager.get_actions_by_category(&quot;arm&quot;)&#10;        head_actions = ubx_manager.get_actions_by_category(&quot;head&quot;)&#10;        expression_actions = ubx_manager.get_actions_by_category(&quot;expression&quot;)&#10;&#10;        print(f&quot;   Dance actions: {len(dance_actions)} (examples: {dance_actions[:3]})&quot;)&#10;        print(f&quot;   Arm actions: {len(arm_actions)} (examples: {arm_actions[:3]})&quot;)&#10;        print(f&quot;   Head actions: {len(head_actions)} (examples: {head_actions[:3]})&quot;)&#10;        print(f&quot;   Expression actions: {len(expression_actions)} (examples: {expression_actions[:3]})&quot;)&#10;&#10;        # Test action selection&#10;        suitable_actions = ubx_manager.get_suitable_actions(&quot;high&quot;, 2.5, 140)&#10;        print(f&quot;   High energy actions for fast tempo: {suitable_actions[:5]}&quot;)&#10;&#10;        # Test 2: Check if we have any sample music files&#10;        print(&quot;\n2. Checking for sample music files...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        if not os.path.exists(music_dir):&#10;            os.makedirs(music_dir, exist_ok=True)&#10;&#10;        music_files = [f for f in os.listdir(music_dir) if f.endswith(('.mp3', '.wav', '.m4a'))]&#10;&#10;        if music_files:&#10;            print(f&quot;   Found {len(music_files)} music files:&quot;)&#10;            for file in music_files[:3]:  # Show first 3&#10;                print(f&quot;     - {file}&quot;)&#10;&#10;            # Test music analysis with first file&#10;            test_file = music_files[0]&#10;            file_path = os.path.join(music_dir, test_file)&#10;&#10;            print(f&quot;\n3. Analyzing music file: {test_file}&quot;)&#10;            analysis_result = await music_analysis_service.analyze_audio_file(file_path, test_file)&#10;&#10;            print(f&quot;   Analysis completed:&quot;)&#10;            print(f&quot;     Duration: {analysis_result.duration:.2f}s&quot;)&#10;            print(f&quot;     Tempo: {analysis_result.tempo:.1f} BPM&quot;)&#10;            print(f&quot;     Beats detected: {len(analysis_result.beats)}&quot;)&#10;            print(f&quot;     Energy mean: {analysis_result.energy_analysis.get('energy_mean', 0):.3f}&quot;)&#10;&#10;            # Test choreography generation&#10;            print(f&quot;\n4. Generating choreography...&quot;)&#10;            choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;&#10;            print(f&quot;   Choreography generated:&quot;)&#10;            print(f&quot;     ID: {choreography.id}&quot;)&#10;            print(f&quot;     Total segments: {len(choreography.segments)}&quot;)&#10;&#10;            # Show choreography preview&#10;            print(f&quot;\n5. Choreography Preview:&quot;)&#10;            preview = choreography_service.preview_choreography(choreography)&#10;            print(preview)&#10;&#10;            # Test robot connection (if available)&#10;            print(f&quot;\n6. Testing robot connection...&quot;)&#10;            devices = await robot_service.search_all_robots(timeout=5)&#10;&#10;            if devices:&#10;                print(f&quot;   Found {len(devices)} robot(s)&quot;)&#10;                connected = await robot_service.connect_robot(devices[0])&#10;&#10;                if connected:&#10;                    print(&quot;   Robot connected! Testing choreography execution...&quot;)&#10;&#10;                    # Execute first few segments as demo&#10;                    demo_segments = choreography.segments[:3]  # First 3 segments&#10;                    print(f&quot;   Executing {len(demo_segments)} demo segments...&quot;)&#10;&#10;                    for i, segment in enumerate(demo_segments):&#10;                        action_name = getattr(segment, 'ubx_action', 'Unknown')&#10;                        print(f&quot;   Segment {i+1}: {action_name}&quot;)&#10;                        # Use the correct method from AlphaMiniRobotService&#10;                        await robot_service.execute_choreography_segment(segment)&#10;&#10;                    await robot_service.disconnect_robot()&#10;                    print(&quot;   Demo completed and robot disconnected!&quot;)&#10;                else:&#10;                    print(&quot;   Could not connect to robot&quot;)&#10;            else:&#10;                print(&quot;   No robot found - choreography ready for future execution&quot;)&#10;&#10;        else:&#10;            print(&quot;   No music files found in uploads/music/&quot;)&#10;            print(&quot;   Please add some music files (.mp3, .wav, .m4a) to test the system&quot;)&#10;&#10;            # Create a demo choreography with synthetic data&#10;            print(&quot;\n3. Creating demo choreography with synthetic data...&quot;)&#10;            from app.models.schemas import MusicAnalysisResult&#10;            from datetime import datetime&#10;&#10;            # Create synthetic analysis&#10;            demo_analysis = MusicAnalysisResult(&#10;                id=&quot;demo-analysis&quot;,&#10;                filename=&quot;demo-song.mp3&quot;,&#10;                duration=30.0,&#10;                tempo=128.0,&#10;                beats=[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0],&#10;                spectral_features={&quot;mfcc_mean&quot;: [1.0, 2.0, 3.0]},&#10;                energy_analysis={&#10;                    &quot;energy_mean&quot;: 0.7,&#10;                    &quot;rms_energy&quot;: [0.5, 0.8, 0.9, 0.6, 0.7, 0.8, 0.9, 0.5, 0.6, 0.7, 0.8, 0.9],&#10;                    &quot;rms_times&quot;: [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0],&#10;                    &quot;onset_peaks&quot;: [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5],&#10;                    &quot;peak_count&quot;: 8&#10;                },&#10;                analysis_timestamp=datetime.now(),&#10;                file_path=&quot;demo-path&quot;&#10;            )&#10;&#10;            # Generate demo choreography&#10;            demo_choreography = await choreography_service.create_choreography_from_analysis(demo_analysis)&#10;&#10;            print(&quot;Demo choreography created:&quot;)&#10;            preview = choreography_service.preview_choreography(demo_choreography)&#10;            print(preview)&#10;&#10;        # Test 7: Show all saved choreographies&#10;        print(f&quot;\n7. Saved choreographies:&quot;)&#10;        all_choreographies = choreography_service.get_all_choreographies()&#10;        if all_choreographies:&#10;            for choreo in all_choreographies[:5]:  # Show first 5&#10;                print(f&quot;   - {choreo['name']} (BPM: {choreo['bpm']:.1f}, Segments: {choreo['segment_count']})&quot;)&#10;        else:&#10;            print(&quot;   No saved choreographies found&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;Test failed with error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;Test completed!&quot;)&#10;&#10;async def show_ubx_actions():&#10;    &quot;&quot;&quot;Show detailed information about available UBX actions&quot;&quot;&quot;&#10;    print(&quot;Available UBX Actions by Category&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    categories = [&quot;dance&quot;, &quot;arm&quot;, &quot;head&quot;, &quot;expression&quot;, &quot;pose&quot;, &quot;exercise&quot;, &quot;greeting&quot;]&#10;&#10;    for category in categories:&#10;        actions = ubx_manager.get_actions_by_category(category)&#10;        print(f&quot;\n{category.upper()} Actions ({len(actions)}):&quot;)&#10;&#10;        for action_id in actions[:10]:  # Show first 10 in each category&#10;            info = ubx_manager.get_action_info(action_id)&#10;            print(f&quot;  {action_id:15} - {info.get('name', 'Unknown')} [{info.get('energy', 'medium')} energy]&quot;)&#10;&#10;        if len(actions) &gt; 10:&#10;            print(f&quot;  ... and {len(actions) - 10} more&quot;)&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Complete System Test&quot;)&#10;    print(&quot;Select test mode:&quot;)&#10;    print(&quot;1. Complete workflow test (music analysis + choreography + robot)&quot;)&#10;    print(&quot;2. Show UBX actions database&quot;)&#10;&#10;    mode = input(&quot;Enter choice (1 or 2): &quot;).strip()&#10;&#10;    if mode == &quot;1&quot;:&#10;        await test_music_analysis_and_choreography()&#10;    elif mode == &quot;2&quot;:&#10;        await show_ubx_actions()&#10;    else:&#10;        print(&quot;Invalid choice, running complete test...&quot;)&#10;        await test_music_analysis_and_choreography()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_music_only_dance.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_music_only_dance.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test robot dancing with user's music only (no built-in dance music)&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;from app.services.music_analysis import music_analysis_service&#10;from app.services.choreography import choreography_service&#10;&#10;async def test_music_only_dance():&#10;    &quot;&quot;&quot;Test robot dancing to user's imported music without built-in dance sounds&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini - Music Only Dance Test&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    try:&#10;        # Step 1: Search for robots&#10;        print(&quot;1. Searching for robots...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=10)&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        print(f&quot;✅ Found {len(devices)} robot(s)&quot;)&#10;        &#10;        # Step 2: Connect to robot&#10;        print(f&quot;2. Connecting to {devices[0].name}...&quot;)&#10;        connected = await robot_service.connect_robot(devices[0])&#10;        &#10;        if not connected:&#10;            print(&quot;❌ Failed to connect to robot&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected successfully!&quot;)&#10;        &#10;        # Step 3: Find music file&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = []&#10;        for file in os.listdir(music_dir):&#10;            if file.lower().endswith(('.mp3', '.wav', '.m4a')):&#10;                music_files.append(file)&#10;                &#10;        if not music_files:&#10;            print(&quot;❌ No music files found. Please add music files to uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        print(f&quot;3. Found music file: {music_files[0]}&quot;)&#10;        music_path = os.path.join(music_dir, music_files[0])&#10;        &#10;        # Step 4: Analyze music&#10;        print(&quot;4. Analyzing music...&quot;)&#10;        analysis_result = await music_analysis_service.analyze_audio_file(music_path, music_files[0])&#10;        &#10;        if not analysis_result:&#10;            print(&quot;❌ Failed to analyze music&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        print(f&quot;✅ Music analyzed - BPM: {analysis_result.tempo:.1f}, Duration: {analysis_result.duration:.1f}s&quot;)&#10;        &#10;        # Step 5: Generate choreography with ONLY basic movements&#10;        print(&quot;5. Generating choreography with basic movements only...&quot;)&#10;        choreography = await choreography_service.create_choreography_from_analysis(analysis_result)&#10;        &#10;        if not choreography:&#10;            print(&quot;❌ Failed to generate choreography&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        print(f&quot;✅ Choreography created with {len(choreography.segments)} segments&quot;)&#10;        &#10;        # Step 6: Preview choreography&#10;        print(&quot;\n6. Choreography Preview (first 5 segments):&quot;)&#10;        for i, segment in enumerate(choreography.segments[:5]):&#10;            action_name = &quot;Unknown&quot;&#10;            if hasattr(segment, 'ubx_action'):&#10;                action_name = segment.ubx_action&#10;            print(f&quot;   {i+1}. {segment.start_time:.1f}s - {segment.end_time:.1f}s: {segment.action} ({action_name})&quot;)&#10;        &#10;        # Step 7: Execute synchronized performance&#10;        print(f&quot;\n7. Starting synchronized performance...&quot;)&#10;        print(&quot;    Music will play from computer speakers&quot;)&#10;        print(&quot;    Robot will dance with basic movements only&quot;)&#10;        print(&quot;   ⏱️  Duration: ~30 seconds demo&quot;)&#10;        &#10;        # Create a shorter demo version (first 30 seconds)&#10;        demo_segments = []&#10;        for segment in choreography.segments:&#10;            if segment.start_time &lt; 30.0:  # Only first 30 seconds&#10;                demo_segments.append(segment)&#10;            else:&#10;                break&#10;                &#10;        # Update choreography for demo&#10;        choreography.segments = demo_segments&#10;        &#10;        success = await robot_service.execute_choreography_with_music(choreography, music_path)&#10;        &#10;        if success:&#10;            print(&quot; Music-only dance performance completed successfully!&quot;)&#10;            print(&quot;   ✅ Music played from computer&quot;)&#10;            print(&quot;   ✅ Robot danced with basic movements&quot;)&#10;        else:&#10;            print(&quot;❌ Performance failed&quot;)&#10;            &#10;        # Step 8: Disconnect robot&#10;        print(&quot;\n8. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;        &#10;        return success&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in music-only dance test: {e}&quot;)&#10;        await robot_service.disconnect_robot()&#10;        return False&#10;&#10;async def test_basic_movements_only():&#10;    &quot;&quot;&quot;Test robot with only basic movements (no dance actions with music)&quot;&quot;&quot;&#10;    print(&quot;\n Testing Basic Movements Only&quot;)&#10;    print(&quot;=&quot; * 40)&#10;    &#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected, testing basic movements...&quot;)&#10;        &#10;        # Test basic movements without music&#10;        basic_actions = [&#10;            (&quot;017&quot;, &quot;Raise both hands&quot;),&#10;            (&quot;random_short3&quot;, &quot;Wave left hand&quot;),&#10;            (&quot;random_short4&quot;, &quot;Wave right hand&quot;),&#10;            (&quot;011&quot;, &quot;Nod head&quot;),&#10;            (&quot;037&quot;, &quot;Shake head&quot;)&#10;        ]&#10;        &#10;        for action_id, description in basic_actions:&#10;            print(f&quot;Testing: {description} ({action_id})&quot;)&#10;            success = await robot_service._start_behavior(action_id)&#10;            if success:&#10;                await asyncio.sleep(2)&#10;                await robot_service._stop_current_behavior()&#10;                print(&quot;   ✅ Success&quot;)&#10;            else:&#10;                print(&quot;   ❌ Failed&quot;)&#10;            await asyncio.sleep(0.5)&#10;            &#10;        # Test expressions&#10;        print(&quot;Testing expressions...&quot;)&#10;        expressions = [(&quot;codemao1&quot;, &quot;Looking around&quot;), (&quot;codemao10&quot;, &quot;Exciting&quot;)]&#10;        &#10;        for expr_id, description in expressions:&#10;            print(f&quot;Testing: {description} ({expr_id})&quot;)&#10;            success = await robot_service._play_expression(expr_id)&#10;            if success:&#10;                print(&quot;   ✅ Success&quot;)&#10;                await asyncio.sleep(1)&#10;            else:&#10;                print(&quot;   ❌ Failed&quot;)&#10;        &#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Basic movements test completed&quot;)&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in basic movements test: {e}&quot;)&#10;        await robot_service.disconnect_robot()&#10;        return False&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Robot - Music Only Dance System Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    choice = input(&quot;\nSelect test mode:\n1. Music-only dance test\n2. Basic movements only\n3. Both tests\nEnter choice (1, 2, or 3): &quot;)&#10;    &#10;    if choice == &quot;1&quot;:&#10;        await test_music_only_dance()&#10;    elif choice == &quot;2&quot;:&#10;        await test_basic_movements_only()&#10;    elif choice == &quot;3&quot;:&#10;        await test_basic_movements_only()&#10;        await asyncio.sleep(2)&#10;        await test_music_only_dance()&#10;    else:&#10;        print(&quot;Invalid choice&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_robot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_robot.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Test script for Alpha Mini robot connection&#10;Run this to test the robot connection functionality&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import sys&#10;import os&#10;&#10;# Add the current directory to path&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_robot_connection():&#10;    &quot;&quot;&quot;Test robot connection and basic functionality&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini Robot Connection Test&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    try:&#10;        # Test 1: Search for all robots&#10;        print(&quot;\n1. Searching for all available robots...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=10)&#10;&#10;        if devices:&#10;            print(f&quot;✅ Found {len(devices)} robot(s):&quot;)&#10;            for i, device in enumerate(devices, 1):&#10;                # WiFiDevice có thuộc tính 'address' thay vì 'ip'&#10;                print(f&quot;   {i}. {device.name} - {device.address}:{device.port}&quot;)&#10;&#10;            # Test 2: Connect to first robot&#10;            print(f&quot;\n2. Attempting to connect to {devices[0].name}...&quot;)&#10;            connected = await robot_service.connect_robot(devices[0])&#10;&#10;            if connected:&#10;                print(&quot;✅ Successfully connected to robot!&quot;)&#10;                print(f&quot;   Robot: {robot_service.current_device.name}&quot;)&#10;&#10;                # Test 3: Test basic commands&#10;                print(&quot;\n3. Testing basic robot commands...&quot;)&#10;                from app.models.schemas import RobotAction&#10;&#10;                # Test dance command&#10;                await robot_service.execute_robot_action(&#10;                    RobotAction.DANCE,&#10;                    {&quot;intensity&quot;: 0.8, &quot;duration&quot;: 2.0},&#10;                    2.0&#10;                )&#10;&#10;                # Test arm movement&#10;                await robot_service.execute_robot_action(&#10;                    RobotAction.ARM_MOVEMENT,&#10;                    {&quot;amplitude&quot;: 0.6, &quot;both_arms&quot;: True},&#10;                    1.5&#10;                )&#10;&#10;                print(&quot;✅ Basic commands test completed!&quot;)&#10;&#10;                # Test 4: Disconnect&#10;                print(&quot;\n4. Disconnecting from robot...&quot;)&#10;                disconnected = await robot_service.disconnect_robot()&#10;                if disconnected:&#10;                    print(&quot;✅ Successfully disconnected!&quot;)&#10;&#10;            else:&#10;                print(&quot;❌ Failed to connect to robot&quot;)&#10;&#10;        else:&#10;            print(&quot;❌ No robots found&quot;)&#10;            print(&quot;\nTips:&quot;)&#10;            print(&quot;- Make sure your Alpha Mini robot is turned on&quot;)&#10;            print(&quot;- Check that robot is connected to the same WiFi network&quot;)&#10;            print(&quot;- Try searching with a specific serial number suffix&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Test failed with error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 50)&#10;    print(&quot;Test completed!&quot;)&#10;&#10;async def test_robot_search_by_serial():&#10;    &quot;&quot;&quot;Test searching robot by serial number&quot;&quot;&quot;&#10;    print(&quot;\n Testing robot search by serial number...&quot;)&#10;&#10;    # You can change this to your robot's serial suffix&#10;    serial_suffix = &quot;000341&quot;  # Last 6 digits of your robot's serial&#10;&#10;    device = await robot_service.search_robot_by_serial(serial_suffix, timeout=10)&#10;&#10;    if device:&#10;        print(f&quot;✅ Found robot with serial suffix '{serial_suffix}':&quot;)&#10;        print(f&quot;   Name: {device.name}&quot;)&#10;        print(f&quot;   IP: {device.ip}&quot;)&#10;        print(f&quot;   Port: {device.port}&quot;)&#10;        return device&#10;    else:&#10;        print(f&quot;❌ No robot found with serial suffix: {serial_suffix}&quot;)&#10;        return None&#10;&#10;async def interactive_test():&#10;    &quot;&quot;&quot;Interactive test mode&quot;&quot;&quot;&#10;    print(&quot; Interactive Robot Test Mode&quot;)&#10;    print(&quot;=&quot; * 40)&#10;&#10;    while True:&#10;        print(&quot;\nOptions:&quot;)&#10;        print(&quot;1. Search all robots&quot;)&#10;        print(&quot;2. Search robot by serial&quot;)&#10;        print(&quot;3. Connect to robot&quot;)&#10;        print(&quot;4. Test dance command&quot;)&#10;        print(&quot;5. Test arm movement&quot;)&#10;        print(&quot;6. Disconnect robot&quot;)&#10;        print(&quot;7. Exit&quot;)&#10;&#10;        choice = input(&quot;\nSelect option (1-7): &quot;).strip()&#10;&#10;        try:&#10;            if choice == &quot;1&quot;:&#10;                await robot_service.search_all_robots()&#10;&#10;            elif choice == &quot;2&quot;:&#10;                serial = input(&quot;Enter robot serial suffix: &quot;).strip()&#10;                await robot_service.search_robot_by_serial(serial)&#10;&#10;            elif choice == &quot;3&quot;:&#10;                if not robot_service.is_connected:&#10;                    devices = await robot_service.search_all_robots()&#10;                    if devices:&#10;                        await robot_service.connect_robot(devices[0])&#10;                    else:&#10;                        print(&quot;No robots found to connect to&quot;)&#10;                else:&#10;                    print(&quot;Already connected to a robot&quot;)&#10;&#10;            elif choice == &quot;4&quot;:&#10;                if robot_service.is_connected:&#10;                    from app.models.schemas import RobotAction&#10;                    await robot_service.execute_robot_action(&#10;                        RobotAction.DANCE,&#10;                        {&quot;intensity&quot;: 0.7},&#10;                        3.0&#10;                    )&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;5&quot;:&#10;                if robot_service.is_connected:&#10;                    from app.models.schemas import RobotAction&#10;                    await robot_service.execute_robot_action(&#10;                        RobotAction.ARM_MOVEMENT,&#10;                        {&quot;amplitude&quot;: 0.8, &quot;both_arms&quot;: True},&#10;                        2.0&#10;                    )&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;6&quot;:&#10;                if robot_service.is_connected:&#10;                    await robot_service.disconnect_robot()&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;7&quot;:&#10;                print(&quot;Exiting...&quot;)&#10;                if robot_service.is_connected:&#10;                    await robot_service.disconnect_robot()&#10;                break&#10;&#10;            else:&#10;                print(&quot;Invalid option&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error: {str(e)}&quot;)&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot;Select test mode:&quot;)&#10;    print(&quot;1. Automatic test&quot;)&#10;    print(&quot;2. Interactive test&quot;)&#10;&#10;    mode = input(&quot;Enter choice (1 or 2): &quot;).strip()&#10;&#10;    if mode == &quot;1&quot;:&#10;        await test_robot_connection()&#10;    elif mode == &quot;2&quot;:&#10;        await interactive_test()&#10;    else:&#10;        print(&quot;Invalid choice, running automatic test...&quot;)&#10;        await test_robot_connection()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test script for Alpha Mini robot connection&#10;Run this to test the robot connection functionality&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import sys&#10;import os&#10;&#10;# Add the current directory to path&#10;sys.path.append(os.path.dirname(os.path.abspath(__file__)))&#10;&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_robot_connection():&#10;    &quot;&quot;&quot;Test robot connection and basic functionality&quot;&quot;&quot;&#10;    print(&quot;Alpha Mini Robot Connection Test&quot;)&#10;    print(&quot;=&quot; * 50)&#10;&#10;    try:&#10;        # Test 1: Search for all robots&#10;        print(&quot;\n1. Searching for all available robots...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=10)&#10;&#10;        if devices:&#10;            print(f&quot;Found {len(devices)} robot(s):&quot;)&#10;            for i, device in enumerate(devices, 1):&#10;                # WiFiDevice có thuộc tính 'address' thay vì 'ip'&#10;                print(f&quot;   {i}. {device.name} - {device.address}:{device.port}&quot;)&#10;&#10;            # Test 2: Connect to first robot&#10;            print(f&quot;\n2. Attempting to connect to {devices[0].name}...&quot;)&#10;            connected = await robot_service.connect_robot(devices[0])&#10;&#10;            if connected:&#10;                print(&quot;Successfully connected to robot!&quot;)&#10;                print(f&quot;   Robot: {robot_service.current_device.name}&quot;)&#10;&#10;                # Test 3: Test basic commands&#10;                print(&quot;\n3. Testing basic robot commands...&quot;)&#10;                from app.models.schemas import RobotAction&#10;&#10;                # Test dance command&#10;                await robot_service.execute_robot_action(&#10;                    RobotAction.DANCE,&#10;                    {&quot;intensity&quot;: 0.8, &quot;duration&quot;: 2.0},&#10;                    2.0&#10;                )&#10;&#10;                # Test arm movement&#10;                await robot_service.execute_robot_action(&#10;                    RobotAction.ARM_MOVEMENT,&#10;                    {&quot;amplitude&quot;: 0.6, &quot;both_arms&quot;: True},&#10;                    1.5&#10;                )&#10;&#10;                print(&quot;Basic commands test completed!&quot;)&#10;&#10;                # Test 4: Disconnect&#10;                print(&quot;\n4. Disconnecting from robot...&quot;)&#10;                disconnected = await robot_service.disconnect_robot()&#10;                if disconnected:&#10;                    print(&quot;Successfully disconnected!&quot;)&#10;&#10;            else:&#10;                print(&quot;Failed to connect to robot&quot;)&#10;&#10;        else:&#10;            print(&quot;No robots found&quot;)&#10;            print(&quot;\nTips:&quot;)&#10;            print(&quot;- Make sure your Alpha Mini robot is turned on&quot;)&#10;            print(&quot;- Check that robot is connected to the same WiFi network&quot;)&#10;            print(&quot;- Try searching with a specific serial number suffix&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;Test failed with error: {str(e)}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 50)&#10;    print(&quot;Test completed!&quot;)&#10;&#10;async def test_robot_search_by_serial():&#10;    &quot;&quot;&quot;Test searching robot by serial number&quot;&quot;&quot;&#10;    print(&quot;\nTesting robot search by serial number...&quot;)&#10;&#10;    # You can change this to your robot's serial suffix&#10;    serial_suffix = &quot;000341&quot;  # Last 6 digits of your robot's serial&#10;&#10;    device = await robot_service.search_robot_by_serial(serial_suffix, timeout=10)&#10;&#10;    if device:&#10;        print(f&quot;Found robot with serial suffix '{serial_suffix}':&quot;)&#10;        print(f&quot;   Name: {device.name}&quot;)&#10;        print(f&quot;   IP: {device.ip}&quot;)&#10;        print(f&quot;   Port: {device.port}&quot;)&#10;        return device&#10;    else:&#10;        print(f&quot;No robot found with serial suffix: {serial_suffix}&quot;)&#10;        return None&#10;&#10;async def interactive_test():&#10;    &quot;&quot;&quot;Interactive test mode&quot;&quot;&quot;&#10;    print(&quot;Interactive Robot Test Mode&quot;)&#10;    print(&quot;=&quot; * 40)&#10;&#10;    while True:&#10;        print(&quot;\nOptions:&quot;)&#10;        print(&quot;1. Search all robots&quot;)&#10;        print(&quot;2. Search robot by serial&quot;)&#10;        print(&quot;3. Connect to robot&quot;)&#10;        print(&quot;4. Test dance command&quot;)&#10;        print(&quot;5. Test arm movement&quot;)&#10;        print(&quot;6. Disconnect robot&quot;)&#10;        print(&quot;7. Exit&quot;)&#10;&#10;        choice = input(&quot;\nSelect option (1-7): &quot;).strip()&#10;&#10;        try:&#10;            if choice == &quot;1&quot;:&#10;                await robot_service.search_all_robots()&#10;&#10;            elif choice == &quot;2&quot;:&#10;                serial = input(&quot;Enter robot serial suffix: &quot;).strip()&#10;                await robot_service.search_robot_by_serial(serial)&#10;&#10;            elif choice == &quot;3&quot;:&#10;                if not robot_service.is_connected:&#10;                    devices = await robot_service.search_all_robots()&#10;                    if devices:&#10;                        await robot_service.connect_robot(devices[0])&#10;                    else:&#10;                        print(&quot;No robots found to connect to&quot;)&#10;                else:&#10;                    print(&quot;Already connected to a robot&quot;)&#10;&#10;            elif choice == &quot;4&quot;:&#10;                if robot_service.is_connected:&#10;                    from app.models.schemas import RobotAction&#10;                    await robot_service.execute_robot_action(&#10;                        RobotAction.DANCE,&#10;                        {&quot;intensity&quot;: 0.7},&#10;                        3.0&#10;                    )&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;5&quot;:&#10;                if robot_service.is_connected:&#10;                    from app.models.schemas import RobotAction&#10;                    await robot_service.execute_robot_action(&#10;                        RobotAction.ARM_MOVEMENT,&#10;                        {&quot;amplitude&quot;: 0.8, &quot;both_arms&quot;: True},&#10;                        2.0&#10;                    )&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;6&quot;:&#10;                if robot_service.is_connected:&#10;                    await robot_service.disconnect_robot()&#10;                else:&#10;                    print(&quot;No robot connected&quot;)&#10;&#10;            elif choice == &quot;7&quot;:&#10;                print(&quot;Exiting...&quot;)&#10;                if robot_service.is_connected:&#10;                    await robot_service.disconnect_robot()&#10;                break&#10;&#10;            else:&#10;                print(&quot;Invalid option&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error: {str(e)}&quot;)&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot;Select test mode:&quot;)&#10;    print(&quot;1. Automatic test&quot;)&#10;    print(&quot;2. Interactive test&quot;)&#10;&#10;    mode = input(&quot;Enter choice (1 or 2): &quot;).strip()&#10;&#10;    if mode == &quot;1&quot;:&#10;        await test_robot_connection()&#10;    elif mode == &quot;2&quot;:&#10;        await interactive_test()&#10;    else:&#10;        print(&quot;Invalid choice, running automatic test...&quot;)&#10;        await test_robot_connection()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_robot_speaker_music.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_robot_speaker_music.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test robot playing music from its own speakers and dancing synchronously&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_robot_speaker_music_dance():&#10;    &quot;&quot;&quot;Test robot playing music from its speakers and dancing to analyzed music&quot;&quot;&quot;&#10;    print(&quot; Robot Speaker Music Dance Test&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    print(&quot;This test will:&quot;)&#10;    print(&quot;   Play music from ROBOT speakers (not computer)&quot;)&#10;    print(&quot;   Dance to the analyzed music beats&quot;)&#10;    print(&quot;   Robot will announce the performance&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;1. Searching and connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;        &#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected!&quot;)&#10;        &#10;        # Step 2: Find music file&#10;        print(&quot;\n2. Looking for music files...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;        &#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        print(f&quot;   Found: {music_file}&quot;)&#10;        &#10;        # Step 3: Test robot audio capabilities&#10;        print(&quot;\n3. Testing robot audio capabilities...&quot;)&#10;        print(&quot;   Testing TTS (text-to-speech)...&quot;)&#10;        &#10;        # Test basic TTS first&#10;        from mini.apis.api_sound import StartPlayTTS&#10;        test_tts = StartPlayTTS(text=&quot;Xin chào! Tôi đang test âm thanh. Bạn có nghe thấy tôi không?&quot;)&#10;        await test_tts.execute()&#10;        await asyncio.sleep(3)&#10;        print(&quot;   ✅ TTS test completed&quot;)&#10;        &#10;        # Step 4: Execute complete robot speaker performance&#10;        print(f&quot;\n4. Starting COMPLETE robot speaker performance...&quot;)&#10;        print(&quot;    Robot will announce the song&quot;)&#10;        print(&quot;    Robot will play music from its speakers&quot;)&#10;        print(&quot;    Robot will dance to analyzed beats&quot;)&#10;        print(&quot;   ⏱️  Performance duration: ~45 seconds&quot;)&#10;        print(&quot;\n   Starting in 3 seconds...&quot;)&#10;        await asyncio.sleep(3)&#10;        &#10;        success = await robot_service.execute_full_robot_speaker_performance(music_path)&#10;        &#10;        if success:&#10;            print(&quot; Complete robot speaker performance successful!&quot;)&#10;            print(&quot;   ✅ Music played from robot speakers&quot;)&#10;            print(&quot;   ✅ Robot danced to analyzed beats&quot;)&#10;            print(&quot;   ✅ Synchronized performance completed&quot;)&#10;        else:&#10;            print(&quot;❌ Performance failed&quot;)&#10;            &#10;        # Step 5: Cleanup&#10;        print(&quot;\n5. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;        &#10;        return success&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_simple_robot_audio():&#10;    &quot;&quot;&quot;Simple test to check if robot can play audio&quot;&quot;&quot;&#10;    print(&quot;\n Simple Robot Audio Test&quot;)&#10;    print(&quot;=&quot; * 40)&#10;    &#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected&quot;)&#10;        &#10;        # Test basic audio functionality&#10;        print(&quot;\n Testing basic audio:&quot;)&#10;        print(&quot;   1. Testing TTS...&quot;)&#10;        &#10;        from mini.apis.api_sound import StartPlayTTS&#10;        tts1 = StartPlayTTS(text=&quot;Xin chào! Đây là test âm thanh số 1.&quot;)&#10;        await tts1.execute()&#10;        await asyncio.sleep(3)&#10;        &#10;        print(&quot;   2. Testing music file playback...&quot;)&#10;        &#10;        # Find a music file&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;        &#10;        if music_files:&#10;            music_path = os.path.join(music_dir, music_files[0])&#10;            print(f&quot;      Trying to play: {music_files[0]}&quot;)&#10;            &#10;            # Test robot music playback&#10;            music_success = await robot_service._play_music_on_robot(music_path)&#10;            if music_success:&#10;                print(&quot;      ✅ Music started on robot speakers&quot;)&#10;                await asyncio.sleep(5)  # Play for 5 seconds&#10;                await robot_service._stop_music_on_robot()&#10;                print(&quot;      ✅ Music stopped&quot;)&#10;            else:&#10;                print(&quot;      ❌ Failed to play music on robot&quot;)&#10;        else:&#10;            print(&quot;      ❌ No music files found&quot;)&#10;            &#10;        # Final TTS&#10;        print(&quot;   3. Final TTS test...&quot;)&#10;        tts2 = StartPlayTTS(text=&quot;Test hoàn tất! Cảm ơn bạn đã nghe.&quot;)&#10;        await tts2.execute()&#10;        await asyncio.sleep(3)&#10;        &#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Simple audio test completed&quot;)&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in audio test: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini Robot Speaker Music System Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    choice = input(&quot;\nSelect test mode:\n1. Simple robot audio test\n2. Complete robot speaker music dance\n3. Both tests\nEnter choice (1, 2, or 3): &quot;)&#10;    &#10;    if choice == &quot;1&quot;:&#10;        await test_simple_robot_audio()&#10;    elif choice == &quot;2&quot;:&#10;        await test_robot_speaker_music_dance()&#10;    elif choice == &quot;3&quot;:&#10;        await test_simple_robot_audio()&#10;        print(&quot;\n&quot; + &quot;=&quot;*60)&#10;        input(&quot;Press Enter to continue to full performance test...&quot;)&#10;        await test_robot_speaker_music_dance()&#10;    else:&#10;        print(&quot;Invalid choice&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_robot_tts_rhythmic_dance.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_robot_tts_rhythmic_dance.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Test robot TTS + rhythmic dance performance based on analyzed music&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_robot_tts_rhythmic_dance():&#10;    &quot;&quot;&quot;Test robot performing TTS announcements + rhythmic dance based on music analysis&quot;&quot;&quot;&#10;    print(&quot; Robot TTS + Rhythmic Dance Test&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    print(&quot;This test will:&quot;)&#10;    print(&quot;   Analyze your imported music file&quot;)&#10;    print(&quot;   Robot will speak analysis results (BPM, etc.)&quot;)&#10;    print(&quot;   Robot will dance to the analyzed rhythm&quot;)&#10;    print(&quot;   Robot will count beats and announce dance phrases&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;1. Searching and connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;        &#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected!&quot;)&#10;        &#10;        # Step 2: Find music file&#10;        print(&quot;\n2. Looking for music files...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;        &#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        clean_name = music_file.replace(&quot;BẠC PHẬN - ICM x JACK - OFFICIAL MV (online-audio-converter.com) (2)&quot;, &quot;BẠC PHẬN&quot;)&#10;        print(f&quot;   Found: {clean_name}&quot;)&#10;        &#10;        # Step 3: Execute TTS + Rhythmic Dance Performance&#10;        print(f&quot;\n3. Starting TTS + Rhythmic Dance Performance...&quot;)&#10;        print(&quot;    Robot will speak Vietnamese analysis&quot;)&#10;        print(&quot;    Robot will analyze music rhythm&quot;)&#10;        print(&quot;    Robot will dance to analyzed beats&quot;)&#10;        print(&quot;    Robot will count dance phrases&quot;)&#10;        print(&quot;   ⏱️  Performance duration: ~30 seconds + announcements&quot;)&#10;        print(&quot;\n   Starting performance...&quot;)&#10;        &#10;        success = await robot_service.execute_full_robot_speaker_performance_v2(music_path)&#10;        &#10;        if success:&#10;            print(&quot; TTS + Rhythmic Dance Performance successful!&quot;)&#10;            print(&quot;   ✅ Music analyzed and announced&quot;)&#10;            print(&quot;   ✅ Robot danced to analyzed rhythm&quot;)&#10;            print(&quot;   ✅ Beat counting and phrase announcements&quot;)&#10;            print(&quot;   ✅ Vietnamese TTS from robot speakers&quot;)&#10;        else:&#10;            print(&quot;❌ Performance failed&quot;)&#10;            &#10;        # Step 4: Cleanup&#10;        print(&quot;\n4. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;        &#10;        return success&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_simple_robot_tts():&#10;    &quot;&quot;&quot;Simple test for robot TTS capabilities&quot;&quot;&quot;&#10;    print(&quot;\n Simple Robot TTS Test&quot;)&#10;    print(&quot;=&quot; * 40)&#10;    &#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected&quot;)&#10;        &#10;        # Test Vietnamese TTS&#10;        print(&quot;\n Testing Vietnamese TTS:&quot;)&#10;        &#10;        from mini.apis.api_sound import StartPlayTTS&#10;        &#10;        # Test 1: Introduction&#10;        print(&quot;   1. Introduction...&quot;)&#10;        tts1 = StartPlayTTS(text=&quot;Xin chào! Tôi là Alpha Mini. Tôi có thể nói tiếng Việt và nhảy múa.&quot;)&#10;        await tts1.execute()&#10;        await asyncio.sleep(4)&#10;        &#10;        # Test 2: Music analysis announcement&#10;        print(&quot;   2. Music analysis announcement...&quot;)&#10;        tts2 = StartPlayTTS(text=&quot;Tôi sẽ phân tích bài nhạc của bạn. Nhịp độ 120 BPM. Bắt đầu nhảy!&quot;)&#10;        await tts2.execute()&#10;        await asyncio.sleep(4)&#10;        &#10;        # Test 3: Beat counting&#10;        print(&quot;   3. Beat counting...&quot;)&#10;        tts3 = StartPlayTTS(text=&quot;Một, hai, ba, bốn! Cụm một! Một, hai, ba, bốn! Cụm hai!&quot;)&#10;        await tts3.execute()&#10;        await asyncio.sleep(5)&#10;        &#10;        # Test 4: Final thanks&#10;        print(&quot;   4. Final thanks...&quot;)&#10;        tts4 = StartPlayTTS(text=&quot;Kết thúc! Cảm ơn các bạn đã xem. Tôi nhảy có đẹp không?&quot;)&#10;        await tts4.execute()&#10;        await asyncio.sleep(4)&#10;        &#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ TTS test completed&quot;)&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in TTS test: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def test_robot_dance_movements():&#10;    &quot;&quot;&quot;Test robot dance movements without music&quot;&quot;&quot;&#10;    print(&quot;\n Robot Dance Movements Test&quot;)&#10;    print(&quot;=&quot; * 40)&#10;    &#10;    try:&#10;        # Connect to robot&#10;        devices = await robot_service.search_all_robots(timeout=5)&#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected&quot;)&#10;        &#10;        # Test dance movements&#10;        print(&quot;\n Testing dance movements:&quot;)&#10;        &#10;        # Announce test&#10;        from mini.apis.api_sound import StartPlayTTS&#10;        announce_tts = StartPlayTTS(text=&quot;Bây giờ tôi sẽ test các động tác nhảy!&quot;)&#10;        await announce_tts.execute()&#10;        await asyncio.sleep(3)&#10;        &#10;        dance_movements = [&#10;            (&quot;random_short3&quot;, &quot;Wave left hand&quot;, &quot;Vẫy tay trái!&quot;),&#10;            (&quot;random_short4&quot;, &quot;Wave right hand&quot;, &quot;Vẫy tay phải!&quot;),&#10;            (&quot;015&quot;, &quot;Welcome gesture&quot;, &quot;Chào mừng!&quot;),&#10;            (&quot;action_005&quot;, &quot;Thumbs up&quot;, &quot;Thích!&quot;),&#10;        ]&#10;        &#10;        for action_id, description, vietnamese_text in dance_movements:&#10;            print(f&quot;   Testing: {description}&quot;)&#10;            &#10;            # Announce movement in Vietnamese&#10;            movement_tts = StartPlayTTS(text=vietnamese_text)&#10;            await movement_tts.execute()&#10;            await asyncio.sleep(1.5)&#10;            &#10;            # Do movement&#10;            success = await robot_service._start_behavior(action_id)&#10;            if success:&#10;                await asyncio.sleep(2.5)&#10;                await robot_service._stop_current_behavior()&#10;                print(f&quot;   ✅ {description} - Success&quot;)&#10;            else:&#10;                print(f&quot;   ❌ {description} - Failed&quot;)&#10;            &#10;            await asyncio.sleep(0.5)&#10;        &#10;        # Final bow&#10;        final_tts = StartPlayTTS(text=&quot;Test hoàn tất! Cảm ơn các bạn!&quot;)&#10;        await final_tts.execute()&#10;        await asyncio.sleep(3)&#10;        &#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Dance movements test completed&quot;)&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error in dance test: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;async def main():&#10;    &quot;&quot;&quot;Main test function&quot;&quot;&quot;&#10;    print(&quot; Alpha Mini TTS + Rhythmic Dance System Test&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    print(&quot;Test Options:&quot;)&#10;    print(&quot;1. Simple TTS test&quot;)&#10;    print(&quot;2. Dance movements test&quot;)  &#10;    print(&quot;3. Full TTS + Rhythmic Dance (with music analysis)&quot;)&#10;    print(&quot;4. All tests&quot;)&#10;    &#10;    choice = input(&quot;\nEnter choice (1, 2, 3, or 4): &quot;)&#10;    &#10;    if choice == &quot;1&quot;:&#10;        await test_simple_robot_tts()&#10;    elif choice == &quot;2&quot;:&#10;        await test_robot_dance_movements()&#10;    elif choice == &quot;3&quot;:&#10;        await test_robot_tts_rhythmic_dance()&#10;    elif choice == &quot;4&quot;:&#10;        print(&quot;Running all tests...&quot;)&#10;        await test_simple_robot_tts()&#10;        print(&quot;\n&quot; + &quot;=&quot;*60)&#10;        input(&quot;Press Enter to continue to dance test...&quot;)&#10;        await test_robot_dance_movements()&#10;        print(&quot;\n&quot; + &quot;=&quot;*60)&#10;        input(&quot;Press Enter to continue to full performance...&quot;)&#10;        await test_robot_tts_rhythmic_dance()&#10;    else:&#10;        print(&quot;Invalid choice&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_simple_music_dance.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_simple_music_dance.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Simple test for robot dancing with user's music&#10;&quot;&quot;&quot;&#10;import asyncio&#10;import os&#10;from app.services.alpha_mini_robot import robot_service&#10;&#10;async def test_simple_music_dance():&#10;    &quot;&quot;&quot;Test robot dancing to user's music with confirmed working actions only&quot;&quot;&quot;&#10;    print(&quot; Simple Music Dance Test&quot;)&#10;    print(&quot;=&quot; * 40)&#10;    &#10;    try:&#10;        # Step 1: Connect to robot&#10;        print(&quot;1. Searching and connecting to robot...&quot;)&#10;        devices = await robot_service.search_all_robots(timeout=8)&#10;        &#10;        if not devices:&#10;            device = await robot_service.search_robot_by_serial(&quot;000341&quot;, timeout=5)&#10;            if device:&#10;                devices = [device]&#10;        &#10;        if not devices:&#10;            print(&quot;❌ No robots found&quot;)&#10;            return False&#10;            &#10;        connected = await robot_service.connect_robot(devices[0])&#10;        if not connected:&#10;            print(&quot;❌ Failed to connect&quot;)&#10;            return False&#10;            &#10;        print(&quot;✅ Robot connected!&quot;)&#10;        &#10;        # Step 2: Test confirmed working actions&#10;        print(&quot;\n2. Testing confirmed working actions...&quot;)&#10;        &#10;        # Test wave hands (confirmed working)&#10;        print(&quot;   Testing wave left hand...&quot;)&#10;        success1 = await robot_service._start_behavior(&quot;random_short3&quot;)&#10;        if success1:&#10;            await asyncio.sleep(2)&#10;            await robot_service._stop_current_behavior()&#10;            print(&quot;   ✅ Wave left hand works!&quot;)&#10;        else:&#10;            print(&quot;   ❌ Wave left hand failed&quot;)&#10;            &#10;        await asyncio.sleep(0.5)&#10;        &#10;        # Test wave right hand&#10;        print(&quot;   Testing wave right hand...&quot;)&#10;        success2 = await robot_service._start_behavior(&quot;random_short4&quot;)&#10;        if success2:&#10;            await asyncio.sleep(2)&#10;            await robot_service._stop_current_behavior()&#10;            print(&quot;   ✅ Wave right hand works!&quot;)&#10;        else:&#10;            print(&quot;   ❌ Wave right hand failed&quot;)&#10;        &#10;        # Step 3: Find music file&#10;        print(&quot;\n3. Looking for music files...&quot;)&#10;        music_dir = &quot;uploads/music&quot;&#10;        music_files = [f for f in os.listdir(music_dir) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]&#10;        &#10;        if not music_files:&#10;            print(&quot;❌ No music files found in uploads/music/&quot;)&#10;            await robot_service.disconnect_robot()&#10;            return False&#10;            &#10;        music_file = music_files[0]&#10;        music_path = os.path.join(music_dir, music_file)&#10;        print(f&quot;   Found: {music_file}&quot;)&#10;        &#10;        # Step 4: Simple dance with music&#10;        print(f&quot;\n4. Starting simple dance with music...&quot;)&#10;        print(&quot;    Music will play from computer speakers&quot;)&#10;        print(&quot;    Robot will do simple movements (no built-in dance music)&quot;)&#10;        print(&quot;   ⏱️  Demo duration: 15 seconds&quot;)&#10;        &#10;        # Start music playback&#10;        music_task = asyncio.create_task(robot_service.audio_player.play_audio_file(music_path))&#10;        await asyncio.sleep(0.5)  # Let music start&#10;        &#10;        # Do simple dance sequence with confirmed actions&#10;        dance_actions = [&#10;            (&quot;random_short3&quot;, &quot;Wave left hand&quot;, 2.0),&#10;            (&quot;random_short4&quot;, &quot;Wave right hand&quot;, 2.0),&#10;            (&quot;random_short3&quot;, &quot;Wave left hand&quot;, 2.0),&#10;            (&quot;random_short4&quot;, &quot;Wave right hand&quot;, 2.0),&#10;        ]&#10;        &#10;        print(&quot;    Starting dance sequence...&quot;)&#10;        &#10;        for action_id, description, duration in dance_actions:&#10;            print(f&quot;      {description}...&quot;)&#10;            success = await robot_service._start_behavior(action_id)&#10;            if success:&#10;                await asyncio.sleep(duration)&#10;                await robot_service._stop_current_behavior()&#10;            await asyncio.sleep(0.2)  # Brief pause between actions&#10;        &#10;        # Add some expressions&#10;        print(&quot;      Adding expressions...&quot;)&#10;        await robot_service._play_expression(&quot;codemao1&quot;)  # Looking around&#10;        await asyncio.sleep(1.5)&#10;        await robot_service._play_expression(&quot;codemao10&quot;)  # Exciting&#10;        await asyncio.sleep(1.5)&#10;        &#10;        # Final wave&#10;        print(&quot;      Final wave...&quot;)&#10;        await robot_service._start_behavior(&quot;random_short3&quot;)&#10;        await asyncio.sleep(2)&#10;        await robot_service._stop_current_behavior()&#10;        &#10;        print(&quot; Simple dance completed!&quot;)&#10;        &#10;        # Step 5: Cleanup&#10;        print(&quot;\n5. Disconnecting robot...&quot;)&#10;        await robot_service.disconnect_robot()&#10;        print(&quot;✅ Robot disconnected&quot;)&#10;        &#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        try:&#10;            await robot_service.disconnect_robot()&#10;        except:&#10;            pass&#10;        return False&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(test_simple_music_dance())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>