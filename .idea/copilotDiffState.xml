<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/services/socket/connection_manager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/socket/connection_manager.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;WebSocket Connection Manager&#10;Quản lý kết nối WebSocket với các robot, hỗ trợ nhiều loại kết nối&#10;&quot;&quot;&quot;&#10;from fastapi import WebSocket&#10;from typing import Dict, List&#10;import logging&#10;&#10;&#10;class WSMapEntry:&#10;    websocket: WebSocket&#10;    client_id: str&#10;&#10;    def __init__(self, websocket: WebSocket, client_id: str):&#10;        self.websocket = websocket&#10;        self.client_id = client_id&#10;&#10;&#10;class ConnectionManager:&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot và signaling&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Store clients as {serial: {client_type: WSMapEntry}}&#10;        self.clients: Dict[str, Dict[str, WSMapEntry]] = {}&#10;        self.logger = logging.getLogger(__name__)&#10;&#10;    async def connect(self, websocket: WebSocket, serial: str, client_type: str = &quot;robot&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Kết nối WebSocket với robot hoặc signaling&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#10;        &quot;&quot;&quot;&#10;        await websocket.accept()&#10;        if serial not in self.clients:&#10;            self.clients[serial] = {}&#10;        # Nếu cùng client_type đã tồn tại, disconnect cũ&#10;        if client_type in self.clients[serial]:&#10;            try:&#10;                old_ws = self.clients[serial][client_type].websocket&#10;                if old_ws.client_state.name != &quot;DISCONNECTED&quot;:&#10;                    await old_ws.close(reason=f&quot;New {client_type} connection established&quot;)&#10;            except Exception as e:&#10;                self.logger.warning(f&quot;Error closing old {client_type} websocket for {serial}: {e}&quot;)&#10;&#10;        self.clients[serial][client_type] = WSMapEntry(websocket, websocket.headers.get(&quot;client_id&quot;))&#10;        self.logger.info(f&quot;{client_type} connected for serial {serial}. Total client types: {list(self.clients[serial].keys())}&quot;)&#10;        return True&#10;&#10;    async def disconnect(self, serial: str, client_type: str = None):&#10;        &quot;&quot;&quot;&#10;        Ngắt kết nối robot hoặc signaling&#10;        Nếu client_type=None sẽ ngắt tất cả kết nối của serial&#10;        &quot;&quot;&quot;&#10;        if serial not in self.clients:&#10;            self.logger.warning(f&quot;Attempted to disconnect {serial} but it was not connected&quot;)&#10;            return&#10;&#10;        types_to_disconnect = [client_type] if client_type else list(self.clients[serial].keys())&#10;        for ctype in types_to_disconnect:&#10;            ws_entry = self.clients[serial].get(ctype)&#10;            if ws_entry:&#10;                try:&#10;                    if ws_entry.websocket.client_state.name != &quot;DISCONNECTED&quot;:&#10;                        await ws_entry.websocket.close()&#10;                except Exception as e:&#10;                    self.logger.warning(f&quot;Error disconnecting {ctype} websocket for {serial}: {e}&quot;)&#10;                del self.clients[serial][ctype]&#10;&#10;        # Nếu không còn loại nào, remove serial&#10;        if not self.clients[serial]:&#10;            del self.clients[serial]&#10;&#10;    async def send_to_robot(self, serial: str, message: str, client_type: str = &quot;robot&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới robot hoặc signaling theo client_type&quot;&quot;&quot;&#10;        if serial not in self.clients or client_type not in self.clients[serial]:&#10;            self.logger.warning(f&quot;Cannot send message: {serial} [{client_type}] not connected&quot;)&#10;            return False&#10;&#10;        ws_entry = self.clients[serial][client_type]&#10;        try:&#10;            if ws_entry.websocket.client_state.name == &quot;CONNECTED&quot;:&#10;                await ws_entry.websocket.send_text(message)&#10;                return True&#10;            else:&#10;                self.logger.warning(f&quot;Cannot send message: {serial} [{client_type}] websocket not connected&quot;)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Send error to {serial} [{client_type}]: {e}&quot;)&#10;            await self.disconnect(serial, client_type)&#10;        return False&#10;&#10;    @property&#10;    def active(self) -&gt; int:&#10;        &quot;&quot;&quot;Số lượng serial đang có ít nhất 1 kết nối&quot;&quot;&quot;&#10;        return len(self.clients)&#10;&#10;    def is_connected(self, serial: str, client_type: str = None) -&gt; bool:&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#10;        if serial not in self.clients:&#10;            return False&#10;        if client_type:&#10;            return client_type in self.clients[serial]&#10;        return True&#10;&#10;    def get_connected_serials(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#10;        return list(self.clients.keys())&#10;&#10;    def get_client_types(self, serial: str) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các loại kết nối cho serial&quot;&quot;&quot;&#10;        if serial in self.clients:&#10;            return list(self.clients[serial].keys())&#10;        return []&#10;&#10;&#10;# Tạo instance global&#10;connection_manager = ConnectionManager()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;WebSocket Connection Manager&#10;Quản lý kết nối WebSocket với các robot, hỗ trợ nhiều loại kết nối&#10;&quot;&quot;&quot;&#10;from fastapi import WebSocket&#10;from typing import Dict, List&#10;import logging&#10;&#10;&#10;class WSMapEntry:&#10;    websocket: WebSocket&#10;    client_id: str&#10;&#10;    def __init__(self, websocket: WebSocket, client_id: str):&#10;        self.websocket = websocket&#10;        self.client_id = client_id&#10;&#10;&#10;class ConnectionManager:&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot và signaling&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Store clients as {serial: {client_type: WSMapEntry}}&#10;        self.clients: Dict[str, Dict[str, WSMapEntry]] = {}&#10;        self.logger = logging.getLogger(__name__)&#10;&#10;    async def connect(self, websocket: WebSocket, serial: str, client_type: str = &quot;robot&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Kết nối WebSocket với robot hoặc signaling&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Validate client_type&#10;            if client_type not in [&quot;robot&quot;, &quot;web&quot;]:&#10;                self.logger.warning(f&quot;Invalid client_type: {client_type}&quot;)&#10;                return False&#10;            &#10;            # Validate serial&#10;            if not serial or len(serial.strip()) == 0:&#10;                self.logger.warning(f&quot;Invalid serial: {serial}&quot;)&#10;                return False&#10;            &#10;            await websocket.accept()&#10;            &#10;            if serial not in self.clients:&#10;                self.clients[serial] = {}&#10;            &#10;            # Nếu cùng client_type đã tồn tại, disconnect cũ&#10;            if client_type in self.clients[serial]:&#10;                try:&#10;                    old_ws = self.clients[serial][client_type].websocket&#10;                    if old_ws.client_state.name != &quot;DISCONNECTED&quot;:&#10;                        await old_ws.close(reason=f&quot;New {client_type} connection established&quot;)&#10;                except Exception as e:&#10;                    self.logger.warning(f&quot;Error closing old {client_type} websocket for {serial}: {e}&quot;)&#10;&#10;            self.clients[serial][client_type] = WSMapEntry(websocket, websocket.headers.get(&quot;client_id&quot;))&#10;            self.logger.info(f&quot;{client_type} connected for serial {serial}. Total client types: {list(self.clients[serial].keys())}&quot;)&#10;            return True&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to connect {client_type} for serial {serial}: {e}&quot;)&#10;            try:&#10;                await websocket.close(code=1008, reason=f&quot;Connection failed: {str(e)}&quot;)&#10;            except:&#10;                pass&#10;            return False&#10;&#10;    async def disconnect(self, serial: str, client_type: str = None):&#10;        &quot;&quot;&quot;&#10;        Ngắt kết nối robot hoặc signaling&#10;        Nếu client_type=None sẽ ngắt tất cả kết nối của serial&#10;        &quot;&quot;&quot;&#10;        if serial not in self.clients:&#10;            self.logger.warning(f&quot;Attempted to disconnect {serial} but it was not connected&quot;)&#10;            return&#10;&#10;        types_to_disconnect = [client_type] if client_type else list(self.clients[serial].keys())&#10;        for ctype in types_to_disconnect:&#10;            ws_entry = self.clients[serial].get(ctype)&#10;            if ws_entry:&#10;                try:&#10;                    if ws_entry.websocket.client_state.name != &quot;DISCONNECTED&quot;:&#10;                        await ws_entry.websocket.close()&#10;                except Exception as e:&#10;                    self.logger.warning(f&quot;Error disconnecting {ctype} websocket for {serial}: {e}&quot;)&#10;                del self.clients[serial][ctype]&#10;&#10;        # Nếu không còn loại nào, remove serial&#10;        if not self.clients[serial]:&#10;            del self.clients[serial]&#10;&#10;    async def send_to_robot(self, serial: str, message: str, client_type: str = &quot;robot&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới robot hoặc signaling theo client_type&quot;&quot;&quot;&#10;        if serial not in self.clients or client_type not in self.clients[serial]:&#10;            self.logger.warning(f&quot;Cannot send message: {serial} [{client_type}] not connected&quot;)&#10;            return False&#10;&#10;        ws_entry = self.clients[serial][client_type]&#10;        try:&#10;            if ws_entry.websocket.client_state.name == &quot;CONNECTED&quot;:&#10;                await ws_entry.websocket.send_text(message)&#10;                return True&#10;            else:&#10;                self.logger.warning(f&quot;Cannot send message: {serial} [{client_type}] websocket not connected&quot;)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Send error to {serial} [{client_type}]: {e}&quot;)&#10;            await self.disconnect(serial, client_type)&#10;        return False&#10;&#10;    async def send_to_client(self, serial: str, message: str, client_type: str = &quot;robot&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới client theo loại (robot hoặc web)&quot;&quot;&quot;&#10;        return await self.send_to_robot(serial, message, client_type)&#10;&#10;    @property&#10;    def active(self) -&gt; int:&#10;        &quot;&quot;&quot;Số lượng serial đang có ít nhất 1 kết nối&quot;&quot;&quot;&#10;        return len(self.clients)&#10;&#10;    def is_connected(self, serial: str, client_type: str = None) -&gt; bool:&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#10;        if serial not in self.clients:&#10;            return False&#10;        if client_type:&#10;            return client_type in self.clients[serial]&#10;        return True&#10;&#10;    def get_connected_serials(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#10;        return list(self.clients.keys())&#10;&#10;    def get_client_types(self, serial: str) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các loại kết nối cho serial&quot;&quot;&quot;&#10;        if serial in self.clients:&#10;            return list(self.clients[serial].keys())&#10;        return []&#10;&#10;&#10;# Tạo instance global&#10;connection_manager = ConnectionManager()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>