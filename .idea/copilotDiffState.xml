<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/services/socket/connection_manager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/socket/connection_manager.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;WebSocket Connection Manager&#10;Quản lý kết nối WebSocket với các robot&#10;&quot;&quot;&quot;&#10;from fastapi import WebSocket&#10;from typing import Dict, List&#10;import logging&#10;&#10;&#10;class WSMapEntry:&#10;    websocket: WebSocket&#10;    client_id: str&#10;    def __init__(self, websocket, client_id):&#10;        self.client_id = client_id&#10;        self.websocket = websocket&#10;    &#10;class ConnectionManager:&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        # Store clients as {serial: websocket}&#10;        self.clients: Dict[str, WSMapEntry] = {}&#10;        self.logger = logging.getLogger(__name__)&#10;    &#10;    async def connect(self, websocket: WebSocket, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Kết nối WebSocket với robot&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#10;        &quot;&quot;&quot;&#10;        # if websocket.headers.get('client_id') is None:&#10;        #     await websocket.close(code=1008, reason=&quot;Socket has no client id&quot;)&#10;        #     return False&#10;        &#10;        # Kiểm tra nếu serial đã tồn tại&#10;        # if serial in self.clients:&#10;        #     try:&#10;        #         # Nếu không có lỗi, kết nối vẫn active&#10;        #         print(f&quot;Từ chối kết nối từ robot {serial}, đã có kết nối active&quot;)&#10;        #&#10;        #         # Thông báo cho client lý do từ chối&#10;        #         try:&#10;        #             await websocket.close(code=1008, reason=&quot;Robot with this serial is already connected&quot;)&#10;        #         except Exception as e:&#10;        #             self.logger.error(f&quot;Lỗi khi từ chối kết nối: {e}&quot;)&#10;        #         return False&#10;        #&#10;        #     except Exception as e:&#10;        #         # Nếu có lỗi, kết nối cũ đã bị ngắt nhưng chưa được dọn dẹp&#10;        #         self.logger.info(f&quot;Cleaning up stale connection for {serial}: {e}&quot;)&#10;        #         await self.disconnect(serial)&#10;        # Nếu serial chưa tồn tại hoặc kết nối cũ đã bị ngắt, cho phép kết nối mới&#10;        await websocket.accept()&#10;        self.clients[serial] = WSMapEntry(websocket, websocket.headers.get('client_id'))&#10;        self.logger.info(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#10;        return True&#10;    &#10;    async def disconnect(self, serial: str):&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#10;        if serial in self.clients:&#10;            await self.clients[serial].websocket.close()&#10;            del self.clients[serial]&#10;        else:&#10;            self.logger.warning(f&quot;Attempted to disconnect robot {serial} but it was not connected&quot;)&#10;    &#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới robot&quot;&quot;&quot;&#10;        ws = self.clients.get(serial).websocket&#10;        if ws:&#10;            try:&#10;                await ws.send_text(message)&#10;                return True&#10;            except Exception as e:&#10;                self.logger.error(f&quot;Send error to {serial}: {e}&quot;)&#10;                await self.disconnect(serial)&#10;    @property&#10;    def active(self) -&gt; int:&#10;        &quot;&quot;&quot;Số lượng robot đang kết nối&quot;&quot;&quot;&#10;        return len(self.clients)&#10;    &#10;    def is_connected(self, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#10;        return serial in self.clients&#10;    &#10;    def get_connected_serials(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#10;        return list(self.clients.keys())&#10;&#10;&#10;# Tạo instance global&#10;connection_manager = ConnectionManager()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;WebSocket Connection Manager&#10;Quản lý kết nối WebSocket với các robot&#10;&quot;&quot;&quot;&#10;from fastapi import WebSocket&#10;from typing import Dict, List&#10;import logging&#10;&#10;&#10;class WSMapEntry:&#10;    websocket: WebSocket&#10;    client_id: str&#10;    def __init__(self, websocket, client_id):&#10;        self.client_id = client_id&#10;        self.websocket = websocket&#10;    &#10;class ConnectionManager:&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        # Store clients as {serial: websocket}&#10;        self.clients: Dict[str, WSMapEntry] = {}&#10;        self.logger = logging.getLogger(__name__)&#10;    &#10;    async def connect(self, websocket: WebSocket, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Kết nối WebSocket với robot&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#10;        &quot;&quot;&quot;&#10;        # if websocket.headers.get('client_id') is None:&#10;        #     await websocket.close(code=1008, reason=&quot;Socket has no client id&quot;)&#10;        #     return False&#10;        &#10;        # Kiểm tra nếu serial đã tồn tại&#10;        # if serial in self.clients:&#10;        #     try:&#10;        #         # Nếu không có lỗi, kết nối vẫn active&#10;        #         print(f&quot;Từ chối kết nối từ robot {serial}, đã có kết nối active&quot;)&#10;        #&#10;        #         # Thông báo cho client lý do từ chối&#10;        #         try:&#10;        #             await websocket.close(code=1008, reason=&quot;Robot with this serial is already connected&quot;)&#10;        #         except Exception as e:&#10;        #             self.logger.error(f&quot;Lỗi khi từ chối kết nối: {e}&quot;)&#10;        #         return False&#10;        #&#10;        #     except Exception as e:&#10;        #         # Nếu có lỗi, kết nối cũ đã bị ngắt nhưng chưa được dọn dẹp&#10;        #         self.logger.info(f&quot;Cleaning up stale connection for {serial}: {e}&quot;)&#10;        #         await self.disconnect(serial)&#10;        # Nếu serial chưa tồn tại hoặc kết nối cũ đã bị ngắt, cho phép kết nối mới&#10;        await websocket.accept()&#10;        self.clients[serial] = WSMapEntry(websocket, websocket.headers.get('client_id'))&#10;        self.logger.info(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#10;        return True&#10;    &#10;    async def disconnect(self, serial: str):&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#10;        if serial in self.clients:&#10;            ws = self.clients[serial].websocket&#10;            try:&#10;                if not ws.client_state.name == &quot;DISCONNECTED&quot;:&#10;                    await ws.close()&#10;            except RuntimeError as e:&#10;                self.logger.warning(f&quot;WebSocket for {serial} already closed: {e}&quot;)&#10;            except Exception as e:&#10;                self.logger.error(f&quot;Unexpected error closing WebSocket for {serial}: {e}&quot;)&#10;            del self.clients[serial]&#10;        else:&#10;            self.logger.warning(f&quot;Attempted to disconnect robot {serial} but it was not connected&quot;)&#10;&#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới robot&quot;&quot;&quot;&#10;        client = self.clients.get(serial)&#10;        if client and hasattr(client, 'websocket'):&#10;            ws = client.websocket&#10;            if ws:&#10;                try:&#10;                    if ws.client_state.name == &quot;CONNECTED&quot;:&#10;                        await ws.send_text(message)&#10;                        return True&#10;                    else:&#10;                        self.logger.warning(f&quot;Cannot send message to {serial}: websocket not connected&quot;)&#10;                except RuntimeError as e:&#10;                    self.logger.error(f&quot;Send error to {serial}: {e}&quot;)&#10;                    await self.disconnect(serial)&#10;                except Exception as e:&#10;                    self.logger.error(f&quot;Unexpected send error to {serial}: {e}&quot;)&#10;                    await self.disconnect(serial)&#10;            else:&#10;                self.logger.warning(f&quot;Cannot send message to {serial}: websocket not available&quot;)&#10;        else:&#10;            self.logger.warning(f&quot;Cannot send message to {serial}: robot not connected&quot;)&#10;        return False&#10;    &#10;    @property&#10;    def active(self) -&gt; int:&#10;        &quot;&quot;&quot;Số lượng robot đang kết nối&quot;&quot;&quot;&#10;        return len(self.clients)&#10;    &#10;    def is_connected(self, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#10;        return serial in self.clients&#10;    &#10;    def get_connected_serials(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#10;        return list(self.clients.keys())&#10;&#10;&#10;# Tạo instance global&#10;connection_manager = ConnectionManager()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>