<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/routers/websocket_router.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/routers/websocket_router.py" />
              <option name="originalContent" value="from fastapi import APIRouter, WebSocket, WebSocketDisconnect&#10;from fastapi.responses import JSONResponse&#10;from pydantic import BaseModel&#10;from typing import Dict&#10;&#10;router = APIRouter()&#10;&#10;class Command(BaseModel):&#10;    type: str&#10;    data: dict&#10;&#10;class ConnectionManager:&#10;    def __init__(self):&#10;        # Store clients as {serial: websocket}&#10;        self.clients: Dict[str, WebSocket] = {}&#10;&#10;    async def connect(self, websocket: WebSocket, serial: str):&#10;        await websocket.accept()&#10;        self.clients[serial] = websocket&#10;        print(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#10;&#10;    def disconnect(self, serial: str):&#10;        if serial in self.clients:&#10;            del self.clients[serial]&#10;            print(f&quot;Robot {serial} disconnected. Total: {len(self.clients)}&quot;)&#10;&#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#10;        ws = self.clients.get(serial)&#10;        if ws:&#10;            try:&#10;                await ws.send_text(message)&#10;                return True&#10;            except Exception as e:&#10;                print(f&quot;Send error to {serial}: {e}&quot;)&#10;                self.disconnect(serial)&#10;        return False&#10;&#10;    @property&#10;    def active(self) -&gt; int:&#10;        return len(self.clients)&#10;&#10;manager = ConnectionManager()&#10;&#10;# Robot connects here with serial number&#10;@router.websocket(&quot;/ws/{serial}&quot;)&#10;async def websocket_endpoint(websocket: WebSocket, serial: str):&#10;    try:&#10;        print(&quot;Incoming WS request:&quot;, websocket.url)&#10;        print(&quot;Parsed serial:&quot;, serial)&#10;        if not serial:&#10;            await websocket.close(code=1008)  # Policy Violation&#10;            return&#10;&#10;        await manager.connect(websocket, serial)&#10;        print(f&quot;Robot {serial} connected&quot;)&#10;&#10;        while True:&#10;            data = await websocket.receive_text()&#10;            print(f&quot;{serial} -&gt; {data}&quot;)&#10;&#10;    except WebSocketDisconnect:&#10;        print(f&quot;Robot {serial} disconnected&quot;)&#10;        manager.disconnect(serial)&#10;&#10;    except Exception as e:&#10;        print(f&quot;WebSocket error for {serial}: {e}&quot;)&#10;        manager.disconnect(serial)&#10;&#10;&#10;&#10;# Send a command to a specific robot&#10;@router.post(&quot;/command/{serial}&quot;)&#10;async def send_command(serial: str, command: Command):&#10;    # Use pydantic v2 model_dump_json / model_dump to avoid deprecation warnings&#10;    ok = await manager.send_to_robot(serial, command.model_dump_json())&#10;    return JSONResponse({&#10;        &quot;status&quot;: &quot;sent&quot; if ok else &quot;failed&quot;,&#10;        &quot;to&quot;: serial,&#10;        &quot;command&quot;: command.model_dump(),&#10;        &quot;active_clients&quot;: manager.active&#10;    })&#10;&#10;&#10;# New endpoint: trigger the action flow for a robot identified by serial tail&#10;from app.services.robot_sdk_control.action_service import run_actions_for_serial&#10;&#10;@router.post(&quot;/robot/actions/{serial}&quot;)&#10;async def trigger_robot_actions(serial: str):&#10;    &quot;&quot;&quot;Connect to robot by serial tail, run predefined actions, and return results.&#10;&#10;    The router is included under the /websocket prefix in main.py, so the full path is POST /websocket/robot/actions/{serial}&#10;    &quot;&quot;&quot;&#10;    result = await run_actions_for_serial(serial)&#10;    return JSONResponse(result)&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, WebSocket, WebSocketDisconnect&#10;from fastapi.responses import JSONResponse&#10;from pydantic import BaseModel&#10;from typing import Dict&#10;&#10;router = APIRouter()&#10;&#10;class Command(BaseModel):&#10;    type: str&#10;    data: dict&#10;&#10;class ConnectionManager:&#10;    def __init__(self):&#10;        # Store clients as {serial: websocket}&#10;        self.clients: Dict[str, WebSocket] = {}&#10;&#10;    async def connect(self, websocket: WebSocket, serial: str):&#10;        await websocket.accept()&#10;        self.clients[serial] = websocket&#10;        print(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#10;&#10;    def disconnect(self, serial: str):&#10;        if serial in self.clients:&#10;            del self.clients[serial]&#10;            print(f&quot;Robot {serial} disconnected. Total: {len(self.clients)}&quot;)&#10;&#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#10;        ws = self.clients.get(serial)&#10;        if ws:&#10;            try:&#10;                await ws.send_text(message)&#10;                return True&#10;            except Exception as e:&#10;                print(f&quot;Send error to {serial}: {e}&quot;)&#10;                self.disconnect(serial)&#10;        return False&#10;&#10;    @property&#10;    def active(self) -&gt; int:&#10;        return len(self.clients)&#10;&#10;manager = ConnectionManager()&#10;&#10;# Robot connects here with serial number&#10;@router.websocket(&quot;/ws/{serial}&quot;)&#10;async def websocket_endpoint(websocket: WebSocket, serial: str):&#10;    try:&#10;        print(&quot;Incoming WS request:&quot;, websocket.url)&#10;        print(&quot;Parsed serial:&quot;, serial)&#10;        if not serial:&#10;            await websocket.close(code=1008)  # Policy Violation&#10;            return&#10;&#10;        await manager.connect(websocket, serial)&#10;        print(f&quot;Robot {serial} connected&quot;)&#10;&#10;        while True:&#10;            data = await websocket.receive_text()&#10;            print(f&quot;{serial} -&gt; {data}&quot;)&#10;&#10;    except WebSocketDisconnect:&#10;        print(f&quot;Robot {serial} disconnected&quot;)&#10;        manager.disconnect(serial)&#10;&#10;    except Exception as e:&#10;        print(f&quot;WebSocket error for {serial}: {e}&quot;)&#10;        manager.disconnect(serial)&#10;&#10;&#10;&#10;# Send a command to a specific robot&#10;@router.post(&quot;/command/{serial}&quot;)&#10;async def send_command(serial: str, command: Command):&#10;    # Use pydantic v2 model_dump_json / model_dump to avoid deprecation warnings&#10;    ok = await manager.send_to_robot(serial, command.model_dump_json())&#10;    return JSONResponse({&#10;        &quot;status&quot;: &quot;sent&quot; if ok else &quot;failed&quot;,&#10;        &quot;to&quot;: serial,&#10;        &quot;command&quot;: command.model_dump(),&#10;        &quot;active_clients&quot;: manager.active&#10;    })&#10;&#10;&#10;# New endpoint: trigger the action flow for a robot identified by serial tail&#10;from app.services.robot_sdk_control.action_service import run_actions_for_serial&#10;&#10;@router.post(&quot;/robot/actions/{serial}&quot;)&#10;async def trigger_robot_actions(serial: str):&#10;    &quot;&quot;&quot;Connect to robot by serial tail, run predefined actions, and return results.&#10;&#10;    The router is included under the /websocket prefix in main.py, so the full path is POST /websocket/robot/actions/{serial}&#10;    &quot;&quot;&quot;&#10;    try:&#10;        result = await run_actions_for_serial(serial)&#10;        return JSONResponse(result)&#10;    except Exception as e:&#10;        # return exception details to caller to aid debugging (do not keep this in production)&#10;        return JSONResponse({&quot;error&quot;: str(e)})" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/robot_sdk_control/action_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/robot_sdk_control/action_service.py" />
              <option name="originalContent" value="import asyncio&#10;from typing import Any, Dict&#10;&#10;from mini.apis.api_action import GetActionList, GetActionListResponse, RobotActionType&#10;from mini.apis.api_action import MoveRobot, MoveRobotDirection, MoveRobotResponse&#10;from mini.apis.api_action import PlayAction, PlayActionResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;&#10;&#10;# 测试, 执行一个动作文件&#10;async def test_play_action() -&gt; PlayActionResponse:&#10;    &quot;&quot;&quot;Perform an action demo&#10;&#10;     Control the robot to execute a local (built-in/custom) action with a specified name and wait for the execution result to reply&#10;&#10;     Action name can be obtained with GetActionList&#10;&#10;     #PlayActionResponse.isSuccess: Is it successful&#10;&#10;     #PlayActionResponse.resultCode: Return code&#10;&#10;     &quot;&quot;&quot;&#10;    # action_name: Action file name, you can get the actions supported by the robot through GetActionList&#10;    block: PlayAction = PlayAction(action_name='action_013')&#10;    # response: PlayActionResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_play_action result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, PlayActionResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_play_action failed')&#10;&#10;    return response&#10;&#10;&#10;# 测试, 控制机器人,向前/后/左/右 移动&#10;async def test_move_robot() -&gt; MoveRobotResponse:&#10;    &quot;&quot;&quot;Control the robot mobile demo&#10;&#10;     Control the robot to move 10 steps to the left (LEFTWARD) and wait for the execution result&#10;&#10;     #MoveRobotResponse.isSuccess: Is it successful　&#10;&#10;     #MoveRobotResponse.code: Return code&#10;&#10;     &quot;&quot;&quot;&#10;    # step: Move a few steps&#10;    # direction: direction, enumeration type&#10;    block: MoveRobot = MoveRobot(step=10, direction=MoveRobotDirection.LEFTWARD)&#10;    # response : MoveRobotResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_move_robot result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, MoveRobotResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_move_robot failed')&#10;&#10;    return response&#10;&#10;&#10;# 测试, 获取支持的动作文件列表&#10;async def test_get_action_list() -&gt; GetActionListResponse:&#10;    &quot;&quot;&quot;Get action list demo&#10;&#10;     Get the list of built-in actions of the robot and wait for the reply result&#10;&#10;    &quot;&quot;&quot;&#10;    # action_type: INNER refers to the unmodifiable action file built into the robot, and CUSTOM is an action that can be modified by the developer placed in the sdcard/customize/action directory&#10;    block: GetActionList = GetActionList(action_type=RobotActionType.INNER)&#10;    # response:GetActionListResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_get_action_list result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, GetActionListResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_get_action_list failed')&#10;&#10;    return response&#10;&#10;&#10;async def run_actions_for_serial(serial: str, timeout: int = 10) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Connect to robot by serial tail, run a set of actions, and ensure cleanup.&#10;&#10;    Returns a dict with per-action results and an overall status.&#10;    &quot;&quot;&quot;&#10;    results: Dict[str, Any] = {&#10;        &quot;connected&quot;: False,&#10;        &quot;play_action&quot;: None,&#10;        &quot;move_robot&quot;: None,&#10;        &quot;get_action_list&quot;: None,&#10;        &quot;error&quot;: None,&#10;    }&#10;&#10;    from connect_service import connect_by_serial, shutdown&#10;&#10;    device = None&#10;    try:&#10;        device = await connect_by_serial(serial, timeout=timeout)&#10;        if not device:&#10;            results[&quot;error&quot;] = f&quot;device_not_found_or_connect_failed:{serial}&quot;&#10;            return results&#10;        results[&quot;connected&quot;] = True&#10;&#10;        try:&#10;            play_resp = await test_play_action()&#10;            results[&quot;play_action&quot;] = repr(play_resp)&#10;        except Exception as e:&#10;            results[&quot;play_action&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        try:&#10;            move_resp = await test_move_robot()&#10;            results[&quot;move_robot&quot;] = repr(move_resp)&#10;        except Exception as e:&#10;            results[&quot;move_robot&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        try:&#10;            list_resp = await test_get_action_list()&#10;            results[&quot;get_action_list&quot;] = repr(list_resp)&#10;        except Exception as e:&#10;            results[&quot;get_action_list&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        return results&#10;&#10;    except Exception as e:&#10;        results[&quot;error&quot;] = f&quot;unexpected_error:{e}&quot;&#10;        return results&#10;&#10;    finally:&#10;        try:&#10;            await shutdown()&#10;        except Exception as e:&#10;            print(f&quot;Error during shutdown: {e}&quot;)&#10;&#10;&#10;# Keep a small runnable example when executed directly&#10;async def _main_example():&#10;    await run_actions_for_serial('000341')&#10;&#10;&#10;if __name__ == '__main__':&#10;    asyncio.run(_main_example())&#10;" />
              <option name="updatedContent" value="import asyncio&#10;from typing import Any, Dict&#10;&#10;from mini.apis.api_action import GetActionList, GetActionListResponse, RobotActionType&#10;from mini.apis.api_action import MoveRobot, MoveRobotDirection, MoveRobotResponse&#10;from mini.apis.api_action import PlayAction, PlayActionResponse&#10;from mini.apis.base_api import MiniApiResultType&#10;&#10;&#10;# 测试, 执行一个动作文件&#10;async def test_play_action() -&gt; PlayActionResponse:&#10;    &quot;&quot;&quot;Perform an action demo&#10;&#10;     Control the robot to execute a local (built-in/custom) action with a specified name and wait for the execution result to reply&#10;&#10;     Action name can be obtained with GetActionList&#10;&#10;     #PlayActionResponse.isSuccess: Is it successful&#10;&#10;     #PlayActionResponse.resultCode: Return code&#10;&#10;     &quot;&quot;&quot;&#10;    # action_name: Action file name, you can get the actions supported by the robot through GetActionList&#10;    block: PlayAction = PlayAction(action_name='action_013')&#10;    # response: PlayActionResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_play_action result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, PlayActionResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_play_action failed')&#10;&#10;    return response&#10;&#10;&#10;# 测试, 控制机器人,向前/后/左/右 移动&#10;async def test_move_robot() -&gt; MoveRobotResponse:&#10;    &quot;&quot;&quot;Control the robot mobile demo&#10;&#10;     Control the robot to move 10 steps to the left (LEFTWARD) and wait for the execution result&#10;&#10;     #MoveRobotResponse.isSuccess: Is it successful　&#10;&#10;     #MoveRobotResponse.code: Return code&#10;&#10;     &quot;&quot;&quot;&#10;    # step: Move a few steps&#10;    # direction: direction, enumeration type&#10;    block: MoveRobot = MoveRobot(step=10, direction=MoveRobotDirection.LEFTWARD)&#10;    # response : MoveRobotResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_move_robot result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, MoveRobotResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_move_robot failed')&#10;&#10;    return response&#10;&#10;&#10;# 测试, 获取支持的动作文件列表&#10;async def test_get_action_list() -&gt; GetActionListResponse:&#10;    &quot;&quot;&quot;Get action list demo&#10;&#10;     Get the list of built-in actions of the robot and wait for the reply result&#10;&#10;    &quot;&quot;&quot;&#10;    # action_type: INNER refers to the unmodifiable action file built into the robot, and CUSTOM is an action that can be modified by the developer placed in the sdcard/customize/action directory&#10;    block: GetActionList = GetActionList(action_type=RobotActionType.INNER)&#10;    # response:GetActionListResponse&#10;    (resultType, response) = await block.execute()&#10;&#10;    print(f'test_get_action_list result:{response}')&#10;&#10;    if resultType != MiniApiResultType.Success or response is None or not isinstance(response, GetActionListResponse) or not response.isSuccess:&#10;        raise RuntimeError('test_get_action_list failed')&#10;&#10;    return response&#10;&#10;&#10;async def run_actions_for_serial(serial: str, timeout: int = 10) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Connect to robot by serial tail, run a set of actions, and ensure cleanup.&#10;&#10;    Returns a dict with per-action results and an overall status.&#10;    &quot;&quot;&quot;&#10;    results: Dict[str, Any] = {&#10;        &quot;connected&quot;: False,&#10;        &quot;play_action&quot;: None,&#10;        &quot;move_robot&quot;: None,&#10;        &quot;get_action_list&quot;: None,&#10;        &quot;error&quot;: None,&#10;    }&#10;&#10;    # Use package-qualified import so the module is found when running under the app package&#10;    from app.services.robot_sdk_control.connect_service import connect_by_serial, shutdown&#10;&#10;    device = None&#10;    try:&#10;        device = await connect_by_serial(serial, timeout=timeout)&#10;        if not device:&#10;            results[&quot;error&quot;] = f&quot;device_not_found_or_connect_failed:{serial}&quot;&#10;            return results&#10;        results[&quot;connected&quot;] = True&#10;&#10;        try:&#10;            play_resp = await test_play_action()&#10;            results[&quot;play_action&quot;] = repr(play_resp)&#10;        except Exception as e:&#10;            results[&quot;play_action&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        try:&#10;            move_resp = await test_move_robot()&#10;            results[&quot;move_robot&quot;] = repr(move_resp)&#10;        except Exception as e:&#10;            results[&quot;move_robot&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        try:&#10;            list_resp = await test_get_action_list()&#10;            results[&quot;get_action_list&quot;] = repr(list_resp)&#10;        except Exception as e:&#10;            results[&quot;get_action_list&quot;] = {&quot;error&quot;: str(e)}&#10;&#10;        return results&#10;&#10;    except Exception as e:&#10;        results[&quot;error&quot;] = f&quot;unexpected_error:{e}&quot;&#10;        return results&#10;&#10;    finally:&#10;        try:&#10;            await shutdown()&#10;        except Exception as e:&#10;            print(f&quot;Error during shutdown: {e}&quot;)&#10;&#10;&#10;# Keep a small runnable example when executed directly&#10;async def _main_example():&#10;    await run_actions_for_serial('000341')&#10;&#10;&#10;if __name__ == '__main__':&#10;    asyncio.run(_main_example())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/robot_sdk_control/connect_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/robot_sdk_control/connect_service.py" />
              <option name="originalContent" value="import logging&#10;from typing import Optional&#10;&#10;# Apply websocket compatibility patch before importing Mini SDK&#10;from websocket_patch import apply_websocket_patch&#10;apply_websocket_patch()&#10;&#10;import mini.mini_sdk as MiniSdk&#10;from mini.dns.dns_browser import WiFiDevice&#10;&#10;&#10;# To search for the robot with the specified serial number (behind the robot's butt), you can enter only the tail characters of the serial number, any length, it is recommended that more than 5 characters can be matched accurately, and the timeout is 10 seconds&#10;# The search result WiFiDevice, contains robot name, ip, port and other information&#10;async def test_get_device_by_name(serial_tail: str, timeout: int = 10) -&gt; Optional[WiFiDevice]:&#10;    &quot;&quot;&quot;Search for devices based on the suffix of the robot serial number&#10;&#10;     To search for the robot with the specified serial number (behind the robot's butt), you can enter only the tail characters of the serial number, any length, it is recommended that more than 5 characters can be matched accurately, and a timeout of 10 seconds&#10;&#10;&#10;     Returns:&#10;         WiFiDevice: Contains information such as robot name, ip, port, etc. Or None when not found.&#10;    &quot;&quot;&quot;&#10;    result: WiFiDevice = await MiniSdk.get_device_by_name(serial_tail, timeout)&#10;    print(f&quot;test_get_device_by_name('{serial_tail}') result:{result}&quot;)&#10;    return result&#10;&#10;&#10;async def connect_by_serial(serial_tail: str, timeout: int = 10) -&gt; Optional[WiFiDevice]:&#10;    &quot;&quot;&quot;Find device by serial tail and connect to it. Returns the connected WiFiDevice or None on failure.&quot;&quot;&quot;&#10;    device = await test_get_device_by_name(serial_tail, timeout)&#10;    if not device:&#10;        print(f&quot;No device found for serial: {serial_tail}&quot;)&#10;        return None&#10;&#10;    connected = await MiniSdk.connect(device)&#10;    if connected:&#10;        print(f&quot;Connected to device {device}&quot;)&#10;        return device&#10;    else:&#10;        print(f&quot;Failed to connect to device {device}&quot;)&#10;        return None&#10;&#10;&#10;# Enter the programming mode, the robot has a tts broadcast, here through asyncio.sleep, let the current coroutine wait 6 seconds to return, let the robot finish the broadcast&#10;async def test_start_run_program():&#10;    &quot;&quot;&quot;Enter programming mode demo&#10;&#10;     Make the robot enter the programming mode, wait for the reply result, and delay 6 seconds, let the robot finish &quot;Enter programming mode&quot;&#10;&#10;     Returns:&#10;         None:&#10;&#10;    &quot;&quot;&quot;&#10;    await MiniSdk.enter_program()&#10;&#10;&#10;# Disconnect and release resources&#10;async def shutdown():&#10;    &quot;&quot;&quot;Disconnect and release resources&#10;&#10;     Disconnect the currently connected device and release resources&#10;&#10;    &quot;&quot;&quot;&#10;    await MiniSdk.quit_program()&#10;    await MiniSdk.release()&#10;&#10;&#10;# The default log level is Warning, set to INFO&#10;MiniSdk.set_log_level(logging.INFO)&#10;# Set robot type&#10;MiniSdk.set_robot_type(MiniSdk.RobotType.EDU)&#10;&#10;&#10;# Note: module no longer runs standalone. Import its functions from routers or services.&#10;" />
              <option name="updatedContent" value="import logging&#10;from typing import Optional&#10;&#10;# Apply websocket compatibility patch before importing Mini SDK&#10;# import package-qualified so it works when running as part of the app package&#10;from app.services.robot_sdk_control.websocket_patch import apply_websocket_patch&#10;apply_websocket_patch()&#10;&#10;import mini.mini_sdk as MiniSdk&#10;from mini.dns.dns_browser import WiFiDevice&#10;&#10;&#10;# To search for the robot with the specified serial number (behind the robot's butt), you can enter only the tail characters of the serial number, any length, it is recommended that more than 5 characters can be matched accurately, and the timeout is 10 seconds&#10;# The search result WiFiDevice, contains robot name, ip, port and other information&#10;async def test_get_device_by_name(serial_tail: str, timeout: int = 10) -&gt; Optional[WiFiDevice]:&#10;    &quot;&quot;&quot;Search for devices based on the suffix of the robot serial number&#10;&#10;     To search for the robot with the specified serial number (behind the robot's butt), you can enter only the tail characters of the serial number, any length, it is recommended that more than 5 characters can be matched accurately, and a timeout of 10 seconds&#10;&#10;&#10;     Returns:&#10;         WiFiDevice: Contains information such as robot name, ip, port, etc. Or None when not found.&#10;    &quot;&quot;&quot;&#10;    result: WiFiDevice = await MiniSdk.get_device_by_name(serial_tail, timeout)&#10;    print(f&quot;test_get_device_by_name('{serial_tail}') result:{result}&quot;)&#10;    return result&#10;&#10;&#10;async def connect_by_serial(serial_tail: str, timeout: int = 10) -&gt; Optional[WiFiDevice]:&#10;    &quot;&quot;&quot;Find device by serial tail and connect to it. Returns the connected WiFiDevice or None on failure.&quot;&quot;&quot;&#10;    device = await test_get_device_by_name(serial_tail, timeout)&#10;    if not device:&#10;        print(f&quot;No device found for serial: {serial_tail}&quot;)&#10;        return None&#10;&#10;    connected = await MiniSdk.connect(device)&#10;    if connected:&#10;        print(f&quot;Connected to device {device}&quot;)&#10;        return device&#10;    else:&#10;        print(f&quot;Failed to connect to device {device}&quot;)&#10;        return None&#10;&#10;&#10;# Enter the programming mode, the robot has a tts broadcast, here through asyncio.sleep, let the current coroutine wait 6 seconds to return, let the robot finish the broadcast&#10;async def test_start_run_program():&#10;    &quot;&quot;&quot;Enter programming mode demo&#10;&#10;     Make the robot enter the programming mode, wait for the reply result, and delay 6 seconds, let the robot finish &quot;Enter programming mode&quot;&#10;&#10;     Returns:&#10;         None:&#10;&#10;    &quot;&quot;&quot;&#10;    await MiniSdk.enter_program()&#10;&#10;&#10;# Disconnect and release resources&#10;async def shutdown():&#10;    &quot;&quot;&quot;Disconnect and release resources&#10;&#10;     Disconnect the currently connected device and release resources&#10;&#10;    &quot;&quot;&quot;&#10;    await MiniSdk.quit_program()&#10;    await MiniSdk.release()&#10;&#10;&#10;# The default log level is Warning, set to INFO&#10;MiniSdk.set_log_level(logging.INFO)&#10;# Set robot type&#10;MiniSdk.set_robot_type(MiniSdk.RobotType.EDU)&#10;&#10;&#10;# Note: module no longer runs standalone. Import its functions from routers or services." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="fastapi&#10;uvicorn[standard]&#10;pydantic&#10;opencv-python&#10;pillow&#10;pytesseract&#10;pydub&#10;python-dotenv&#10;requests&#10;librosa&#10;numpy&#10;soundfile&#10;boto3&#10;openai-whisper&#10;protobuf&#10;python-multipart&#10;whisper&#10;google.generativeai&#10;email-validator&#10;alphamini&#10;" />
              <option name="updatedContent" value="fastapi&#10;uvicorn[standard]&#10;pydantic&#10;opencv-python&#10;pillow&#10;pytesseract&#10;pydub&#10;python-dotenv&#10;requests&#10;librosa&#10;numpy&#10;soundfile&#10;boto3&#10;openai-whisper&#10;protobuf==3.20.3&#10;python-multipart&#10;whisper&#10;google.generativeai&#10;email-validator&#10;alphamini" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>