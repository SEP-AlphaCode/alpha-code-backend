<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/routers/music_router.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/routers/music_router.py" />
              <option name="originalContent" value="from typing import Optional&#10;&#10;from fastapi import APIRouter&#10;from pydantic import BaseModel&#10;&#10;from app.services.audio.audio_service import convert_audio_to_wav_and_upload&#10;from app.services.music.planner import build_activity_json&#10;from fastapi import APIRouter, UploadFile, File, HTTPException, Body, Query&#10;&#10;router = APIRouter()&#10;&#10;&#10;class MusicRequest(BaseModel):&#10;    music_name: str&#10;    music_url: str&#10;    duration: float  # seconds&#10;&#10;&#10;@router.post('/generate-dance-plan')&#10;async def generate_dance_plan(req: MusicRequest):&#10;    return build_activity_json(req.music_name, req.music_url, req.duration)&#10;&#10;&#10;@router.post('/upload-music-and-generate-plan')&#10;async def upload_music_and_generate_plan(&#10;        file: UploadFile = File(...),&#10;        start_time: Optional[float] = Query(None, description=&quot;Start time in seconds (optional)&quot;, ge=0),&#10;        end_time: Optional[float] = Query(None, description=&quot;End time in seconds (optional)&quot;, ge=0)):&#10;    # Chỉ cho phép mp3 và mp4&#10;    if not (file.filename.lower().endswith(&quot;.mp3&quot;) or file.filename.lower().endswith(&quot;.mp4&quot;)):&#10;        raise HTTPException(status_code=400, detail=&quot;Only .mp3 or .mp4 files are supported.&quot;)&#10;&#10;    # Validate time parameters&#10;    if start_time is not None and end_time is not None and start_time &gt;= end_time:&#10;        raise HTTPException(status_code=400, detail=&quot;start_time must be less than end_time&quot;)&#10;&#10;    try:&#10;        result = await convert_audio_to_wav_and_upload(file, start_time=start_time, end_time=end_time)&#10;&#10;        # Add trimming info to response if parameters were provided&#10;&#10;        response_data = build_activity_json(result[&quot;file_name&quot;], result[&quot;url&quot;], result[&quot;duration&quot;])&#10;&#10;        # lấy phần data ra&#10;        new_res_data = response_data['data'].copy()&#10;&#10;        # map start_time / end_time vào music_info nếu có&#10;        if start_time is not None or end_time is not None:&#10;            new_res_data['music_info']['start_time'] = start_time&#10;            new_res_data['music_info']['end_time'] = end_time&#10;&#10;&#10;        return new_res_data&#10;            except ValueError as ve:&#10;                raise HTTPException(status_code=400, detail=str(ve))&#10;            except Exception as e:&#10;                raise HTTPException(status_code=500, detail=f&quot;Conversion or upload failed: {str(e)}&quot;)&#10;" />
              <option name="updatedContent" value="from typing import Optional&#10;&#10;from fastapi import APIRouter&#10;from pydantic import BaseModel&#10;&#10;from app.services.audio.audio_service import convert_audio_to_wav_and_upload&#10;from app.services.music.planner import build_activity_json&#10;from fastapi import APIRouter, UploadFile, File, HTTPException, Body, Query&#10;&#10;router = APIRouter()&#10;&#10;&#10;class MusicRequest(BaseModel):&#10;    music_name: str&#10;    music_url: str&#10;    duration: float  # seconds&#10;&#10;&#10;@router.post('/generate-dance-plan')&#10;async def generate_dance_plan(req: MusicRequest):&#10;    return build_activity_json(req.music_name, req.music_url, req.duration)&#10;&#10;&#10;@router.post('/upload-music-and-generate-plan')&#10;async def upload_music_and_generate_plan(&#10;        file: UploadFile = File(...),&#10;        start_time: Optional[float] = Query(None, description=&quot;Start time in seconds (optional)&quot;, ge=0),&#10;        end_time: Optional[float] = Query(None, description=&quot;End time in seconds (optional)&quot;, ge=0)):&#10;    # Chỉ cho phép mp3 và mp4&#10;    if not (file.filename.lower().endswith(&quot;.mp3&quot;) or file.filename.lower().endswith(&quot;.mp4&quot;)):&#10;        raise HTTPException(status_code=400, detail=&quot;Only .mp3 or .mp4 files are supported.&quot;)&#10;&#10;    # Validate time parameters&#10;    if start_time is not None and end_time is not None and start_time &gt;= end_time:&#10;        raise HTTPException(status_code=400, detail=&quot;start_time must be less than end_time&quot;)&#10;&#10;    try:&#10;        result = await convert_audio_to_wav_and_upload(file, start_time=start_time, end_time=end_time)&#10;&#10;        # Add trimming info to response if parameters were provided&#10;&#10;        response_data = build_activity_json(result[&quot;file_name&quot;], result[&quot;url&quot;], result[&quot;duration&quot;])&#10;&#10;        # lấy phần data ra&#10;        new_res_data = response_data['data'].copy()&#10;&#10;        # map start_time / end_time vào music_info nếu có&#10;        if start_time is not None or end_time is not None:&#10;            new_res_data['music_info']['start_time'] = start_time&#10;            new_res_data['music_info']['end_time'] = end_time&#10;&#10;&#10;        return new_res_data&#10;    except ValueError as ve:&#10;        raise HTTPException(status_code=400, detail=str(ve))&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Conversion or upload failed: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/socket/connection_manager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/socket/connection_manager.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;WebSocket Connection Manager&#10;Quản lý kết nối WebSocket với các robot&#10;&quot;&quot;&quot;&#10;from fastapi import WebSocket&#10;from typing import Dict, List&#10;import logging&#10;&#10;&#10;class WSMapEntry:&#10;    websocket: WebSocket&#10;    client_id: str&#10;    def __init__(self, websocket, client_id):&#10;        self.client_id = client_id&#10;        self.websocket = websocket&#10;    &#10;class ConnectionManager:&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        # Store clients as {serial: websocket}&#10;        self.clients: Dict[str, WSMapEntry] = {}&#10;        self.logger = logging.getLogger(__name__)&#10;    &#10;    async def connect(self, websocket: WebSocket, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Kết nối WebSocket với robot&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#10;        &quot;&quot;&quot;&#10;        # if websocket.headers.get('client_id') is None:&#10;        #     await websocket.close(code=1008, reason=&quot;Socket has no client id&quot;)&#10;        #     return False&#10;        &#10;        # Kiểm tra nếu serial đã tồn tại&#10;        # if serial in self.clients:&#10;        #     try:&#10;        #         # Nếu không có lỗi, kết nối vẫn active&#10;        #         print(f&quot;Từ chối kết nối từ robot {serial}, đã có kết nối active&quot;)&#10;        #&#10;        #         # Thông báo cho client lý do từ chối&#10;        #         try:&#10;        #             await websocket.close(code=1008, reason=&quot;Robot with this serial is already connected&quot;)&#10;        #         except Exception as e:&#10;        #             self.logger.error(f&quot;Lỗi khi từ chối kết nối: {e}&quot;)&#10;        #         return False&#10;        #&#10;        #     except Exception as e:&#10;        #         # Nếu có lỗi, kết nối cũ đã bị ngắt nhưng chưa được dọn dẹp&#10;        #         self.logger.info(f&quot;Cleaning up stale connection for {serial}: {e}&quot;)&#10;        #         await self.disconnect(serial)&#10;        # Nếu serial chưa tồn tại hoặc kết nối cũ đã bị ngắt, cho phép kết nối mới&#10;        await websocket.accept()&#10;        self.clients[serial] = WSMapEntry(websocket, websocket.headers.get('client_id'))&#10;        self.logger.info(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#10;        return True&#10;    &#10;    async def disconnect(self, serial: str):&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#10;        if serial in self.clients:&#10;            await self.clients[serial].websocket.close()&#10;            del self.clients[serial]&#10;        else:&#10;            self.logger.warning(f&quot;Attempted to disconnect robot {serial} but it was not connected&quot;)&#10;    &#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#10;        &quot;&quot;&quot;Gửi message tới robot&quot;&quot;&quot;&#10;        ws = self.clients.get(serial).websocket&#10;        if ws:&#10;            try:&#10;                await ws.send_text(message)&#10;                return True&#10;            except Exception as e:&#10;                self.logger.error(f&quot;Send error to {serial}: {e}&quot;)&#10;                await self.disconnect(serial)&#10;        else:&#10;            self.logger.warning(f&quot;Cannot send message to {serial}: robot not connected&quot;)&#10;        return False&#10;    &#10;    @property&#10;    def active(self) -&gt; int:&#10;        &quot;&quot;&quot;Số lượng robot đang kết nối&quot;&quot;&quot;&#10;        return len(self.clients)&#10;    &#10;    def is_connected(self, serial: str) -&gt; bool:&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#10;        return serial in self.clients&#10;    &#10;    def get_connected_serials(self) -&gt; List[str]:&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#10;        return list(self.clients.keys())&#10;&#10;&#10;# Tạo instance global&#10;connection_manager = ConnectionManager()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#13;&#10;WebSocket Connection Manager&#13;&#10;Quản lý kết nối WebSocket với các robot&#13;&#10;&quot;&quot;&quot;&#13;&#10;from fastapi import WebSocket&#13;&#10;from typing import Dict, List&#13;&#10;import logging&#13;&#10;&#13;&#10;&#13;&#10;class WSMapEntry:&#13;&#10;    websocket: WebSocket&#13;&#10;    client_id: str&#13;&#10;    def __init__(self, websocket, client_id):&#13;&#10;        self.client_id = client_id&#13;&#10;        self.websocket = websocket&#13;&#10;    &#13;&#10;class ConnectionManager:&#13;&#10;    &quot;&quot;&quot;Quản lý kết nối WebSocket với robot&quot;&quot;&quot;&#13;&#10;    &#13;&#10;    def __init__(self):&#13;&#10;        # Store clients as {serial: websocket}&#13;&#10;        self.clients: Dict[str, WSMapEntry] = {}&#13;&#10;        self.logger = logging.getLogger(__name__)&#13;&#10;    &#13;&#10;    async def connect(self, websocket: WebSocket, serial: str) -&gt; bool:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Kết nối WebSocket với robot&#13;&#10;        Trả về True nếu kết nối thành công, False nếu từ chối&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # if websocket.headers.get('client_id') is None:&#13;&#10;        #     await websocket.close(code=1008, reason=&quot;Socket has no client id&quot;)&#13;&#10;        #     return False&#13;&#10;        &#13;&#10;        # Kiểm tra nếu serial đã tồn tại&#13;&#10;        # if serial in self.clients:&#13;&#10;        #     try:&#13;&#10;        #         # Nếu không có lỗi, kết nối vẫn active&#13;&#10;        #         print(f&quot;Từ chối kết nối từ robot {serial}, đã có kết nối active&quot;)&#13;&#10;        #&#13;&#10;        #         # Thông báo cho client lý do từ chối&#13;&#10;        #         try:&#13;&#10;        #             await websocket.close(code=1008, reason=&quot;Robot with this serial is already connected&quot;)&#13;&#10;        #         except Exception as e:&#13;&#10;        #             self.logger.error(f&quot;Lỗi khi từ chối kết nối: {e}&quot;)&#13;&#10;        #         return False&#13;&#10;        #&#13;&#10;        #     except Exception as e:&#13;&#10;        #         # Nếu có lỗi, kết nối cũ đã bị ngắt nhưng chưa được dọn dẹp&#13;&#10;        #         self.logger.info(f&quot;Cleaning up stale connection for {serial}: {e}&quot;)&#13;&#10;        #         await self.disconnect(serial)&#13;&#10;        # Nếu serial chưa tồn tại hoặc kết nối cũ đã bị ngắt, cho phép kết nối mới&#13;&#10;        await websocket.accept()&#13;&#10;        self.clients[serial] = WSMapEntry(websocket, websocket.headers.get('client_id'))&#13;&#10;        self.logger.info(f&quot;Robot {serial} connected. Total: {len(self.clients)}&quot;)&#13;&#10;        return True&#13;&#10;    &#13;&#10;    async def disconnect(self, serial: str):&#13;&#10;        &quot;&quot;&quot;Ngắt kết nối robot&quot;&quot;&quot;&#13;&#10;        if serial in self.clients:&#13;&#10;            await self.clients[serial].websocket.close()&#13;&#10;            del self.clients[serial]&#13;&#10;        else:&#13;&#10;            self.logger.warning(f&quot;Attempted to disconnect robot {serial} but it was not connected&quot;)&#13;&#10;    &#13;&#10;    async def send_to_robot(self, serial: str, message: str) -&gt; bool:&#13;&#10;        &quot;&quot;&quot;Gửi message tới robot&quot;&quot;&quot;&#13;&#10;        client = self.clients.get(serial)&#13;&#10;        if client and hasattr(client, 'websocket'):&#13;&#10;            ws = client.websocket&#13;&#10;            if ws:&#13;&#10;                try:&#13;&#10;                    await ws.send_text(message)&#13;&#10;                    return True&#13;&#10;                except Exception as e:&#13;&#10;                    self.logger.error(f&quot;Send error to {serial}: {e}&quot;)&#13;&#10;                    await self.disconnect(serial)&#13;&#10;            else:&#13;&#10;                self.logger.warning(f&quot;Cannot send message to {serial}: websocket not available&quot;)&#13;&#10;        else:&#13;&#10;            self.logger.warning(f&quot;Cannot send message to {serial}: robot not connected&quot;)&#13;&#10;        return False&#13;&#10;    &#13;&#10;    @property&#13;&#10;    def active(self) -&gt; int:&#13;&#10;        &quot;&quot;&quot;Số lượng robot đang kết nối&quot;&quot;&quot;&#13;&#10;        return len(self.clients)&#13;&#10;    &#13;&#10;    def is_connected(self, serial: str) -&gt; bool:&#13;&#10;        &quot;&quot;&quot;Kiểm tra robot có đang kết nối không&quot;&quot;&quot;&#13;&#10;        return serial in self.clients&#13;&#10;    &#13;&#10;    def get_connected_serials(self) -&gt; List[str]:&#13;&#10;        &quot;&quot;&quot;Lấy danh sách các serial đang kết nối&quot;&quot;&quot;&#13;&#10;        return list(self.clients.keys())&#13;&#10;&#13;&#10;&#13;&#10;# Tạo instance global&#13;&#10;connection_manager = ConnectionManager()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>